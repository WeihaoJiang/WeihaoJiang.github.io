<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="android，基础," />










<meta name="description" content="背景以及夙愿 1 练习博客排版 2 尝试阅读源码，从熟悉的handler开始 3 习惯养成  handler是什么？Handler主要用于异步消息的处理： 有点类似辅助类，封装了消息投递、消息处理等接口。当发出一个消息之后，首先进入一个消息队列，发送消息的函数即刻返回，而另外一个部分在消息队列中逐一将消息取出，然后对消息进行处理，也就是发送消息和接收消息不是同步的处理。 这种机制通常用来处理相对耗">
<meta name="keywords" content="android，基础">
<meta property="og:type" content="article">
<meta property="og:title" content="handler学习总结">
<meta property="og:url" content="http://yoursite.com/2018/09/09/handler_sum/index.html">
<meta property="og:site_name" content="Coding_dog的成长笔记">
<meta property="og:description" content="背景以及夙愿 1 练习博客排版 2 尝试阅读源码，从熟悉的handler开始 3 习惯养成  handler是什么？Handler主要用于异步消息的处理： 有点类似辅助类，封装了消息投递、消息处理等接口。当发出一个消息之后，首先进入一个消息队列，发送消息的函数即刻返回，而另外一个部分在消息队列中逐一将消息取出，然后对消息进行处理，也就是发送消息和接收消息不是同步的处理。 这种机制通常用来处理相对耗">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s1.ax1x.com/2018/09/15/iV8gAA.gif">
<meta property="og:image" content="https://s1.ax1x.com/2018/09/27/iMbeEj.png">
<meta property="og:updated_time" content="2018-11-29T03:46:44.518Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="handler学习总结">
<meta name="twitter:description" content="背景以及夙愿 1 练习博客排版 2 尝试阅读源码，从熟悉的handler开始 3 习惯养成  handler是什么？Handler主要用于异步消息的处理： 有点类似辅助类，封装了消息投递、消息处理等接口。当发出一个消息之后，首先进入一个消息队列，发送消息的函数即刻返回，而另外一个部分在消息队列中逐一将消息取出，然后对消息进行处理，也就是发送消息和接收消息不是同步的处理。 这种机制通常用来处理相对耗">
<meta name="twitter:image" content="https://s1.ax1x.com/2018/09/15/iV8gAA.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/09/09/handler_sum/"/>





  <title>handler学习总结 | Coding_dog的成长笔记</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding_dog的成长笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/09/handler_sum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">handler学习总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-09T00:00:00+08:00">
                2018-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/09/handler_sum/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/09/09/handler_sum/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="背景以及夙愿"><a href="#背景以及夙愿" class="headerlink" title="背景以及夙愿"></a>背景以及夙愿</h2><ul>
<li>1 练习博客排版</li>
<li>2 尝试阅读源码，从熟悉的handler开始</li>
<li>3 习惯养成</li>
</ul>
<h2 id="handler是什么？"><a href="#handler是什么？" class="headerlink" title="handler是什么？"></a>handler是什么？</h2><p>Handler主要用于异步消息的处理： 有点类似辅助类，封装了消息投递、消息处理等接口。当发出一个消息之后，首先进入一个消息队列，发送消息的函数即刻返回，而另外一个部分在消息队列中逐一将消息取出，然后对消息进行处理，也就是发送消息和接收消息不是同步的处理。 这种机制通常用来处理相对耗时比较长的操作。</p>
<h2 id="handler使用场景"><a href="#handler使用场景" class="headerlink" title="handler使用场景"></a>handler使用场景</h2><p>在Android系统中出于性能优化考虑，Android的UI操作并不是线程安全的，这意味着如果有多个线程并发操作UI组件，可能导致线程安全问题。为了解决这个问题，Android制定了一条简单的原则，只允许UI线程（亦即主线程）修改Activity中的UI组件。但实际上，有部分UI需要在子线程中控制其修改逻辑，因此子线程需要通过handler通知主线程修改UI，实现线程间通信。</p>
<h2 id="handler的使用"><a href="#handler的使用" class="headerlink" title="handler的使用"></a>handler的使用</h2><h3 id="1-post或postDelayed"><a href="#1-post或postDelayed" class="headerlink" title="1 post或postDelayed"></a>1 post或postDelayed</h3><p>区别在于一个立即执行，一个延时执行<br>下面以延时操作为例</p>
<p>直接上代码举个小例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Handler().postDelayed(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        goHome();//可做UI操作等等</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 2000); // 延时2秒</span><br></pre></td></tr></table></figure></p>
<h3 id="2-sendMessage"><a href="#2-sendMessage" class="headerlink" title="2 sendMessage"></a>2 sendMessage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private TabLayout mTab;</span><br><span class="line">    private ViewPager mVp;</span><br><span class="line">    private ViewPagerAapter mvpAapter;</span><br><span class="line">    public ArrayList&lt;String&gt; mlist = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public ArrayList&lt;ImageView&gt; mlistIv = new ArrayList&lt;&gt;();</span><br><span class="line">    private ImageView v1, v2, v3;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mVp = findViewById(R.id.view1);</span><br><span class="line">        mTab = findViewById(R.id.tab);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line"></span><br><span class="line">        mlist.add(&quot;daxifu&quot;);</span><br><span class="line">        mlist.add(&quot;erxifu&quot;);</span><br><span class="line">        mlist.add(&quot;sanxifu&quot;);</span><br><span class="line"></span><br><span class="line">        //mTab.setTabMode(TabLayout.MODE_FIXED);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; mlist.size(); i++) &#123;</span><br><span class="line">            mTab.addTab(mTab.newTab().setText(mlist.get(i)));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        v1 = new ImageView(this);</span><br><span class="line">        v2 = new ImageView(this);</span><br><span class="line">        v3 = new ImageView(this);</span><br><span class="line"></span><br><span class="line">        v1.setImageResource(R.drawable.app_launch_01);</span><br><span class="line">        v2.setImageResource(R.drawable.app_launch_02);</span><br><span class="line">        v3.setImageResource(R.drawable.app_launch_03);</span><br><span class="line"></span><br><span class="line">//        v1.setScaleType(ImageView.ScaleType.FIT_XY);</span><br><span class="line">//        v2.setScaleType(ImageView.ScaleType.FIT_XY);</span><br><span class="line">//        v3.setScaleType(ImageView.ScaleType.FIT_XY);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mlistIv.add(v1);</span><br><span class="line">        mlistIv.add(v2);</span><br><span class="line">        mlistIv.add(v3);</span><br><span class="line"></span><br><span class="line">        mTab.setupWithViewPager(mVp);</span><br><span class="line"></span><br><span class="line">        mvpAapter = new ViewPagerAapter(mlist, mlistIv);</span><br><span class="line">        mVp.setAdapter(mvpAapter);</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line"></span><br><span class="line">                for (int i  = 1; i &lt; 4; i++)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(3000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Message message = new Message();</span><br><span class="line">                    message.what = i;</span><br><span class="line"></span><br><span class="line">                    mhandler.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    private Handler mhandler = new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    v1.setImageResource(R.drawable.app_fuli_01);</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    v2.setImageResource(R.drawable.app_fuli_02);</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">                case 3:</span><br><span class="line">                    v3.setImageResource(R.drawable.app_fuli_03);</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><img src="https://s1.ax1x.com/2018/09/15/iV8gAA.gif" alt="图片"></p>
<h3 id="handler的内存泄漏"><a href="#handler的内存泄漏" class="headerlink" title="handler的内存泄漏"></a>handler的内存泄漏</h3><p>上面的代码有没有发现一些问题或风险，没错就是内存泄漏</p>
<h4 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h4><p>Java使用有向图机制，通过GC自动检查内存中的对象（什么时候检查由虚拟机决定），如果GC发现一个或一组对象为不可到达状态，则将该对象从内存中回收。也就是说，一个对象不被任何引用所指向，则该对象会在被GC发现的时候被回收；另外，如果一组对象中只包含互相的引用，而没有来自它们外部的引用（例如有两个对象A和B互相持有引用，但没有任何外部对象持有指向A或B的引用），这仍然属于不可到达，同样会被GC回收。而一旦GC因为某些对象持有外部引用而无法回收资源时就会发生内存泄露，这部分内存即没有被使用又无法被回收，积少成多就会造成oom，以现在的手机性能造成oom的情况极少，但内存泄露处理仍是android代码质量高低的重要标准之一</p>
<h4 id="为什么handler会造成内存泄露"><a href="#为什么handler会造成内存泄露" class="headerlink" title="为什么handler会造成内存泄露"></a>为什么handler会造成内存泄露</h4><p>当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用（不然你怎么可能通过Handler来操作Activity中的View？）。而Handler通常会伴随着一个耗时的后台线程（例如从网络拉取图片）一起出现，这个后台线程在任务执行完毕（例如图片下载完毕）之后，通过消息机制通知Handler，然后Handler把图片更新到界面。然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用（不然它怎么发消息给Handler？），这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束（例如图片下载完毕）。另外，如果你执行了Handler的postDelayed()方法，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，那么在你设定的delay到达之前，会有一条MessageQueue -&gt; Message -&gt; Handler -&gt; Activity的链，导致你的Activity被持有引用而无法被回收。</p>
<h4 id="如何来处理handler内存泄露"><a href="#如何来处理handler内存泄露" class="headerlink" title="如何来处理handler内存泄露"></a>如何来处理handler内存泄露</h4><p>目前方式有如下几种</p>
<h5 id="方法一：通过程序逻辑来进行保护。"><a href="#方法一：通过程序逻辑来进行保护。" class="headerlink" title="方法一：通过程序逻辑来进行保护。"></a>方法一：通过程序逻辑来进行保护。</h5><p>1.在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。</p>
<p>2.如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。</p>
<h5 id="方法二：将Handler声明为静态类和加入弱引用"><a href="#方法二：将Handler声明为静态类和加入弱引用" class="headerlink" title="方法二：将Handler声明为静态类和加入弱引用"></a>方法二：将Handler声明为静态类和加入弱引用</h5><p>有很多文章说设为静态类就可以了，但是实际操作事会发现，由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）：</p>
<h6 id="小扩展：什么是弱引用？"><a href="#小扩展：什么是弱引用？" class="headerlink" title="小扩展：什么是弱引用？"></a>小扩展：什么是弱引用？</h6><p>WeakReference弱引用，与强引用（即我们常说的引用）相对，它的特点是，GC在回收时会忽略掉弱引用，即就算有弱引用指向某对象，但只要该对象没有被强引用指向（实际上多数时候还要求没有软引用，但此处软引用的概念可以忽略），该对象就会在被GC检查到时回收掉。对于上面的代码，用户在关闭Activity之后，就算后台线程还没结束，但由于仅有一条来自Handler的弱引用指向Activity，所以GC仍然会在检查的时候把Activity回收掉。这样，内存泄露的问题就不会出现了。</p>
<h6 id="上面的杨幂demo修正版本："><a href="#上面的杨幂demo修正版本：" class="headerlink" title="上面的杨幂demo修正版本："></a>上面的杨幂demo修正版本：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">//仅给出部分代码，主要看handler的变动</span><br><span class="line">  @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line">        final MyHandler myHandler = new MyHandler(this);</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line"></span><br><span class="line">                for (int i  = 1; i &lt; 4; i++)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(3000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Message message = new Message();</span><br><span class="line">                    message.what = i;</span><br><span class="line"></span><br><span class="line">                    myHandler.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   class MyHandler extends Handler&#123;</span><br><span class="line"></span><br><span class="line">        WeakReference&lt;SwipeViewPager&gt; mWeak;</span><br><span class="line"></span><br><span class="line">        public MyHandler(SwipeViewPager swipeViewPager) &#123;</span><br><span class="line">            mWeak = new WeakReference&lt;SwipeViewPager&gt;(swipeViewPager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">            SwipeViewPager swipeViewPager = (SwipeViewPager) mWeak.get();</span><br><span class="line"></span><br><span class="line">            if (swipeViewPager != null) &#123;</span><br><span class="line">                switch (msg.what) &#123;</span><br><span class="line">                    case AUTO_SCORLL:</span><br><span class="line">                        if (isStart) &#123;</span><br><span class="line">                            if (vpAd.getChildCount() &gt; 1) &#123;</span><br><span class="line">                                vpAd.setCurrentItem(vpAd.getCurrentItem() + 1, true);</span><br><span class="line">                            &#125;</span><br><span class="line">                            mHandler.sendEmptyMessageDelayed(AUTO_SCORLL, 5000);</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="handler源码分析"><a href="#handler源码分析" class="headerlink" title="handler源码分析"></a>handler源码分析</h2><h3 id="handler机制概括"><a href="#handler机制概括" class="headerlink" title="handler机制概括"></a>handler机制概括</h3><p>首先用一张图来概括handler以及它的四大“组件”的工作过程</p>
<p><img src="https://s1.ax1x.com/2018/09/27/iMbeEj.png" alt="图片"><br> handler具有两个功能，1.发送消息 2.处理消息<br> handler将消息发送到消息队列，由looper通过轮询从消息队列中将消息取出并派发(通过dispatchMessage()方法)给相应的hanndler，再通过重写handleMessage()方法处理。</p>
<h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>找到构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">        this(null, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> this跟进去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">       if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">           final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">           if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                   (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">               Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                   klass.getCanonicalName());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mLooper = Looper.myLooper(); //指定了looper对象</span><br><span class="line">       if (mLooper == null) &#123;</span><br><span class="line">           //如果是在子线程中，没有首先调用Looper.prepare()的话就会抛出该异常，具体原因稍后分析looper时再分析</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">               &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       mQueue = mLooper.mQueue;   //绑定消息队列</span><br><span class="line">       mCallback = callback;</span><br><span class="line">       mAsynchronous = async;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到主要做了两件事</p>
<ul>
<li>1 指定了looper对象</li>
<li>2 绑定消息队列<br>那么问题来了，我们需要看一下looper的源码，本菜鸡看的时候着实被吓一跳，没有头绪苦思冥想一番想到看一眼官方文档是怎么介绍它的，以下是官网给的使用范例</li>
</ul>
<h3 id="looper"><a href="#looper" class="headerlink" title="looper"></a>looper</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LooperThread extends Thread &#123;</span><br><span class="line">    public Handler mHandler;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line"></span><br><span class="line">        mHandler = new Handler() &#123;</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                // process incoming messages here</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到调用顺序</p>
<ul>
<li>1 Looper.prepare()</li>
<li>2 Looper.loop()<br>以下分别贴出源码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void prepare() &#123;</span><br><span class="line">     prepare(true);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">     if (sThreadLocal.get() != null) &#123; //看这里</span><br><span class="line">         //ThreadLocal相当于一个容器，是线程内部的数据存储类，通过它可以在指定线程中存储数据，</span><br><span class="line">         只有在指定线程中才能获取到存储的数据，对于其他线程是无法获取到的，通过对sThreadLocal.get()的判空，保证了一个线程只能set一个looper</span><br><span class="line">         throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>sThreadLocal若为null则new一个looper对象，若不为null抛出异常。<br>说明</p>
<ul>
<li>1 Looper.prepare()只能调用一次</li>
<li>2 一个线程中仅有一个looper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123; </span><br><span class="line"></span><br><span class="line">      final Looper me = myLooper();</span><br><span class="line">      if (me == null) &#123;</span><br><span class="line">          throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //获取looper实例中的消息队列</span><br><span class="line">      final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">      // Make sure the identity of this thread is that of the local process,</span><br><span class="line">      // and keep track of what that identity token actually is.</span><br><span class="line">      Binder.clearCallingIdentity();</span><br><span class="line">      final long ident = Binder.clearCallingIdentity();</span><br><span class="line">      //无限遍历</span><br><span class="line">      for (;;) &#123; </span><br><span class="line">          //从消息队列中取出消息</span><br><span class="line">          Message msg = queue.next(); // might block</span><br><span class="line">          if (msg == null) &#123;</span><br><span class="line">              // No message indicates that the message queue is quitting.（若取出消息为null则线程阻塞 --翻译一下怕后期自己看不懂）</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">          final Printer logging = me.mLogging;</span><br><span class="line">          if (logging != null) &#123;</span><br><span class="line">              logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                      msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">          final long traceTag = me.mTraceTag;</span><br><span class="line">          if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">              Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">          &#125;</span><br><span class="line">          final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">          final long end;</span><br><span class="line">          try &#123;</span><br><span class="line">              //把消息分发给hangler，稍后分析源码</span><br><span class="line">              msg.target.dispatchMessage(msg);</span><br><span class="line">              end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              if (traceTag != 0) &#123;</span><br><span class="line">                  Trace.traceEnd(traceTag);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (slowDispatchThresholdMs &gt; 0) &#123;</span><br><span class="line">              final long time = end - start;</span><br><span class="line">              if (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                  Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;</span><br><span class="line">                          + Thread.currentThread().getName() + &quot;, h=&quot; +</span><br><span class="line">                          msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (logging != null) &#123;</span><br><span class="line">              logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Make sure that during the course of dispatching the</span><br><span class="line">          // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">          final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">          if (ident != newIdent) &#123;</span><br><span class="line">              Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                      + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                      + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                      + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                      + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">          &#125;</span><br><span class="line">          //释放</span><br><span class="line">          msg.recycleUnchecked();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="曾经的疑问之一：用handler用了好多次，哪次也没写looper-prepare-和looper-loop-也跑的好好的。"><a href="#曾经的疑问之一：用handler用了好多次，哪次也没写looper-prepare-和looper-loop-也跑的好好的。" class="headerlink" title="曾经的疑问之一：用handler用了好多次，哪次也没写looper.prepare()和looper.loop()也跑的好好的。"></a>曾经的疑问之一：用handler用了好多次，哪次也没写looper.prepare()和looper.loop()也跑的好好的。</h4><p>读完源码发现，早在UI线程创建之初，就绑定了一个looper，凡是在主线程中显示什么什么，都不需要我们自己初始化looper，默认使用主线程的looper，那么代码中是什么时候创建主线程的looper的呢，再上一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//在Android应用进程启动时，会默认创建1个主线程</span><br><span class="line">// 创建时，会自动调用ActivityThread的1个静态的main（）方法 = 应用程序的入口</span><br><span class="line">// main（）内则会调用Looper.prepareMainLooper()为主线程生成1个Looper对象</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">        // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">        // disable it here, but selectively enable it later (via</span><br><span class="line">        // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">        CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        // Set the reporter for event logging in libcore</span><br><span class="line">        EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">        // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // End of event ActivityThreadMain.</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="dispatchMessage-msg-分析"><a href="#dispatchMessage-msg-分析" class="headerlink" title="dispatchMessage(msg)分析"></a>dispatchMessage(msg)分析</h3><p>下面我们看dispatchMessage(msg)是如何把消息分发给handler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Handle system messages here.</span><br><span class="line">    */</span><br><span class="line">   public void dispatchMessage(Message msg) &#123;</span><br><span class="line">       if (msg.callback != null) &#123;</span><br><span class="line">           handleCallback(msg); </span><br><span class="line"></span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (mCallback != null) &#123;</span><br><span class="line">               if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //若msg.callback属性为空，则代表使用了sendMessage</span><br><span class="line">           handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>1 检查message的callback是否为null，不为空就交给handleCallback(msg)来处理消息，<br>message的callback是一个runnable对象，实际就是handler.post()所传递的runnable参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static void handleCallback(Message message) &#123;</span><br><span class="line">       message.callback.run();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 检查mCallback是否为空，不为空就调用mCallback.handleMessage(msg)来处理消息，Callback是一个接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Callback interface you can use when instantiating a Handler to avoid</span><br><span class="line">  * having to implement your own subclass of Handler.</span><br><span class="line">  *</span><br><span class="line">  * @param msg A &#123;@link android.os.Message Message&#125; object</span><br><span class="line">  * @return True if no further handling is desired</span><br><span class="line">  */</span><br><span class="line"> public interface Callback &#123;</span><br><span class="line">     public boolean handleMessage(Message msg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 通过callback可以使用Handler mhandler = new Handler(Callback)来创建handler对象，那么callback是什么呢？<br> 上文注释里给出了说明：当不想派生handler的子类时可以使用callback创建handler对象，下面是本例使用callback创建的代码（本人不建议使用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity implements Callback&#123;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  中间代码</span><br><span class="line">   </span><br><span class="line">  */</span><br><span class="line">  @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">      super.onResume();</span><br><span class="line">      final Handler mhandler = new Handler(this);</span><br><span class="line">      new Thread()&#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              super.run();</span><br><span class="line"></span><br><span class="line">              for (int i  = 1; i &lt; 4; i++)&#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      Thread.sleep(3000);</span><br><span class="line">                  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                  Message message = new Message();</span><br><span class="line">                  message.what = i;</span><br><span class="line">                  mhandler.sendMessage(message);</span><br><span class="line">               &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">    @Override</span><br><span class="line">     public boolean handleMessage(Message msg) &#123;</span><br><span class="line">      switch (msg.what) &#123;</span><br><span class="line">          case 1:</span><br><span class="line">              v1.setImageResource(R.drawable.app_fuli_01);</span><br><span class="line"></span><br><span class="line">              break;</span><br><span class="line">          case 2:</span><br><span class="line">              v2.setImageResource(R.drawable.app_fuli_02);</span><br><span class="line"></span><br><span class="line">              break;</span><br><span class="line">          case 3:</span><br><span class="line">              v3.setImageResource(R.drawable.app_fuli_03);</span><br><span class="line"></span><br><span class="line">              break;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 最后通过handleMessage来处理消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Subclasses must implement this to receive messages.</span><br><span class="line">  */</span><br><span class="line"> public void handleMessage(Message msg) &#123;</span><br><span class="line">     //这是一个空方法，需要我们自己在代码业务中重写</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="MessageQueen"><a href="#MessageQueen" class="headerlink" title="MessageQueen"></a>MessageQueen</h3><p>我们一直称呼它为消息队列，但实际它是一个单链表结构，在handler机制中我们设计MessageQueen的两个方法，取出和插入</p>
<h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">        // Return here if the message loop has already quit and been disposed.</span><br><span class="line">        // This can happen if the application tries to restart a looper after quit</span><br><span class="line">        // which is not supported.</span><br><span class="line">        final long ptr = mPtr;</span><br><span class="line">        if (ptr == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">        int nextPollTimeoutMillis = 0;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                // Try to retrieve the next message.  Return if found.</span><br><span class="line">                final long now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = null;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                    // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                    do &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                if (msg != null) &#123;</span><br><span class="line">                    if (now &lt; msg.when) &#123;</span><br><span class="line">                        // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // Got a message.</span><br><span class="line">                        mBlocked = false;</span><br><span class="line">                        if (prevMsg != null) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = null;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        return msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // No more messages.</span><br><span class="line">                    nextPollTimeoutMillis = -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Process the quit message now that all pending messages have been handled.</span><br><span class="line">                if (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // If first time idle, then get the number of idlers to run.</span><br><span class="line">                // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">                // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">                if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                    // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                    mBlocked = true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Run the idle handlers.</span><br><span class="line">            // We only ever reach this code block during the first iteration.</span><br><span class="line">            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">                boolean keep = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!keep) &#123;</span><br><span class="line">                    synchronized (this) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">            pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">            // While calling an idle handler, a new message could have been delivered</span><br><span class="line">            // so go back and look again for a pending message without waiting.</span><br><span class="line">            nextPollTimeoutMillis = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>简单的说，这个函数就是从从头Head取出下一个Message，如果队列中没有message了，那么则可以取处理IdleHandler接口。当队列中没有消息或者消息指定了等待时间，那么线程会进入等待状态。<br>函数中有两个变量<br>int pendingIdleHandlerCount = -1;空闲的IdleHandler个数，只有在第一次迭代的时候为-1。<br>int nextPollTimeoutMillis = 0;下一轮等待时间，如果当前消息队列中没哟消息，需要等待的时间。<br>如果等待时间不为零，执行flush pending command，刷新等待时间。然后执行nativePollOnce(ptr, nextPollTimeoutMillis);其功能是查询消息队列中有没有消息。如果消息为空，那么nextPollTimeoutMillis=-1，接着等待消息，如果不为空，那么就处理这个消息。当我们设置的等待时间到了，将msg从Message中取出来并返回msg，如果没有返回，则说明没有消息需要处理，既然没有消息需要处理，检查以下是否要退出队列，如果退出返回null，否则那么就可以处理IdleHandler，处理完IdleHandler后将nextPollTimeoutMillis设为0（因为在处理IdleHandler的时候可能来消息），重新检测消息。</p>
<h4 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage()"></a>enqueueMessage()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">     if (msg.target == null) &#123;</span><br><span class="line">         throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     if (msg.isInUse()) &#123;</span><br><span class="line">         throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     synchronized (this) &#123;</span><br><span class="line">         if (mQuitting) &#123;</span><br><span class="line">             IllegalStateException e = new IllegalStateException(</span><br><span class="line">                     msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">             Log.w(TAG, e.getMessage(), e);</span><br><span class="line">             msg.recycle();</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         msg.markInUse();</span><br><span class="line">         msg.when = when;</span><br><span class="line">         Message p = mMessages;</span><br><span class="line">         boolean needWake;</span><br><span class="line"></span><br><span class="line">         //判断，如果mMessages对象为空，或者when为0也就是立刻执行，或者新消息的when时间比mMessages队列的when时间还要早</span><br><span class="line">         if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">             // New head, wake up the event queue if blocked.</span><br><span class="line">             //官方注释，当前消息作为新的队列头部，如果阻塞则唤醒</span><br><span class="line">             //就把新的msg插到mMessages的前面 并把next指向它，也就是队列的最前面，等待loop的轮询。</span><br><span class="line">             msg.next = p;</span><br><span class="line">             mMessages = msg;</span><br><span class="line">             needWake = mBlocked;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">             官方注释：插入队列中间。 通常我们不必醒来</span><br><span class="line">             // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">             // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">             needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">             Message prev;</span><br><span class="line">             //when是新消息的执行时间，p.when的是队列中message消息的执行时间，</span><br><span class="line">             如果找到比新的message还要晚执行的消息，</span><br><span class="line">             就执行msg.next = p;prev.next = msg;</span><br><span class="line">             也就是把插到该消息的前面，优先执行新的消息。</span><br><span class="line">             for (;;) &#123;</span><br><span class="line">                 prev = p;</span><br><span class="line">                 p = p.next;</span><br><span class="line">                 if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                     needWake = false;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             msg.next = p; // invariant: p == prev.next</span><br><span class="line">             prev.next = msg;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">         if (needWake) &#123;</span><br><span class="line">             nativeWake(mPtr);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/android，基础/" rel="tag"># android，基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/27/hello-world/" rel="next" title="hello world">
                <i class="fa fa-chevron-left"></i> hello world
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/19/kotlin总结/" rel="prev" title="Kotlin开发学习">
                Kotlin开发学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.jpg"
                alt="Coding_dog" />
            
              <p class="site-author-name" itemprop="name">Coding_dog</p>
              <p class="site-description motion-element" itemprop="description">你愿意陪我一起菜鸡变凤凰吗</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景以及夙愿"><span class="nav-number">1.</span> <span class="nav-text">背景以及夙愿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handler是什么？"><span class="nav-number">2.</span> <span class="nav-text">handler是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handler使用场景"><span class="nav-number">3.</span> <span class="nav-text">handler使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handler的使用"><span class="nav-number">4.</span> <span class="nav-text">handler的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-post或postDelayed"><span class="nav-number">4.1.</span> <span class="nav-text">1 post或postDelayed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-sendMessage"><span class="nav-number">4.2.</span> <span class="nav-text">2 sendMessage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行效果"><span class="nav-number">4.3.</span> <span class="nav-text">运行效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#handler的内存泄漏"><span class="nav-number">4.4.</span> <span class="nav-text">handler的内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是内存泄漏"><span class="nav-number">4.4.1.</span> <span class="nav-text">什么是内存泄漏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么handler会造成内存泄露"><span class="nav-number">4.4.2.</span> <span class="nav-text">为什么handler会造成内存泄露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何来处理handler内存泄露"><span class="nav-number">4.4.3.</span> <span class="nav-text">如何来处理handler内存泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#方法一：通过程序逻辑来进行保护。"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">方法一：通过程序逻辑来进行保护。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法二：将Handler声明为静态类和加入弱引用"><span class="nav-number">4.4.3.2.</span> <span class="nav-text">方法二：将Handler声明为静态类和加入弱引用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#小扩展：什么是弱引用？"><span class="nav-number">4.4.3.2.1.</span> <span class="nav-text">小扩展：什么是弱引用？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#上面的杨幂demo修正版本："><span class="nav-number">4.4.3.2.2.</span> <span class="nav-text">上面的杨幂demo修正版本：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handler源码分析"><span class="nav-number">5.</span> <span class="nav-text">handler源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#handler机制概括"><span class="nav-number">5.1.</span> <span class="nav-text">handler机制概括</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#handler"><span class="nav-number">5.2.</span> <span class="nav-text">handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#looper"><span class="nav-number">5.3.</span> <span class="nav-text">looper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#曾经的疑问之一：用handler用了好多次，哪次也没写looper-prepare-和looper-loop-也跑的好好的。"><span class="nav-number">5.3.1.</span> <span class="nav-text">曾经的疑问之一：用handler用了好多次，哪次也没写looper.prepare()和looper.loop()也跑的好好的。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatchMessage-msg-分析"><span class="nav-number">5.4.</span> <span class="nav-text">dispatchMessage(msg)分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MessageQueen"><span class="nav-number">5.5.</span> <span class="nav-text">MessageQueen</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#next"><span class="nav-number">5.5.1.</span> <span class="nav-text">next()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#enqueueMessage"><span class="nav-number">5.5.2.</span> <span class="nav-text">enqueueMessage()</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Coding_dog</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'lKEXk4PjEE7zRpQT1zDMocSF-gzGzoHsz',
        appKey: 'oUy3OQ2TDAHq3mNInqu0U6eH',
        placeholder: '说两句',
        avatar:'wavatar',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
