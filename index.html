<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="你愿意陪我一起菜鸡变凤凰吗">
<meta property="og:type" content="website">
<meta property="og:title" content="Coding_dog的成长笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Coding_dog的成长笔记">
<meta property="og:description" content="你愿意陪我一起菜鸡变凤凰吗">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coding_dog的成长笔记">
<meta name="twitter:description" content="你愿意陪我一起菜鸡变凤凰吗">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Coding_dog的成长笔记</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding_dog的成长笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/24/JVM总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/24/JVM总结/" itemprop="url">JVM学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-24T00:00:00+08:00">
                2022-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2022/02/24/JVM总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2022/02/24/JVM总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景以及夙愿"><a href="#背景以及夙愿" class="headerlink" title="背景以及夙愿"></a>背景以及夙愿</h2><p>JVM研究了很多次，包括深入理解Java虚拟机的书籍，但总是记不住,可能还是平时用的少，借这个机会总结下加深印象</p>
<h2 id="JVM是什么？"><a href="#JVM是什么？" class="headerlink" title="JVM是什么？"></a>JVM是什么？</h2><p>其实就是Java虚拟机，我们写好的.java文件，经过javac编译成了.class字节码，再由JVM把字节码处理也叫翻译成机器码（像010101）给操作系统，<br>值得注意的是JVM具有跨平台性（比如可以运行在Windows，Linus等不同操作系统）和跨语言性（比如kotlin也是一样的执行流程）</p>
<p>放一张图概括一下<br><img src="https://s1.ax1x.com/2022/03/24/qG7M1U.jpg" alt="图片"></p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>概念比较抽象，大体上由虚拟机栈，本地方法栈，程序计数器，方法区，堆构成<br>其中方法区和堆是线程公有的，其余是线程私有的。<br><img src="https://s1.ax1x.com/2022/03/24/qGOv7Q.jpg" alt="图片"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>-1.较小的内存空间，是jvm内存区域唯一不会oom的区域，当前线程执行的字节码的行号指示器（针对方法体的偏移量）；各线程之间独立存储，互不影响</p>
<p>-2.为什么需要程序计数器：操作系统时间片轮转的时候会导致线程切换，比如线程a执行到一半时发生线程切换，由程序计数器记录下执行到哪里，以便线程a切回来之后继续执行</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了局部变量表（8大基础类型 + 引用），操作数栈，动态链接，方法出口等信息，然后放入栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。</p>
<p><img src="https://s1.ax1x.com/2022/03/25/qt7zTJ.png" alt="图片"></p>
<p>栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k</p>
<p>####局部变量表:<br>顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。</p>
<p>####操作数据栈：<br>存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作</p>
<p>####动态连接:<br>Java语言特性多态（需要类加载、运行时才能确定具体的方法），动态特性（Groovy、JS、动态代理）<br>有个疑问：运行时多态和编译时多态是否由动态连接决定</p>
<p>####返回地址:<br>正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中的&gt;来确定）</p>
<p>###本地方法栈<br>保存native方法的信息，各虚拟机自由实现。</p>
<p>###方法区<br>用于存储已经被虚拟机加载的类信息，常量(“zdy”,”123”等)，静态变量(static变量)，即时编译器编译后的代码等数据</p>
<p>在jdk1.7之前，使用永久带来实现方法区，并把GC的分代收集扩展至永久带。这样设计的好处就是能够省去专门为方法区编写内存管理的代码。但是在实际的场景中，这样的实现并不是一个好的方式，因为永久带有MAX上限，所以这样做会更容易遇到内存溢出问题。</p>
<p>从jdk1.8开始，使用元空间实现方法区，不在与堆是连续的物理内存，而是改为使用本地内存，也就意味着只要本地内存足够，就不会出现OOM的错误。默认情况下元空间大小是无限的，但受jvm参数控制，如果设置得太大的话会导致堆空间被压缩</p>
<p>###堆<br>几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：</p>
<p>-Xms：堆的最小值；</p>
<p>-Xmx：堆的最大值；</p>
<p>##直接内存<br>也可称为堆外内存，不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；</p>
<p>这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常。</p>
<p>##深入辨析堆和栈</p>
<ul>
<li>以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char等）以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放；</li>
</ul>
<ul>
<li>而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中；</li>
<li>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。</li>
<li>堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</li>
<li>栈的内存要远远小于堆内存</li>
</ul>
<p>##内存溢出</p>
<h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>java.lang.StackOverflowError 一般的方法调用是很难出现的，如果出现了要考虑是否有无限递归。</p>
<p>虚拟机栈带给我们的启示：方法的执行因为要打包成栈桢，所以天生要比实现同样功能的循环慢，所以树的遍历算法中：递归和非递归(循环来实现)都有存在的意义。递归代码简洁，非递归代码复杂但是速度较快。</p>
<h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><p>大部分oom都是堆溢出</p>
<h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><p>不断编译代码可能会导致方法区溢出</p>
<h3 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h3><p>使用bytebuffer时可能会导致该问题</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/22/内存泄漏处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/22/内存泄漏处理/" itemprop="url">记录一次内存泄漏处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-22T00:00:00+08:00">
                2021-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/06/22/内存泄漏处理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/06/22/内存泄漏处理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>相应公司Q2技术战略，根据领导安排，集中处理主端的内存泄漏情况。<br>主端采用友盟检测异常包括崩溃，ANR等等，缺乏直观的内存泄漏检测，为了弥补这块缺失，主端在早期就接入了LeakCanary用以检测，因此我接到任务之后第一件事就是使用LeakCanary查看，查看结果惨不忍睹，高繁使用app之后内存泄漏次数高达1000+</p>
<h2 id="寻求解决方法："><a href="#寻求解决方法：" class="headerlink" title="寻求解决方法："></a>寻求解决方法：</h2><h3 id="工具选择："><a href="#工具选择：" class="headerlink" title="工具选择："></a>工具选择：</h3><p>面对主端动辄几百上千行代码的类，仅仅依靠LeakCanary提供的信息已经不太够用了，我们需要尝试其他方法</p>
<p>需要工具：Android studio和Memory Analyzer Tool</p>
<p>附上Memory Analyzer Tool下载地址：<a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">http://www.eclipse.org/mat/downloads.php</a></p>
<h3 id="实操步骤："><a href="#实操步骤：" class="headerlink" title="实操步骤："></a>实操步骤：</h3><h4 id="第一步：借助-Android-Profiler获得内存快照"><a href="#第一步：借助-Android-Profiler获得内存快照" class="headerlink" title="第一步：借助 Android Profiler获得内存快照"></a>第一步：借助 Android Profiler获得内存快照</h4><p>在手机随机切换,刷新频道，打开正文页，使用搜索等主要功能，然后在Android studio里打开Android Profiler</p>
<p><img src="https://z3.ax1x.com/2021/06/22/RVRrq0.png" alt="图片"></p>
<p>拖动鼠标选择想要查看的片段，点击Dump Java Heap</p>
<p><img src="https://z3.ax1x.com/2021/06/22/RVR7dK.png" alt="图片"></p>
<p>截止到此，我们可以得到内存泄漏的类名，这和LeakCanary得到的信息是一样的</p>
<p>点击Export Heap Dump,将输出的.HPROF文件保存好</p>
<p><img src="https://z3.ax1x.com/2021/06/22/RVOUv6.png" alt="图片"></p>
<h4 id="第二步：将得到的内存快照导入Memory-Analyzer-Tool分析"><a href="#第二步：将得到的内存快照导入Memory-Analyzer-Tool分析" class="headerlink" title="第二步：将得到的内存快照导入Memory Analyzer Tool分析"></a>第二步：将得到的内存快照导入Memory Analyzer Tool分析</h4><p>这里需要注意，Memory Analyzer Tool无法直接打开我们需要使用SDK platform-tools 把 hprof 文件转换成 MAT工具可识别的格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">转换mat标准文件</span><br><span class="line">命令：hprof-conv -z src dst</span><br><span class="line">src  是原文件</span><br><span class="line">dst  是需要转换成的文件, 注意名字一定有 _mat</span><br></pre></td></tr></table></figure>
<p>我执行的命令：hprof-conv -z /Users/jiangweihao/Downloads/内存泄漏/2021052601/memory-20210526T154455.hprof memory_mat.hprof</p>
<p>就这样在指定的目录里成功得到了我需要的memory_mat.hprof</p>
<p>然后在Memory Analyzer Tool中把memory_mat.hprof打开</p>
<p><img src="https://z3.ax1x.com/2021/06/22/RVOqx0.png" alt="图片"></p>
<p>这样就得到了一张大饼，MAT很强大，本次任务只关注内存泄漏，直接点击Histogram即可</p>
<p><img src="https://z3.ax1x.com/2021/06/22/RVXZZD.png" alt="图片"></p>
<p>在红框框里搜索我们之前在Android studio中获知的产生内存泄漏的类</p>
<p>将所得结果进行合并，排除“软”、“弱”、“虚”引用对象，右键点击搜索到的结果</p>
<p><img src="https://z3.ax1x.com/2021/06/22/RVXYdg.png" alt="图片"></p>
<p>可以比较直观地获知哪些对象引起的内存泄漏，这对于7000多行的NewsActivity来说很重要</p>
<p><img src="https://z3.ax1x.com/2021/06/22/RVXdWn.png" alt="图片"></p>
<p>之后就是逐一排查修改了</p>
<h2 id="后续："><a href="#后续：" class="headerlink" title="后续："></a>后续：</h2><p>修改成果涉及公司隐私不宜展示，仅记录一下过程</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/01/kotlin总结（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/01/kotlin总结（二）/" itemprop="url">Kotlin开发学习(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-01T00:00:00+08:00">
                2020-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/12/01/kotlin总结（二）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/12/01/kotlin总结（二）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文接上回，继续kotlin和java就使用上的差异性进行讨论</p>
<h2 id="kotlin的集合"><a href="#kotlin的集合" class="headerlink" title="kotlin的集合"></a>kotlin的集合</h2><h3 id="只读和可变"><a href="#只读和可变" class="headerlink" title="只读和可变"></a>只读和可变</h3><p>Kotlin 标准库提供了基本集合类型的实现： set、list 以及 map。 一对接口代表每种集合类型：<br>Collection 只读 接口，提供访问集合元素的操作。<br>MutableCollection 可变 接口，通过写操作扩展相应的只读接口：添加、删除和更新其元素。</p>
<p><img src="https://s3.ax1x.com/2020/12/02/DI65cD.jpg" alt="图片"></p>
<p>先上一张图：</p>
<p>简单来说，绿色部分是我们常用的，实现只读接口的集合。<br>而红色部分，则是我们常用的，实现可变接口的集合</p>
<p>注意：只读集合类型是型变的。 这意味着，如果类 Rectangle 继承自 Shape，则可以在需要 List <shape> 的任何地方使用 List <rectangle>。<br>     换句话说，集合类型与元素类型具有相同的子类型关系。 map 在值（value）类型上是型变的，但在键（key）类型上不是。</rectangle></shape></p>
<pre><code>反之，可变集合不是型变的；否则将导致运行时故障。 如果 MutableList &lt;Rectangle&gt; 是 MutableList &lt;Shape&gt; 的子类型，
你可以在其中插入其他 Shape 的继承者（例如，Circle），从而违反了它的 Rectangle 类型参数。
</code></pre><h3 id="kotlin的list"><a href="#kotlin的list" class="headerlink" title="kotlin的list"></a>kotlin的list</h3><p>以list举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//集合</span><br><span class="line">   var i = listOf(&quot;周一&quot;,&quot;周二&quot;,&quot;周三&quot;)</span><br><span class="line">   var j = mutableListOf(&quot;周一&quot;,&quot;周二&quot;,&quot;周三&quot;)</span><br><span class="line"></span><br><span class="line">   fun lookList()&#123;</span><br><span class="line">       i.size</span><br><span class="line">       i.indexOf(&quot;周二&quot;)</span><br><span class="line">       i.add() //报错</span><br><span class="line">       </span><br><span class="line">       j.size</span><br><span class="line">       j.add(&quot;周四&quot;)</span><br><span class="line">       j.remove(&quot;周四&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //还有很多特有的，更方便的方法,可以选择性掌握</span><br><span class="line">       val numbers = mutableListOf(1,2,3,4,5,6,7,8,9,10)</span><br><span class="line">       numbers.getOrNull(11) //如果有就返回，没有就返回null</span><br><span class="line">       numbers.indexOfFirst &#123; it &gt; 2 &#125; //返回第一个大于2的索引，结果为2</span><br><span class="line">       numbers.indexOfLast &#123; it &gt; 2 &#125;  //返回最后一个大于2的索引</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在某些方面，List 与数组（Array）非常相似。 但是，有一个重要的区别：数组的大小是在初始化时定义的，永远不会改变; 反之，List 没有预定义的大小；作为写操作的结果，可以更改 List 的大小：添加，更新或删除元素。</p>
<p>在 Kotlin 中，List 的默认实现是 ArrayList，可以将其视为可调整大小的数组。</p>
<h3 id="数组与集合的操作符"><a href="#数组与集合的操作符" class="headerlink" title="数组与集合的操作符"></a>数组与集合的操作符</h3><p>其实 Kotlin 中，还为我们提供了许多使数组与集合操作起来更加方便的函数。这部分和Java有所区别</p>
<ul>
<li><p>1 filter:对每个元素进行过滤操作，如果 lambda 表达式中的条件成立则留下该元素，否则剔除，最终生成新的集合</p>
</li>
<li><p>2 map：遍历每个元素并执行给定表达式，最终形成新的集合</p>
</li>
<li><p>3 flatMap：遍历每个元素，并为每个元素创建新的集合，最后合并到一个集合中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//过滤掉等于被2整除的元素</span><br><span class="line">val filterList = numbers.filter &#123; i -&gt; i % 2 != 0  &#125;</span><br><span class="line"></span><br><span class="line">//每个元素加1</span><br><span class="line">val mapList = numbers.map &#123; i -&gt; i + 1 &#125;</span><br><span class="line"></span><br><span class="line">//生成新集合&#123;1,&quot;a&quot;,2,&quot;a&quot;,3,&quot;a&quot;,4,&quot;a&quot;,5,&quot;a&quot;,6,&quot;a&quot;,7,&quot;a&quot;,8,&quot;a&quot;,9,&quot;a&quot;,10,&quot;a&quot;&#125;</span><br><span class="line">val flatMapList = numbers.flatMap &#123; i -&gt; listOf(i,&quot;a&quot; )&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="协程到底是啥"><a href="#协程到底是啥" class="headerlink" title="协程到底是啥"></a>协程到底是啥</h3><p>就是kotlin封装的，便于我们使用线程的api,本质上和Java的线程池，android的AsyncTask一样<br>同样我们在kotlin中同样可以使用这些来处理我们的并发操作,完全支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun lookThread()&#123;</span><br><span class="line">        //java 线程池</span><br><span class="line">        val executor = Executors.newCachedThreadPool()</span><br><span class="line">        executor.execute &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //Android AsyncTask</span><br><span class="line">        //可见MyAsyncTask</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class MyAsyncTask constructor(context: Context):AsyncTask&lt;String, String, String&gt;()&#123;</span><br><span class="line">        override fun doInBackground(vararg params: String?): String &#123;</span><br><span class="line">            TODO(&quot;Not yet implemented&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onProgressUpdate(vararg values: String?) &#123;</span><br><span class="line">            super.onProgressUpdate(*values)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onPostExecute(result: String?) &#123;</span><br><span class="line">            super.onPostExecute(result)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="协程怎么用"><a href="#协程怎么用" class="headerlink" title="协程怎么用"></a>协程怎么用</h3><h4 id="声明协程的几种方式"><a href="#声明协程的几种方式" class="headerlink" title="声明协程的几种方式"></a>声明协程的几种方式</h4><p>下面列举了协程的三种使用方法和使用java写相同代码的案例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">fun lookCoroutine() &#123;</span><br><span class="line">       /**</span><br><span class="line">        * 方法一通常适用于单元测试的场景，而业务开发中不会用到这种方法，因为它是线程阻塞的。</span><br><span class="line">        */</span><br><span class="line">       runBlocking &#123;</span><br><span class="line">           // 网络请求（IO 线程</span><br><span class="line">           val list = getData()</span><br><span class="line">           // 更新 UI（主线程）</span><br><span class="line">           //nameTv.text = list[0]</span><br><span class="line">       &#125;</span><br><span class="line">       /**</span><br><span class="line">        * 方法二和使用 runBlocking 的区别在于不会阻塞线程。</span><br><span class="line">        * 但在 Android 开发中同样不推荐这种用法，因为它的生命周期会和 app 一致，且不能取消</span><br><span class="line">        */</span><br><span class="line">       GlobalScope.launch &#123;</span><br><span class="line">           // 网络请求（IO 线程)</span><br><span class="line">           val list = getData()</span><br><span class="line">           // 更新 UI（主线程）</span><br><span class="line">           //nameTv.text = list[0]</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 方法三是比较推荐的使用方法，我们可以通过 context 参数去管理和控制协程的生命周期</span><br><span class="line">        * （这里的 context 和 Android 里的不是一个东西，是一个更通用的概念，会有一个 Android 平台的封装来配合使用）</span><br><span class="line">        */</span><br><span class="line">       val coroutineScope = CoroutineScope(constext)</span><br><span class="line">       coroutineScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">           // 网络请求（IO 线程)</span><br><span class="line">           val list = getData()</span><br><span class="line">           //主线程更新 UI</span><br><span class="line">           //nameTv.text = list[0]</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * java实现上述功能</span><br><span class="line">        */</span><br><span class="line">       /*</span><br><span class="line">    getData(new Callback&lt;User&gt;() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void success(List list) &#123;</span><br><span class="line">           runOnUiThread(new Runnable() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void run() &#123;</span><br><span class="line">                   nameTv.setText(list[0]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void failure(Exception e) &#123;</span><br><span class="line">       ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">        */</span><br><span class="line">    /**</span><br><span class="line">        * 除此之外，还有async，用于并发操作</span><br><span class="line">        */</span><br><span class="line">       val timeOne = measureTimeMillis &#123;</span><br><span class="line">           val one = doSomethingUsefulOne()</span><br><span class="line">           val two = doSomethingUsefulTwo()</span><br><span class="line">           println(&quot;The answer is $&#123;one + two&#125;&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">       println(&quot;Completed in $timeOne ms&quot;)</span><br><span class="line">       //The answer is 42</span><br><span class="line">       //Completed in 2017 ms</span><br><span class="line"></span><br><span class="line">       val timeTwo = measureTimeMillis &#123;</span><br><span class="line">           val one = CoroutineScope(constext).async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">           val two = CoroutineScope(constext).async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">           println(&quot;The answer is $&#123;one.await() + two.await()&#125;&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">       println(&quot;Completed in $timeTwo ms&quot;)</span><br><span class="line">       //The answer is 42</span><br><span class="line">       //Completed in 1017 ms</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //假设它是网络请求方法</span><br><span class="line">   private fun getData() = ArrayList&lt;String&gt;()</span><br></pre></td></tr></table></figure>
<h4 id="有些业务场景协程更适合"><a href="#有些业务场景协程更适合" class="headerlink" title="有些业务场景协程更适合"></a>有些业务场景协程更适合</h4><p>除了消除回调，还有很多场景协程显得更加方便，比如遇到的场景是多个网络请求需要等待所有请求结束之后再对 UI 进行更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//比如这两个请求</span><br><span class="line">api.getAvatar(user, callback)</span><br><span class="line">api.getCompanyLogo(user, callback)</span><br></pre></td></tr></table></figure></p>
<p>通常来说，我们会要求后端只给一个借口，实在搞不定就写成串行请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">api.getAvatar(user) &#123; avatar -&gt;</span><br><span class="line">    api.getCompanyLogo(user) &#123; logo -&gt;</span><br><span class="line">        show(merge(avatar, logo))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而如果使用协程，它可以这样写并行请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">coroutineScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    //            👇  async 函数之后再讲</span><br><span class="line">    val avatar = async &#123; api.getAvatar(user) &#125;    // 获取用户头像</span><br><span class="line">    val logo = async &#123; api.getCompanyLogo(user) &#125; // 获取用户所在公司的 logo</span><br><span class="line">    val merged = suspendingMerge(avatar, logo)    // 合并结果</span><br><span class="line">    //                  👆</span><br><span class="line">    show(merged) // 更新 UI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="更轻松写意的线程切换"><a href="#更轻松写意的线程切换" class="headerlink" title="更轻松写意的线程切换"></a>更轻松写意的线程切换</h4><p>如果只是使用 launch 函数，协程并不能比线程做更多的事。不过协程中却有一个很实用的函数：withContext 。<br>这个函数可以切换到指定的线程，并在闭包内的逻辑执行结束之后，自动把线程切回去继续执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//假设它是网络请求方法</span><br><span class="line">   private fun getData() = ArrayList&lt;String&gt;()</span><br><span class="line">//线程切换</span><br><span class="line">   fun lookSwitchOne()&#123;</span><br><span class="line">       CoroutineScope(constext).launch(Dispatchers.Main) &#123;</span><br><span class="line"></span><br><span class="line">           val listOne = withContext(Dispatchers.IO) &#123;</span><br><span class="line">               getData()</span><br><span class="line">           &#125;</span><br><span class="line">           val listTwo = withContext(Dispatchers.IO) &#123;</span><br><span class="line">               getData()</span><br><span class="line">           &#125;</span><br><span class="line">           //nameTv.text = listOne[0] + listTwo[0]</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="协程是轻量级的线程吗？"><a href="#协程是轻量级的线程吗？" class="headerlink" title="协程是轻量级的线程吗？"></a>协程是轻量级的线程吗？</h3><p>上面的代码也可以这么写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun lookSwitchTwo()&#123;</span><br><span class="line">        CoroutineScope(constext).launch(Dispatchers.Main) &#123;</span><br><span class="line">            val listOne = getDataList()</span><br><span class="line">            val listTwo = getDataList()</span><br><span class="line">            //nameTv.text = listOne[0] + listTwo[0]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //改造后的网络请求方法</span><br><span class="line">    suspend fun getDataList() = withContext(Dispatchers.IO)&#123;</span><br><span class="line">        getData()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>suspend又是啥玩意儿？
</code></pre><h4 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h4><p>含义：** 从当前线程挂起。换句话说，就是这个协程从正在执行它的线程上脱离。</p>
<p>注意，不是这个协程停下来了！是脱离，当前线程不再管这个协程要去做什么了。</p>
<p>suspend 是有暂停的意思，但我们在协程中应该理解为：当线程执行到协程的 suspend 函数的时候，就暂时不再执行剩余的协程代码，跳出协程的代码块。**</p>
<p>那么从此时开始，兵分两路，线程去做它原本的工作，若是后台线程就执行其他任务或等待回收，若为主线程就刷新屏幕。</p>
<p>而协程呢，接下来协程会从这个 suspend 函数开始继续往下执行，不过是在指定的线程。</p>
<p>谁指定的？是 suspend 函数指定的，比如我们上面这个例子中，函数内部的 withContext 传入的 Dispatchers.IO 所指定的 IO 线程。</p>
<ul>
<li>Dispatchers 调度器<blockquote>
<p>它可以将协程限制在一个特定的线程执行，或者将它分派到一个线程池，或者让它不受限制地运行。<br>那我们平日里常用到的调度器有哪些？</p>
<ul>
<li>常用的 Dispatchers ，有以下三种：<br>Dispatchers.Main：Android 中的主线程<br>Dispatchers.IO：针对磁盘和网络 IO 进行了优化，适合 IO 密集型的任务，比如：读写文件，操作数据库以及网络请求<br>Dispatchers.Default：适合 CPU 密集型的任务，比如计算</li>
</ul>
</blockquote>
</li>
</ul>
<p>回到我们的协程，它从 suspend 函数开始脱离启动它的线程，继续执行在 Dispatchers 所指定的 IO 线程。</p>
<p>紧接着在 suspend 函数执行完成之后，协程为我们做的最爽的事就来了：会自动帮我们把线程再切回来。</p>
<p>也就是说我们的协程原本是运行在主线程的，当代码遇到 suspend 函数的时候，发生线程切换，根据 Dispatchers 切换到了 IO 线程；</p>
<p>当这个函数执行完毕后，线程又切了回来，「切回来」也就是协程会帮我再 post 一个 Runnable，让我剩下的代码继续回到主线程去执行。</p>
<p>现在可以解释suspend了：协程在执行到有 suspend 标记的函数的时候，会被 suspend 也就是被挂起，而所谓的被挂起，就是切个线程；</p>
<p>不过区别在于，挂起函数在执行完成之后，协程会重新切回它原先的线程。而挂起，是靠withContext函数，只写suspend而没有withContext函数的话，</p>
<p>编译器会给出“redundant suspend modifier”，告诉你这个 suspend 是多余的。因此suspend只是用来提醒开发者的，</p>
<p>这是一个挂起函数，而由于挂起需要切回来，所以挂起函数必须在协程或者另一个挂起函数里被调用。</p>
<p>再简单来讲，在 Kotlin 中所谓的挂起，就是一个稍后会被自动切回来的线程调度操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/06/okhttp源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/06/okhttp源码分析/" itemprop="url">OKhttp源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-06T00:00:00+08:00">
                2020-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/06/okhttp源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/06/okhttp源码分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="OKhttp基本使用"><a href="#OKhttp基本使用" class="headerlink" title="OKhttp基本使用"></a>OKhttp基本使用</h2><p>这里以get异步请求为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//创建okHttpClient对象</span><br><span class="line">OkHttpClient mOkHttpClient = new OkHttpClient();</span><br><span class="line">//创建一个Request</span><br><span class="line">final Request request = new Request.Builder()</span><br><span class="line">                .url(&quot;https://baidu.com&quot;)</span><br><span class="line">                .build();</span><br><span class="line">//new call</span><br><span class="line">Call call = mOkHttpClient.newCall(request); </span><br><span class="line">//请求加入调度</span><br><span class="line">call.enqueue(new Callback()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Request request, IOException e)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(final Response response) throws IOException</span><br><span class="line">            &#123;</span><br><span class="line">                    //String htmlStr =  response.body().string();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="三个队列"><a href="#三个队列" class="headerlink" title="三个队列"></a>三个队列</h3><p>创建OkHttpClient和Request都用到了建造者模式，来配置初始化参数和设置参数<br>mOkHttpClient.newCall(request)，实际调用了RealCall,在RealCall中用了工厂模式<br>我们跟进enqueue()<br>下面代码是enqueue（）在RealCall中的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">  //1.看下头</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">    executed = true;</span><br><span class="line">  &#125;</span><br><span class="line">  //加入了一个用于追踪堆栈信息的callStackTrace</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  eventListener.callStart(this);</span><br><span class="line">  //2.看下头</span><br><span class="line">  client.dispatcher().enqueue(new AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1 首先利用synchronized加入了对象锁，防止多线程同时调用，这里先判断一下executed是否为true判断当前call是否被执行了，如果为ture，则抛出异常，没有则设置为true，这意味着call请求只能执行一次。</li>
<li>2 跟进client.dispatcher().enqueue(new AsyncCall(responseCallback))方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line">  //线程最大并发数</span><br><span class="line">  private int maxRequests = 64;</span><br><span class="line">  //每个主机最大请求数</span><br><span class="line">  private int maxRequestsPerHost = 5;</span><br><span class="line">  private @Nullable Runnable idleCallback;</span><br><span class="line"></span><br><span class="line">  /** Executes calls. Created lazily. */</span><br><span class="line">  private @Nullable ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">  /** Ready async calls in the order they&apos;ll be run. */</span><br><span class="line">  private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  /** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */</span><br><span class="line">  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  /** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */</span><br><span class="line">  private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  //中间省略了很多非必要代码</span><br><span class="line"></span><br><span class="line">  synchronized void enqueue(AsyncCall call) &#123;</span><br><span class="line">      if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，这里用三个队列ArrayDeque用于保存Call对象，分为三种状态异步等待,异步running,同步running。<br>当正在执行的异步队列个数小于maxRequest(64)并且请求同一个主机的个数小于maxRequestsPerHost(5)时，则将这个请求加入异步执行队列runningAsyncCall，并用线程池执行execute（），否则加入异步等待队列。<br>这里看一下线程池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized ExecutorService executorService() &#123;</span><br><span class="line">   if (executorService == null) &#123;</span><br><span class="line">     //</span><br><span class="line">     executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">         new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</span><br><span class="line">   &#125;</span><br><span class="line">   return executorService;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>corePoolSize    核心线程池大小，如果是0的话，空闲一段时间后所有线程将全部被销毁</li>
<li>maximumPoolSize 最大线程池大小，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</li>
<li>keepAliveTime   线程最大空闲时间，当线程数大于corePoolSize时，多余的空闲线程的最大存活时间</li>
<li>unit            时间单位</li>
<li>workQueue       线程等待队列</li>
<li>threadFactory   线程创建工厂</li>
</ul>
<p>别忘了看看AsyncCall</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">  private final Callback responseCallback;</span><br><span class="line"></span><br><span class="line">  AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">    super(&quot;OkHttp %s&quot;, redactedUrl());</span><br><span class="line">    this.responseCallback = responseCallback;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">  @Override protected void execute() &#123;</span><br><span class="line">    boolean signalledCallback = false;</span><br><span class="line">    try &#123;</span><br><span class="line">    </span><br><span class="line">      //&apos;1. 我们可以发现最后线程池执行的任务就是getResponseWithInterceptorChain方法&apos;</span><br><span class="line">      Response response = getResponseWithInterceptorChain();</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">        signalledCallback = true;</span><br><span class="line">        responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        signalledCallback = true;</span><br><span class="line">        responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      if (signalledCallback) &#123;</span><br><span class="line">        // Do not signal the callback twice!</span><br><span class="line">        Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        eventListener.callFailed(RealCall.this, e);</span><br><span class="line">        responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      //&apos;2. 最后再从Dispatcher里面的异步队列中移除&apos;</span><br><span class="line">      client.dispatcher().finished(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是异步还是同步，都是一样的:</p>
<ul>
<li>1 加入到Dispatcher里面的同步(或异步)队列</li>
<li>2 执行getResponseWithInterceptorChain方法</li>
<li>3 从Dispatcher里面的同步(或异步)队列移除。（只不过同步操作是直接运行了getResponseWithInterceptorChain方法，而异步是通过线程池执行Runnable再去执行getResponseWithInterceptorChain方法）</li>
</ul>
<h3 id="几个拦截器"><a href="#几个拦截器" class="headerlink" title="几个拦截器"></a>几个拦截器</h3><p>那就看看getResponseWithInterceptorChain<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">  // Build a full stack of interceptors.</span><br><span class="line">  //&apos;1. 创建一个拦截器List&apos;</span><br><span class="line">  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">  //&apos;2. 添加用户自己创建的应用拦截器&apos;</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  //&apos;3. 添加重试与重定向拦截器&apos;</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  //&apos;4. 添加内容拦截器&apos;</span><br><span class="line">  interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  //&apos;4. 添加缓存拦截器&apos;</span><br><span class="line">  interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">  /&apos;5. 添加连接拦截器&apos;</span><br><span class="line">  interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">  if (!forWebSocket) &#123;</span><br><span class="line">    //&apos;6. 添加用户自己创建的网络拦截器&apos;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  //&apos;7. 添加请求服务拦截器&apos;</span><br><span class="line">  interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  //&apos;8.把这些拦截器们一起封装在一个拦截器链条上面(RealInterceptorChain)&apos;</span><br><span class="line">  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">      originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line">  </span><br><span class="line">  //&apos;9.然后执行链条的proceed方法&apos;</span><br><span class="line">  return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后会走到8和9，创建了一个RealInterceptorChain，并调用了proceed方法，这里注意一下0这个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final class RealInterceptorChain implements Interceptor.Chain &#123;</span><br><span class="line">   </span><br><span class="line">   //&apos;我们刚才建立的放拦截器的队列&apos;</span><br><span class="line">   private final List&lt;Interceptor&gt; interceptors;</span><br><span class="line">   //&apos;当前执行的第几个拦截器序号&apos;</span><br><span class="line">   private final int index;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">     RealConnection connection) throws IOException &#123;</span><br><span class="line">   if (index &gt;= interceptors.size()) throw new AssertionError();</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   //&apos;实例化了一个新的RealInterceptorChain对象，并且传入相同的拦截器List，只不过传入的index值+1&apos;</span><br><span class="line">   RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">       connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">       writeTimeout);</span><br><span class="line">   //&apos;获取当前index对应的拦截器里面的具体的某个拦截器，</span><br><span class="line">   Interceptor interceptor = interceptors.get(index);</span><br><span class="line">   //然后执行拦截器的intercept方法,同时传入新的RealInterceptorChain对象(主要的区别在于index+1了)&apos;</span><br><span class="line">   Response response = interceptor.intercept(next);</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">   return response;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里index就是我们刚才的0，也就是从0开始，如果index超过了过滤器的个数抛出异常，后面会再new一个RealInterceptorChain，而且会将参数传递，并且index+1了，接着获取index的interceptor,并调用intercept方法，传入新new的next对象。<br>这是okhttp很牛逼的一个地方，传说中的责任链接设计模式，为了更好的理解并加深印象，我抄了一张图<br><img src="https://s2.ax1x.com/2020/03/06/3qLsw6.png" alt="图片"></p>
<h4 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h4><p>RetryAndFollowUpInterceptor的定义为：This interceptor recovers from failures and follows redirects as necessary 即网络请求失败后，在一些必要的条件下，会重新进行网络请求。<br>进去RetryAndFollowUpInterceptor看核心代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">   Request request = chain.request();</span><br><span class="line">   RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">   Call call = realChain.call();</span><br><span class="line">   EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">   StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">       createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line">   this.streamAllocation = streamAllocation;</span><br><span class="line">   //重定向次数</span><br><span class="line">   int followUpCount = 0;</span><br><span class="line">   Response priorResponse = null;</span><br><span class="line">   //死循环</span><br><span class="line">   while (true) &#123;</span><br><span class="line">     if (canceled) &#123;</span><br><span class="line">       streamAllocation.release();</span><br><span class="line">       throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Response response;</span><br><span class="line">     boolean releaseConnection = true;</span><br><span class="line">     try &#123;</span><br><span class="line">       response = realChain.proceed(request, streamAllocation, null, null);</span><br><span class="line">       releaseConnection = false;</span><br><span class="line">     &#125; catch (RouteException e) &#123;</span><br><span class="line">       //这里能跳出循坏</span><br><span class="line">       //当发生RouteException时候，并且 recover为false的时候，这时候会跳出循环，然后抛出去异常，并回调callback.onFailure(Exception e),返回给UI层进行处理 ，假如说没有开数据流量的情况下，去请求网络，则会抛出该异常。</span><br><span class="line">       // The attempt to connect via a route failed. The request will not have been sent.</span><br><span class="line">       if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123;</span><br><span class="line">         throw e.getLastConnectException();</span><br><span class="line">       &#125;</span><br><span class="line">       releaseConnection = false;</span><br><span class="line">       continue;</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">       // An attempt to communicate with a server failed. The request may have been sent.</span><br><span class="line">       //当发生IOException时候，recover为false的时候，则throw exception，中断死循环的操作，</span><br><span class="line">       boolean requestSendStarted = !(e instanceof ConnectionShutdownException);</span><br><span class="line">       if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;</span><br><span class="line">       releaseConnection = false;</span><br><span class="line">       continue;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       // We&apos;re throwing an unchecked exception. Release any resources.</span><br><span class="line">       if (releaseConnection) &#123;</span><br><span class="line">         streamAllocation.streamFailed(null);</span><br><span class="line">         streamAllocation.release();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // Attach the prior response if it exists. Such responses never have a body.</span><br><span class="line">     if (priorResponse != null) &#123;</span><br><span class="line">       response = response.newBuilder()</span><br><span class="line">           .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                   .body(null)</span><br><span class="line">                   .build())</span><br><span class="line">           .build();</span><br><span class="line">     &#125;</span><br><span class="line">     //重定向方法</span><br><span class="line">     Request followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line"></span><br><span class="line">     if (followUp == null) &#123;</span><br><span class="line">       if (!forWebSocket) &#123;</span><br><span class="line">         streamAllocation.release();</span><br><span class="line">       &#125;</span><br><span class="line">       return response;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">     if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">       streamAllocation.release();</span><br><span class="line">       throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (followUp.body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">       streamAllocation.release();</span><br><span class="line">       throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">       streamAllocation.release();</span><br><span class="line">       streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">           createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">       this.streamAllocation = streamAllocation;</span><br><span class="line">     &#125; else if (streamAllocation.codec() != null) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Closing the body of &quot; + response</span><br><span class="line">           + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     request = followUp;</span><br><span class="line">     priorResponse = response;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>小结一下</p>
<ul>
<li>1 首先查看请求是否已经取消</li>
<li>2 调用RealInterceptorChain的proceed处理这个请求并把刚创建的StreamAllocation传递进去</li>
<li>3 如果前面第二步没有出现异常，则说明请求完成，设置releaseConnection为false,出现异常则将releaseConnection置为true,并释放前面创建的StreamAllocation</li>
<li>4 priorResponse不为空，则说明前面已经获取到了响应，这里会结合当前获取的Response和先前的Response</li>
<li>5 调用followUpRequest查看响应是否需要重定向，如果不需要重定向则返回当前请求</li>
<li>6 重定向次数+1，并且判断StreamAllocation是否需要重新创建</li>
<li>7 重新设置request，并把当前的Response保存到priorResponse，继续while循环</li>
</ul>
<p>然后我们需要看一下重定向方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private Request followUpRequest(Response userResponse, Route route) throws IOException &#123;</span><br><span class="line">  if (userResponse == null) throw new IllegalStateException();</span><br><span class="line">  int responseCode = userResponse.code();</span><br><span class="line"></span><br><span class="line">  final String method = userResponse.request().method();</span><br><span class="line">  switch (responseCode) &#123;</span><br><span class="line">   //...</span><br><span class="line">    case HTTP_PERM_REDIRECT:</span><br><span class="line">    case HTTP_TEMP_REDIRECT:</span><br><span class="line">      if (!method.equals(&quot;GET&quot;) &amp;&amp; !method.equals(&quot;HEAD&quot;)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">    case HTTP_MULT_CHOICE:</span><br><span class="line">    case HTTP_MOVED_PERM:</span><br><span class="line">    case HTTP_MOVED_TEMP:</span><br><span class="line">    case HTTP_SEE_OTHER:</span><br><span class="line">      if (!client.followRedirects()) return null;</span><br><span class="line"></span><br><span class="line">      String location = userResponse.header(&quot;Location&quot;);</span><br><span class="line">      if (location == null) return null;</span><br><span class="line">      HttpUrl url = userResponse.request().url().resolve(location);</span><br><span class="line"></span><br><span class="line">      boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">      Request.Builder requestBuilder = userResponse.request().newBuilder();</span><br><span class="line">      if (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">        final boolean maintainBody = HttpMethod.redirectsWithBody(method);</span><br><span class="line">        if (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">          requestBuilder.method(&quot;GET&quot;, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          RequestBody requestBody = maintainBody ? userResponse.request().body() : null;</span><br><span class="line">          requestBuilder.method(method, requestBody);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!maintainBody) &#123;</span><br><span class="line">          requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">          requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">          requestBuilder.removeHeader(&quot;Content-Type&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      return requestBuilder.url(url).build();</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法会取到状态码，然后进行switch判断，当status code为307即HTTP_TEMP_REDIRECT时，okhttp会从相应体中，获取Location值（重定向地址）从源码中可以看出，还有好多种状态码的判断。这里只看重定向307，<br>会重新创建和拼接请求新的Request，然后将原请求的相关Header信息进行拼装，最后创建一个新的Request返回回去再次进行网络请求</p>
<h4 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h4><p>一句话概括： 将客户端构建的Request对象信息构建成真正的网络请求;然后发起网络请求，最后就是将服务器返回的消息封装成一个Response对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public final class BridgeInterceptor implements Interceptor &#123;</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">@Override </span><br><span class="line">public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">  Request userRequest = chain.request();</span><br><span class="line">  Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line"> RequestBody body = userRequest.body();</span><br><span class="line"> //如果存在请求主体部分，那么需要添加Content-Type、Content-Length首部</span><br><span class="line"> if (body != null) &#123;</span><br><span class="line">      MediaType contentType = body.contentType();</span><br><span class="line">      if (contentType != null) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      long contentLength = body.contentLength();</span><br><span class="line">      if (contentLength != -1) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing</span><br><span class="line">    // the transfer stream.</span><br><span class="line">    boolean transparentGzip = false;</span><br><span class="line">    if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">      transparentGzip = true;</span><br><span class="line">      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    if (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"></span><br><span class="line">    if (transparentGzip</span><br><span class="line">        &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">          .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseBuilder.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /** Returns a &apos;Cookie&apos; HTTP request header with all cookies, like &#123;@code a=b; c=d&#125;. */</span><br><span class="line">  private String cookieHeader(List&lt;Cookie&gt; cookies) &#123;</span><br><span class="line">    StringBuilder cookieHeader = new StringBuilder();</span><br><span class="line">    for (int i = 0, size = cookies.size(); i &lt; size; i++) &#123;</span><br><span class="line">      if (i &gt; 0) &#123;</span><br><span class="line">        cookieHeader.append(&quot;; &quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      Cookie cookie = cookies.get(i);</span><br><span class="line">      cookieHeader.append(cookie.name()).append(&apos;=&apos;).append(cookie.value());</span><br><span class="line">    &#125;</span><br><span class="line">    return cookieHeader.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，首先获取原请求，然后在请求中添加头，比如Host、Connection、Accept-Encoding参数等，然后根据看是否需要填充Cookie，在对原始请求做出处理后，使用chain的procced方法得到响应，接下来对响应做处理得到用户响应，最后返回响应。接下来再看下一个拦截器ConnectInterceptor的处理。</p>
<h4 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h4><p>缓存拦截器，简单来说就是有缓存就使用缓存<br>感觉很复杂，借鉴了一些大神的博客<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    //1 尝试通过这个Request拿缓存</span><br><span class="line">    Response cacheCandidate = cache != null</span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : null;</span><br><span class="line">    //2 如果不允许使用网络并且缓存为空，新建一个504的Resposne返回。</span><br><span class="line">    if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">      return new Response;</span><br><span class="line">    &#125;</span><br><span class="line">    //3 如果不允许使用网络，但是有缓存，返回缓存</span><br><span class="line">    if (networkRequest == null) &#123;</span><br><span class="line">      return cacheResponse;</span><br><span class="line">    &#125;</span><br><span class="line">    //4 链式调用下一个过滤器</span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    //5 如果缓存不为空，但是网络请求得来的返回码是304（如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。)则使用缓存的响应。</span><br><span class="line">    if (cacheResponse != null) &#123;</span><br><span class="line">      if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">        return response;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    //6</span><br><span class="line">    Response response = networkResponse;</span><br><span class="line">    //7</span><br><span class="line">    cache.put(response);</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这些借鉴了<a href="https://www.jianshu.com/p/bfb13eb3a425" target="_blank" rel="noopener">https://www.jianshu.com/p/bfb13eb3a425</a><br>详细内容可以去大神博客里看</p>
<h4 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h4><p>连接拦截器，顾名思义打开了与服务器的链接，正式开启了网络请求。<br>总的来说ConnectionInterceptor就是弄一个RealConnection对象，然后创建Socket链接<br>具体可以看看<a href="https://www.jianshu.com/p/4bf4c796db6f" target="_blank" rel="noopener">https://www.jianshu.com/p/4bf4c796db6f</a><br>跟上面的推荐是一个作者</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 能力一般水平有限，不想写大段的基本使用方式，因为现在一般都会配合rxjava使用，单独记录okhttp使用方式意义不大，笔者只是忠实记录下自己看okhttp框架源码的过程，以供日后查阅。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/01/Retrofit源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/01/Retrofit源码分析/" itemprop="url">Retrofit源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-01T00:00:00+08:00">
                2020-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/01/Retrofit源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/01/Retrofit源码分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Retrofit本质流程"><a href="#Retrofit本质流程" class="headerlink" title="Retrofit本质流程"></a>Retrofit本质流程</h2><ul>
<li>1 将http请求抽象成java接口</li>
<li>2 在接口中注解描述和配置网络请求参数</li>
<li>3 用动态代理的方式将网络请求的注解解析成http请求</li>
<li>4 用okhttp执行http请求</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="创建Retrofit对象"><a href="#创建Retrofit对象" class="headerlink" title="创建Retrofit对象"></a>创建Retrofit对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">                                 .baseUrl(&quot;http://fanyi.youdao.com/&quot;)</span><br><span class="line">                                 .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                                 .build();</span><br></pre></td></tr></table></figure>
<p>Retrofit实例是使用建造者模式通过Builder类进行创建的(建造者模式:将一个复杂对象的构建与表示分离，使得用户在不知道对象的创建细节情况下就可以直接创建复杂的对象。)<br>跟进Retrofit类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public final class Retrofit &#123;</span><br><span class="line">  </span><br><span class="line">  private final Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;();</span><br><span class="line">  // 网络请求配置对象（对网络请求接口中方法注解进行解析后得到的对象）</span><br><span class="line">  // 作用：存储网络请求相关的配置，如网络请求的方法、数据转换器、网络请求适配器、网络请求工厂、基地址等</span><br><span class="line">  </span><br><span class="line">  private final HttpUrl baseUrl;</span><br><span class="line">  // 网络请求的url地址</span><br><span class="line"></span><br><span class="line">  private final okhttp3.Call.Factory callFactory;</span><br><span class="line">  // 网络请求器的工厂</span><br><span class="line">  // 作用：生产网络请求器（Call）</span><br><span class="line">  // Retrofit是默认使用okhttp</span><br><span class="line">  </span><br><span class="line">   private final List&lt;CallAdapter.Factory&gt; adapterFactories;</span><br><span class="line">    //用了工厂模式</span><br><span class="line">  // 网络请求适配器工厂的集合</span><br><span class="line">  // 作用：放置网络请求适配器工厂</span><br><span class="line">  // 网络请求适配器工厂作用：生产网络请求适配器（CallAdapter）</span><br><span class="line">  // 下面会详细说明</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private final List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">  //用了工厂模式</span><br><span class="line">  // 数据转换器工厂的集合</span><br><span class="line">  // 作用：放置数据转换器工厂</span><br><span class="line">  // 数据转换器工厂作用：生产数据转换器（converter）比如gson</span><br><span class="line"></span><br><span class="line">  private final Executor callbackExecutor;</span><br><span class="line">  // 回调方法执行器</span><br><span class="line"></span><br><span class="line">private final boolean validateEagerly; </span><br><span class="line">// 标志位</span><br><span class="line">// 作用：是否提前对业务接口中的注解进行验证转换的标志位</span><br><span class="line"></span><br><span class="line">Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,  </span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; adapterFactories,  </span><br><span class="line">      Executor callbackExecutor, boolean validateEagerly) &#123;  </span><br><span class="line">    this.callFactory = callFactory;  </span><br><span class="line">    this.baseUrl = baseUrl;  </span><br><span class="line">    this.converterFactories = unmodifiableList(converterFactories); </span><br><span class="line">    this.adapterFactories = unmodifiableList(adapterFactories);   </span><br><span class="line">    // unmodifiableList(list)近似于UnmodifiableList&lt;E&gt;(list)</span><br><span class="line">    // 作用：创建的新对象能够对list数据进行访问，但不可通过该对象对list集合中的元素进行修改</span><br><span class="line">    this.callbackExecutor = callbackExecutor;  </span><br><span class="line">    this.validateEagerly = validateEagerly;</span><br></pre></td></tr></table></figure></p>
<p>众多需要配置的参数中，我们注意一下calladapter（网络请求适配器）：将默认的网络请求执行器（OkHttpCall）转换成适合被不同平台来调用的网络请求执行器形式</p>
<ul>
<li>1 Call在Retrofit里默认是OkHttpCall</li>
<li>2 在Retrofit中提供了四种CallAdapterFactory： ExecutorCallAdapterFactory（默认）、GuavaCallAdapterFactory、Java8CallAdapterFactory、RxJavaCallAdapterFactory</li>
</ul>
<p>跟进build<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public Retrofit build() &#123;</span><br><span class="line">      if (baseUrl == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Base URL required.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">&lt;--  配置网络请求执行器（callFactory）--&gt;</span><br><span class="line">      okhttp3.Call.Factory callFactory = this.callFactory;</span><br><span class="line">      // 如果没指定，则默认使用okhttp</span><br><span class="line">      // 所以Retrofit默认使用okhttp进行网络请求</span><br><span class="line">      if (callFactory == null) &#123;</span><br><span class="line">        callFactory = new OkHttpClient();</span><br><span class="line">      &#125;</span><br><span class="line">&lt;--  配置网络请求适配器工厂（CallAdapterFactory）--&gt;</span><br><span class="line">      Executor callbackExecutor = this.callbackExecutor;</span><br><span class="line">       // 如果没指定，则默认使用Platform检测环境时的默认callbackExecutor</span><br><span class="line">      // 即Android默认的callbackExecutor</span><br><span class="line">      if (callbackExecutor == null) &#123;</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Make a defensive copy of the adapters and add the default Call adapter.</span><br><span class="line">      List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);</span><br><span class="line">      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">      // Make a defensive copy of the converters.</span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);</span><br><span class="line">      //获取合适的网络请求适配器和数据转换器都是从adapterFactories和converterFactories集合的首位-末位开始遍历</span><br><span class="line">      // 因此集合中的工厂位置越靠前就拥有越高的使用权限</span><br><span class="line"></span><br><span class="line">      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</span><br><span class="line">          callbackExecutor, validateEagerly);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建网络请求接口的实例"><a href="#创建网络请求接口的实例" class="headerlink" title="创建网络请求接口的实例"></a>创建网络请求接口的实例</h3><p>利用注解确定请求方式并完成url的拼接，这都直接带过，最后种种线索聚焦到retrofit.create(xxxApi.class)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">   Utils.validateServiceInterface(service);</span><br><span class="line">   if (validateEagerly) &#123;</span><br><span class="line">   	// 通过之前传的标志位判断是否需要提前验证，如果不是提前验证则进行动态解析对应方法</span><br><span class="line">     eagerlyValidateMethods(service);</span><br><span class="line">   &#125;</span><br><span class="line">    // 创建了网络请求接口的动态代理对象，即通过动态代理创建网络请求接口的实例 （并最终返回）</span><br><span class="line">       // 该动态代理是为了拿到网络请求接口实例上所有注解</span><br><span class="line">       return (T) Proxy.newProxyInstance(</span><br><span class="line">         service.getClassLoader(),      // 动态生成接口的实现类 </span><br><span class="line">         new Class&lt;?&gt;[] &#123; service &#125;,    // 动态创建实例</span><br><span class="line">         new InvocationHandler() &#123;     // 将代理类的实现交给 InvocationHandler类作为具体的实现（下面会解释）</span><br><span class="line">         private final Platform platform = Platform.get();</span><br><span class="line">        // 在 InvocationHandler类的invoke（）实现中，除了执行真正的逻辑（如再次转发给真正的实现类对象），还可以进行一些有用的操作</span><br><span class="line">        // 如统计执行时间、进行初始化和清理、对接口调用进行检查等。</span><br><span class="line"></span><br><span class="line">         @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)</span><br><span class="line">             throws Throwable &#123;</span><br><span class="line">           // If the method is a method from Object then defer to normal invocation.</span><br><span class="line">           if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">             return method.invoke(this, args);</span><br><span class="line">           &#125;</span><br><span class="line">           if (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">             return platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">           &#125;</span><br><span class="line">           //下面三行是重点</span><br><span class="line">           //这行很复杂下面分析</span><br><span class="line">           ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">               (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">           //根据上边那行配置好的ServiceMethod对象和输入的请求参数创建okHttpCall对象</span><br><span class="line">           OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">           //将上一行创建的OkHttpCall对象传给再上一行创建的serviceMethod对象中对应的网络请求适配器工厂的adapt（）</span><br><span class="line">           return serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>  首先是loadServiceMethod<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod loadServiceMethod(Method method) &#123;</span><br><span class="line">    ServiceMethod result;</span><br><span class="line">      // 设置线程同步锁</span><br><span class="line">    synchronized (serviceMethodCache) &#123;</span><br><span class="line"></span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      // ServiceMethod类对象采用了单例模式进行创建</span><br><span class="line">      // 即创建ServiceMethod对象前，先看serviceMethodCache有没有缓存之前创建过的网络请求实例</span><br><span class="line">      </span><br><span class="line">      // 若没缓存，则通过建造者模式创建 serviceMethod 对象</span><br><span class="line">      if (result == null) &#123;</span><br><span class="line">      // 这个很重要！！！</span><br><span class="line">        result = new ServiceMethod.Builder(this, method).build();</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">// 这里就是上面说的创建实例的缓存机制：采用单例模式从而实现一个 ServiceMethod 对象对应于网络请求接口里的一个方法</span><br></pre></td></tr></table></figure></p>
<p>  特别关注一下ServiceMethod.Builder(this, method).build()<br>  ServiceMethod对象包含了访问网络的所有基本信息,感兴趣可以去看一下ServiceMethod类，这里不贴了占地儿</p>
<p>  Builder(this, method)方法<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    this.retrofit = retrofit;</span><br><span class="line">    this.method = method;</span><br><span class="line"></span><br><span class="line">    // 获取网络请求接口方法里的注释</span><br><span class="line">    this.methodAnnotations = method.getAnnotations();</span><br><span class="line">    // 获取网络请求接口方法里的参数类型       </span><br><span class="line">    this.parameterTypes = method.getGenericParameterTypes();  </span><br><span class="line">    //获取网络请求接口方法里的注解内容    </span><br><span class="line">    this.parameterAnnotationsArray = method.getParameterAnnotations();    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>  ServiceMethod的build（）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 作用：控制ServiceMethod对象的生成流程</span><br><span class="line"> public ServiceMethod build() &#123;</span><br><span class="line"></span><br><span class="line">      callAdapter = createCallAdapter();    </span><br><span class="line">      // 根据网络请求接口方法的返回值和注解类型，从Retrofit对象中获取对应的网络请求适配器  --&gt;关注点1</span><br><span class="line">     </span><br><span class="line">      responseType = callAdapter.responseType();    </span><br><span class="line">     // 根据网络请求接口方法的返回值和注解类型，从Retrofit对象中获取该网络适配器返回的数据类型</span><br><span class="line">     </span><br><span class="line">      responseConverter = createResponseConverter();    </span><br><span class="line">      // 根据网络请求接口方法的返回值和注解类型，从Retrofit对象中获取对应的数据转换器  --&gt;关注点3</span><br><span class="line">       </span><br><span class="line">       for (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">        parseMethodAnnotation(annotation);</span><br><span class="line">      &#125;</span><br><span class="line">      // 解析网络请求接口中方法的注解</span><br><span class="line">      // 主要是解析获取Http请求的方法</span><br><span class="line">     // 注解包括：DELETE、GET、POST、HEAD、PATCH、PUT、OPTIONS、HTTP、retrofit2.http.Headers、Multipart、FormUrlEncoded</span><br><span class="line">     // 处理主要是调用方法 parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) ServiceMethod中的httpMethod、hasBody、relativeUrl、relativeUrlParamNames域进行赋值</span><br><span class="line">      </span><br><span class="line">     int parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">     // 获取当前方法的参数数量</span><br><span class="line">      </span><br><span class="line">      parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">      for (int p = 0; p &lt; parameterCount; p++) &#123;</span><br><span class="line">        Type parameterType = parameterTypes[p];</span><br><span class="line">        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">        // 为方法中的每个参数创建一个ParameterHandler&lt;?&gt;对象并解析每个参数使用的注解类型</span><br><span class="line">        // 该对象的创建过程就是对方法参数中注解进行解析</span><br><span class="line">        // 这里的注解包括：Body、PartMap、Part、FieldMap、Field、Header、QueryMap、Query、Path、Url </span><br><span class="line">        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">      &#125; </span><br><span class="line">      return new ServiceMethod&lt;&gt;(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>小结一下：</p>
<ul>
<li>1 根据返回值类型和方法标注从Retrofit对象的的网络请求适配器工厂集合和内容转换器工厂集合中分别获取到该方法对应的网络请求适配器和Response内容转换器；</li>
<li>2 根据方法的标注对ServiceMethod的域进行赋值</li>
<li>3 最后为每个方法的参数的标注进行解析，获得一个ParameterHandler&lt;?&gt;对象<br>该对象保存有一个Request内容转换器——根据参数的类型从Retrofit的内容转换器工厂集合中获取一个Request内容转换器或者一个String内容转换器。</li>
</ul>
<h3 id="执行网络请求"><a href="#执行网络请求" class="headerlink" title="执行网络请求"></a>执行网络请求</h3><p>OkHttpCall提供了两种网络请求方式:</p>
<ul>
<li>1 同步请求：OkHttpCall.execute()</li>
<li>2 异步请求：OkHttpCall.enqueue()<br>到这就都是okhttp的东西了</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/HTTP学习总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/25/HTTP学习总结/" itemprop="url">http学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-25T00:00:00+08:00">
                2020-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/25/HTTP学习总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/25/HTTP学习总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于http"><a href="#关于http" class="headerlink" title="关于http"></a>关于http</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HTTP是一种用于在通信双方(通常是客户端和服务器端)传输数据(包括但不限于图片、文本、音频等)的可靠的数据传输协议，而且是基于TCP的应用层协议，从更高层次封装了TCP的使用细节，使得网络操作更为简单。</p>
<h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><p><img src="https://s2.ax1x.com/2020/02/24/3G7ajS.png" alt="图片"><br>HTTP协议提供了几种请求方式，大家熟知的请求方式有8种GET、POST、DELETE、PUT、HEAD、TRACE、OPTIONS、CONNECT，其中最常用的是PUT（增）、DELETE(删)、POST（改）、GET（查）。</p>
<ul>
<li>get 获取资源：客户端通过URL获取服务端中的某个资源，请求参数放在URL中，然后服务端返回对应资源给客户端</li>
<li>post 传输实体主体：POST请求通常会用来提交HTML表单，把数据填在表单中，传给服务器，然后服务器对这些数据进行处理，虽然GET方法也可以用来传输主体实体，但是一般采用POST方法</li>
<li>put 传输文件：与GET相反，PUT向服务器写入数据，一般用来传输文件，把需要传输的文件放在请求报文的主体上，然后保存到URL指定的位置</li>
<li>delete 删除文件：与PUT相反，DELETE请求求服务器删除URL所指定的资源，请求参数放在URL中，但是服务端可以在客户端不知情下撤销此请求</li>
<li>head 获取报文首部：HEAD与GET类似，但服务器在响应中只返回首部不会返回主体部分，HEAD是用来在不获取资源的情况下获取资源的首部进行检查，如查看响应的状态码，看看资源是否被修改，对象是否存在</li>
<li>trace 追踪路径：客户端发起一个请求时，可能要穿过防火墙，代理，网关等，每一个中间点都会修改HTTP原始请求报文，TRACE允许请求最终发送给服务端时，看看它最终变成什么样，服务端会返回一个状态码200 OK的响应报文，报文主体包含了TARCE信息</li>
<li>options 询问支持的方法：OPTIONS询问服务端支持的用来查询指定URL资源的方法，这就让客户端不用访问那些实际的资源就能判定访问各种资源的最优方法</li>
<li>connect 要求使用隧道协议连接代理：CONNECT要求在与代理服务器通信时建立隧道，实现用隧道进行TCP通信，隧道就是经过加密的通信信路，一般使用SSL/TLS协议把通信内容加密后经隧道传输</li>
</ul>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>用于HTTP协议交换的信息称为HTTP报文，客户端发出的HTTP报文叫做请求报文，服务端返回的HTTP报文叫做响应报文，它们都是由多行数据构成的字符串文本<br><img src="https://s2.ax1x.com/2020/02/24/3GqajK.png" alt="格式如图"><br>大致可以分为两类</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>一个HTTP的请求报文通常由请求行，请求首部，空行(CR + LF)，请求主体4个部分组成，如图：<br><img src="https://s2.ax1x.com/2020/02/24/3GXN3n.png" alt="图片"><br>下面分别以get请求和post请求为例</p>
<h5 id="GET的请求报文"><a href="#GET的请求报文" class="headerlink" title="GET的请求报文"></a>GET的请求报文</h5><p>对于GET方法来说，它所有的请求参数都是拼接在URL最后，第一个参数前通过”?”连接，然后请求参数按照”key=value”格式进行追加，每个请求参数之间通过”&amp;”连接，如 ：<br><a href="http://www.myhost.com/text/?id=1&amp;…" target="_blank" rel="noopener">www.myhost.com/text/?id=1&amp;…</a><br>这个URL对于GET请求表示获取 <a href="http://www.myhost.com/text/" target="_blank" rel="noopener">www.myhost.com/text/</a> 位置下用户id为1，名为rain的文本，相应的请求报文格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /text/?id=1&amp;name=rain HTTP/1.1</span><br><span class="line">Host: www.myhost.com</span><br><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure></p>
<p>从上面的HTTP请求报文格式知，第一行为请求行，表明请求方式为GET，子路径为 /text/?id=1&amp;name=rain，HTTP版本为1.1，后两行为请求首部，Host为主机地址，Cache-Control为no-cache，表示客户端不接受服务端缓存过的资源，而GET的请求参数都在URL中，所以请求主体为空。</p>
<h5 id="POST的请求报文"><a href="#POST的请求报文" class="headerlink" title="POST的请求报文"></a>POST的请求报文</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST /local/ HTTP/1.1</span><br><span class="line">Host: www.myhost.com</span><br><span class="line">Accept-Encoding：gzip</span><br><span class="line">Content-Length: 222222</span><br><span class="line">Content-Type: multipart/from-data；boundary=dRGP2cPPTxE6WRTssnh4jC7HJLcSde</span><br><span class="line">Connection：Keep-Alive</span><br><span class="line"></span><br><span class="line">--dRGP2cPPTxE6WRTssnh4jC7HJLcSde</span><br><span class="line">Content-Disposition：from-data；name=“username”  //name = username</span><br><span class="line">Content-Type：text/plain：charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"></span><br><span class="line">rain										//value = rain</span><br><span class="line">--dRGP2cPPTxE6WRTssnh4jC7HJLcSde</span><br><span class="line">Content-Diaposition:from-data:name=&quot;image&quot;      //name = image</span><br><span class="line">filename=&quot;/storage/emulated/0/image/1234.png&quot;</span><br><span class="line">Content-Type:application/octet-stream</span><br><span class="line">Content-Transfer-Encoding:binary</span><br><span class="line"></span><br><span class="line">//...省略二进制数据					        //value = 二进制数据</span><br><span class="line">--dRGP2cPPTxE6WRTssnh4jC7HJLcSde--</span><br></pre></td></tr></table></figure>
<p>上述的请求报文的含义是向  <a href="http://www.myhost.com/local/" target="_blank" rel="noopener">www.myhost.com/local/</a>  这个地址发送一个POST请求，接受的内容编码方式为gzip，请求的数据长度为222222字节，请求的数据格式为 multipart/from-data（表单），报文的boundary值为dRGP2cPPTxE6WRTssnh4jC7HJLcSde，Keep-Alive为开启长连接，空行之后，接下来就是请求报文的主体，主体有两个请求参数：<br>一个是名为username，值为rain的文本；<br>一个是名为image，值为二进制数据的图片.</p>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>一个HTTP的响应报文通常由状态行、响应首部、空行(CR + LF)、响应主体组成<br><img src="https://s2.ax1x.com/2020/02/24/3Gx9cn.png" alt="格式如图"><br>比如这是一个GET请求的返回的响应报文格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP1.1 200 OK</span><br><span class="line">Data:Sat, 30, Dec 2006 23:23:00 GMT</span><br><span class="line">Content-Type:text/html；charset=UTF-8</span><br><span class="line">Content-Length:852</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">	//...省略文档内容</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面HTTP响应报文表示，HTTP协议版本为1.1，响应状态码为200，表示请求成功，返回数据的类型为text/html（html）, 编码为UTF-8，返回数据的内容长度为852字节，空行之后，接下来就是返回的数据，是一个html文档</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码的职责是当客户端向服务端发送请求时，描述服务端返回的请求结果，借助状态码，我们就可以得知服务端是正常处理了请求，还是出现了错误，下面是开发中经常遇见的状态码：</p>
<h4 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a>2XX成功</h4><p>2XX的响应结果表示请求被正常处理了.</p>
<ul>
<li>200 OK：请求没有问题，实体的主体部分包含了所请求的资源</li>
<li>204 No Content：该状态码表示服务端接收的请求已成功处理，但是在返回的响应报文中不包含主体部分，这说明请求处理成功，但是没有任何资源返回。比如当浏览器发出的请求处理后，返回204响应，那么浏览器显示的页面将不会发生任何更新；</li>
<li>206 Partial Content: 该状态码表示客户端进行了范围请求，而服务端成功返回了这一部分范围的资源，即响应报文的主体部分中会包含由Content-Range指定范围的内容。</li>
</ul>
<h4 id="3XX重定向"><a href="#3XX重定向" class="headerlink" title="3XX重定向"></a>3XX重定向</h4><p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。如果资源已经被移走，可发送一个重定向状态码和一个可选的Location首部来告知客户端资源已经被移走，以及现在可以在哪里找到它。浏览器就可以在不影响用户浏览体验的情况下透明地在新的位置找到所需资源了。</p>
<ul>
<li>301 Moved Permanently：永久性重定向，该状态码表示请求的资源已被分配了新的URL，以后都应使用新的URL来访问该资源，这时响应报文首部的Location字段会提示新的URL。例如你使用这个最后忘记加斜杠 / 的地址 <a href="http://www.myhost.com" target="_blank" rel="noopener">www.myhost.com</a> 来访问服务端，就会返回301状态码，提示你使用正确的地址访问，不过这些重定向的操作浏览器在背后已经替我们处理了，所以用户是无法感知的；</li>
<li>302 Found：临时重定向，该状态码表示请求的资源暂时被分配了新的URL，本次应使用新的URL来访问该资源，302代表资源不是被永久移动，而是临时移动，即本次会重定向到地址a，下一次可能会重定向到地址b或者不变，所以响应报文首部的Location字段提示的新URL并不是永久性的，而是临时性的；</li>
<li>303 See Other：临时重定向，该状态码表示请求的资源暂时被分配了新的URL，本次应使用新的URL通过GET方法来访问该资源，303和302功能相似，但是303明确表示客户端重定向时应采用GET方法获取资源，而302就没有这个要求。（但是在现实中，大部分浏览器都没有遵循规范，不管是301、302还是303，都会把POST改成GET，然后重新获取资源）；</li>
<li>304 Not Modified：304虽然被划分在3XX中，但是它和重定向没有任何关系，该状态码表示客户端访问的资源存在，但是未符合请求的附带条件，不允返回，这时返回的304响应报文不包含主体部分，请求的附带条件是指请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部。例如客户端想要检查本地资源缓存是否过期，就在GET请求中附带If-Modified-Since条件，If-Modified-Since的值是本地资源的Last-Modified(上一次修改时间)的值，服务端接收请求后，就会检查资源在服务端的上一次修改的时间是否比If-Modified-Since的值更新，如果没有，说明资源没有被修改过，返回304响应报文，告诉客户端可以继续使用本地缓存。</li>
</ul>
<h4 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h4><p>4XX的响应结果表示客户端发生错误的原因所在.</p>
<ul>
<li>400 Bad Request：该状态码表示客户端的请求报文中有语法错误，不能被服务端理解，当发生该错误后需要修改请求内容后再次发送；</li>
<li>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证的认证信息，401的响应报文会包含一个被请求资源的WWW-Authenticate首部用来质询用户信息，当浏览器初次接收到401响应，会弹出认证窗口，当浏览器第二次收到401响应，表示认证失败；</li>
<li>403 Forbidden：该状态码表示服务端收到了请求，但是拒绝提供服务，服务端不会给出拒绝的详细理由，例如没有文件的访问权限等都会返回404响应；</li>
<li>404 Not Found：该状态码表示请求资源在服务端上不存在，或者服务端拒绝请求但不想说明理由也会返回404；</li>
</ul>
<h4 id="5XX服务端错误"><a href="#5XX服务端错误" class="headerlink" title="5XX服务端错误"></a>5XX服务端错误</h4><p>5XX的响应结果表示服务端发送错误的原因所在.</p>
<ul>
<li>500 Internal Server Error：该状态码表示服务端执行请求时发生了不可预估的错误，它表明服务端Web应用存在bug或其他故障；</li>
<li>503 Server Unavailable：该状态码表示服务端当前不能处理客户端请求，一段时间后可能恢复正常，它表明服务端暂时处于超负载或停机维护状态，如果服务端得知故障恢复时间，它会在响应报文的Retry-After首部字段写入返回给客户端。</li>
</ul>
<h3 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie是用来管理客户端和服务端之间的状态，它是服务器发送到客户端并保存在本地的小型文本文件，其内容为一系列的键值对，Cookie并不属于HTTP/1.x的规范，但是由于HTTP的无状态特性，Cookie被广泛应用于各大Web网站的状态管理及用户识别。<br>Cookie的工作过程主要使用到了Set-Cookie和Cookie这两个首部，Set-Cookie首部存在于响应报文中，Set-Cookie首部包含服务端返回给客户端状态管理使用的Cookie信息，客户端收到响应后会从Set-Cookie首部中取出Cookie信息保存到本地；Cookie首部存在于请求报文中，Cookie首部包含客户端从服务端接收到的Cookie信息，每次客户端发起请求时，都会在请求报文的Cookie首部中携带Cookie信息发送给服务端。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>Cookie需要和服务端的Session配合使用，Cookie是存储在客户端中，而Session是存储在服务器端中，Session是服务端保存用户状态的方式，它们的工作过程大概如下：</p>
<ul>
<li>1 当用户登陆网站时，填入账号、密码等信息，然后提交表单，这些信息会被放入HTTP的请求报文，然后发送给服务端；</li>
<li>2 服务端收到请求后，验证该用户名和密码，如果正确，则为该用户创建一个Session对象，Session对象中保存了用户的状态信息，并生成Session对象的唯一ID，称为Session ID，然后把Session对象存储到内存或数据库中，根据Session ID根据从内存或数据库获取到Session对象；</li>
<li>3 接着服务端把Session ID的值以name=value的形式放入响应报文的Set-Cookie首部中，其中name为Session ID的名字，value就是Session ID的值，name=value形式的Session ID就称为Cookie，Set-Cookie首部除了Session ID之外，还有一些其他信息，如Cookie的有效期、Cookie的域名范围等，然后把这个响应报文发送给客户端；</li>
<li>4 客户端收到响应报文之后从Set-Cookie首部中取出所有Cookie信息，然后把它保存到本地，客户端有时候会收到不止一个Set-Cookie首部，如果有多个，每个Set-Cookie首部中的Cookie信息都要保存；</li>
<li>5 客户端之后对同一个服务端进行请求时都会从本地取出Cookie信息，这时可以校验Cookie的有效期、路径、域名等信息，然后取出其中的Cookie值放入请求报文的Cookie首部字段，如果有多个Cookie值，Cookie首部中就用 ; 分隔，然后把这个请求报文发送给服务端；</li>
<li>6 服务器收到请求后，从Cookie首部中取出Cookie，从Cookie中取出Session ID，然后用Session ID从内存或数据库取出用户信息，恢复用户之前的操作状态。</li>
</ul>
<p>关于Cookie与Session建议：<a href="https://zhuanlan.zhihu.com/p/27669892" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27669892</a><br>或者《图解http》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/24/TCP,UDP总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/24/TCP,UDP总结/" itemprop="url">TCP,UDP知识总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-24T00:00:00+08:00">
                2020-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/24/TCP,UDP总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/24/TCP,UDP总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TCP-UDP的对比"><a href="#TCP-UDP的对比" class="headerlink" title="TCP,UDP的对比"></a>TCP,UDP的对比</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP（Transmission Control Protocol，传输控制协议），是一种面向连接的，基于窗口滑动的可靠传输协议，提供可靠（无差错、不丢失、不重复、按顺序）的字节流数据传输服务。在传输效率和可靠性之间选择了后者，所以有开销大、传输速度慢的缺点。</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP（User Datagram Protocol，用户数据报协议），是一种无连接的非可靠传输层协议。UDP 不提供数据包分组、组装，不能对数据段进行排序，所以 UDP 数据段的首部非常简单。换句话说，当数据段发送出去之后，发送方是无法得知其是否完整且安全的到达了接收方的。这样的传输机制决定了它的最大优点就是快，同时也决定了它最大的缺点不可靠、不稳定。</p>
<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><h4 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP:"></a>TCP:</h4><ul>
<li>1 面向连接：需要通过三次握手建立连接。</li>
<li>2 点对点：一条 TCP 连接只能连接两个端点，一对一通信。</li>
<li>3 字节流传输：TCP 会将数据当作字节流进行处理，不尝试理解所传输的数据含义，仅把数据看作一连串的字节序列。</li>
<li>4 可靠传输：使用窗口滑动的流量控制和拥塞控制</li>
<li>5 首部开销大：最少20字节，最大60字节</li>
</ul>
<h4 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP:"></a>UDP:</h4><ul>
<li>1 无连接</li>
<li>2 支持单传，多传，广播（一对一，一对多，多对一，多对多）</li>
<li>3 对应用层交付的报文直接打包：不提供数据包分组、组装，不能对数据段进行排序</li>
<li>4 不可靠：尽最大努力交付，不使用流量控制和拥塞控制</li>
<li>5 首部开销小：仅8个字节</li>
</ul>
<h2 id="TCP-2"><a href="#TCP-2" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。<br><img src="https://s2.ax1x.com/2020/02/23/31cCgP.jpg" alt="图片"></p>
<ul>
<li>1 第一次握手：客户端将标志位SYN置为1（SYN为1时不能携带数据），随机产生一个值seq=x，作为TCP客户进程的初始序号，并将该数据包发送给服务器端，客户端进入SYN_SENT同步已发送状态，等待服务器端确认。</li>
<li>2 第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，表明这是一个TCP确认请求报文，ack=x+1,表明对客户进程初始序号的确认，随机产生一个值seq=y作为服务器进程的初始序号，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD同步已接收状态。</li>
<li>3 第三次握手：客户端收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，seq=x+1并将该数据包发送给服务器端，服务器端检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED连接已建立状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。<br>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。<br><img src="https://s2.ax1x.com/2020/02/23/33uXLD.png" alt="图片"></p>
<ul>
<li>1 第一次挥手：客户端发送一个FIN=1，ACK=1，用来关闭客户端到服务器端的数据传送,seq=u，u为之前客户端传送的数据的最后一个字节序号加1，ack=v,v为之前客户端收到的数据的最后一个字节序号加1，客户端进入FIN_WAIT_1终止等待1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>
<li>2 第二次挥手：服务器端收到FIN后进入CLOSE-WAIT关闭等待状态，ACK=1,seq=v,v表明之前服务器传送的数据的最后一个字节序号加1，ack=u+1(对收到客户端报文的确认)，对客户端，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 终止等待2状态，继续等待服务器端的FIN报文。</li>
<li>3 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=1，ACK=1,seq=w(半关闭状态下可能又发送了数据),ack=u+1（对收到客户端报文的重复确认）报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK最后确认状态。</li>
<li>4 第四次挥手：客户端收到报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ACK=1,seq=u+1,ack=w+1后进入TIME_WAIT时间等待状态，如果服务端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>
</ul>
<p>本文参考：<a href="https://www.youtube.com/watch?v=p799RP-YFY8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=p799RP-YFY8</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/22/网络模型知多少/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/22/网络模型知多少/" itemprop="url">网络模型知识总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-22T00:00:00+08:00">
                2020-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/22/网络模型知多少/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/22/网络模型知多少/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景以及夙愿"><a href="#背景以及夙愿" class="headerlink" title="背景以及夙愿"></a>背景以及夙愿</h2><p>都快还给老师了，往回捡一捡</p>
<h2 id="osi网络模型"><a href="#osi网络模型" class="headerlink" title="osi网络模型"></a>osi网络模型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>即开放式系统互联。 一般都叫OSI参考模型，是国际标准化组织为了普及网络应用而推出的，含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了</p>
<h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>由下到上分为物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3MOsot.md.jpg" alt="图片"></p>
<h4 id="各层功能定义概述"><a href="#各层功能定义概述" class="headerlink" title="各层功能定义概述"></a>各层功能定义概述</h4><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p>OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p>
<p>举例：某东上，卖家和买家都是我们所述的用户，他们的线上买卖行为，退货退款等都是应用层提供的网络服务</p>
<h5 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h5><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>举例：由于卖家A和买家B是不同国家的，他们之间的商定统一用英语作为交流的语言，所以此时表示层，就是将应用层的传递信息转翻译成英语。同时为了防止信息被人截获，A的人也会对这份信息单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</p>
<h5 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h5><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成，。      </p>
<p>举例：B跟A聊完，还想货比三家，就去找其他卖家聊，会话层掌握着其他卖家的信息，负责建立通话并记录通话，首先要找到其他卖家的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，随后终止通话。</p>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p>
<p>举例：传输层就相当于负责快递邮件收发的人，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p>
<p>举例：网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</p>
<h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。<br>数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。<br>MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p>
<h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<h2 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP/IP网络模型"></a>TCP/IP网络模型</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>如果说OSI网络模型是一种理想化的标准，那么TCP/IP就是一种成功的具体实现，它的分层：物理层，数据链路层，网络层，传输层，应用层<br>与OSI对应关系如下：<br><img src="https://s2.ax1x.com/2020/02/22/3Q28kd.md.jpg" alt="图片"></p>
<h3 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h3><p>下图以用户 a 向用户 b 发送邮件为例子：<br><img src="https://s2.ax1x.com/2020/02/23/31mTbj.png" alt="图片"></p>
<ul>
<li>1 ① 应用程序处理<br>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；<br>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</li>
<li>2 ② TCP 模块的处理<br>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</li>
<li>3 ③ IP 模块的处理<br>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</li>
<li>4 ④ 网络接口（以太网驱动）的处理<br>从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</li>
<li>5 ⑤ 网络接口（以太网驱动）的处理主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</li>
<li>6 ⑥ IP 模块的处理IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</li>
<li>7 ⑦ TCP 模块的处理<br>在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</li>
<li>8 ⑧ 应用程序的处理<br>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</li>
</ul>
<p>注：常常说的tcp,udp就是传输层的协议。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/30/零零散散/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/30/零零散散/" itemprop="url">零零散散</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-30T00:00:00+08:00">
                2019-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/30/零零散散/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/30/零零散散/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LeakCanary是如何检测到内存泄漏的？"><a href="#LeakCanary是如何检测到内存泄漏的？" class="headerlink" title="LeakCanary是如何检测到内存泄漏的？"></a>LeakCanary是如何检测到内存泄漏的？</h2><p>LeakCanay的入口是在application的onCreate()方法中声明的，其实用的就是Application的ActivityLifecycleCallbacks回调接口监听所有activity的onDestory()的，在这个方法进行RefWatcher.watch对这个对象进行监控。具体是这样做的，把activity对象封装成带key值和带引用队列(ReferenceQueue)的KeyedWeakReference对象，然后GC看弱引用对象有没有回收，没有回收的话就怀疑是泄漏了，需要二次确认。然后生成HPROF文件，分析这个快照文件有没有存在带这个key值的泄漏对象，如果没有，那么没有泄漏，否则找出最短路径，打印给我们，我们就能够找到这个泄漏对象了。</p>
<h2 id="如何判断app在前台还是后台"><a href="#如何判断app在前台还是后台" class="headerlink" title="如何判断app在前台还是后台?"></a>如何判断app在前台还是后台?</h2><p>Application类里有ActivityLifecycleCallbacks回调接口,可以监听Application的生命周期，通常执行onstart()视为前台，执行onStop()视为后台 </p>
<h2 id="WindowManager-addView-，View-getParent-分别对应？"><a href="#WindowManager-addView-，View-getParent-分别对应？" class="headerlink" title="WindowManager.addView()，View.getParent()分别对应？"></a>WindowManager.addView()，View.getParent()分别对应？</h2><p><img src="https://s2.ax1x.com/2019/12/31/l1g5Z9.png" alt="图片"></p>
<p>WindowManager.addView()是将DecorView作为根布局加入到PhoneWindow中去，而View.getParent()指得是普通子view的父view</p>
<h2 id="Serializable和Parcelable的区别？"><a href="#Serializable和Parcelable的区别？" class="headerlink" title="Serializable和Parcelable的区别？"></a>Serializable和Parcelable的区别？</h2><ul>
<li>1 效率不同，两者最大的区别在于 存储媒介的不同，Serializable会使用反射，这个过程中使用 I/O 读写存储在硬盘上，而 Parcelable 不需要用反射，直接 在内存中读写。很明显，内存的读写速度通常大于 IO 读写，所以在 Android 中传递数据优先选择 Parcelable。</li>
<li>2 用法不同<br>Serializable使用简单<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TestSerializable implements Serializable &#123;</span><br><span class="line">    String msg;</span><br><span class="line">    </span><br><span class="line">    List&lt;ItemBean&gt; datas;</span><br><span class="line">    </span><br><span class="line">    public static class ItemBean implements Serializable&#123;</span><br><span class="line">        String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Parcelable较为复杂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TestParcelable implements Parcelable &#123;</span><br><span class="line">    String msg;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(this.msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TestParcelable(String msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TestParcelable(Parcel in) &#123;</span><br><span class="line">        this.msg = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;TestParcelable&gt; CREATOR = new Creator&lt;TestParcelable&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public TestParcelable createFromParcel(Parcel source) &#123;</span><br><span class="line">            return new TestParcelable(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public TestParcelable[] newArray(int size) &#123;</span><br><span class="line">            return new TestParcelable[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Android里面为什么要设计出Bundle而不是直接用Map结构？"><a href="#Android里面为什么要设计出Bundle而不是直接用Map结构？" class="headerlink" title="Android里面为什么要设计出Bundle而不是直接用Map结构？"></a>Android里面为什么要设计出Bundle而不是直接用Map结构？</h3><ul>
<li>1 是在Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为了更加快速的进行数据的序列化和反序列化，系统封装了Bundle类，方便我们进行数据的传输。</li>
<li>2 Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数据对应下标，一个对象数组保存key和value，内部使用二分法对key进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，只适合于小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据量，我没见过在两个Activity之间传递10个以上数据的场景，所以相比之下，在这种情况下使用ArrayMap保存数据，在操作速度和内存占用上都具有优势，因此使用Bundle来传递数据，可以保证更快的速度和更少的内存占用。</li>
</ul>
<h2 id="Java自动装箱和自动拆箱"><a href="#Java自动装箱和自动拆箱" class="headerlink" title="Java自动装箱和自动拆箱"></a>Java自动装箱和自动拆箱</h2><p>装箱就是自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。<br>举例：int是基本数据类型，Integer是包装器类型，看Integer.valueOf ( int i ) 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;       </span><br><span class="line">        if (i &gt;= -128 &amp;&amp; i &lt;= 127)</span><br><span class="line">            return IntegerCache.cache[i + 127];</span><br><span class="line">            //如果i的值大于-128小于127则返回一个缓冲区中的一个Integer对象</span><br><span class="line">        return new Integer(i);</span><br><span class="line">        //否则返回 new 一个Integer 对象</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>原来IntegerCache 类在初始化的时候，生成了一个大小为 256 的integer 类型的常量池，并且integer.val 的值从-128-127，当我们运行 Integer c=a ;时，如果 -128&lt;=a&lt;=127时，不会再生成新的integer对象，直接从常量池中找到对应的已经初始化后的对象。当 a&lt;-128||a&gt;127时会生成一个新的对象。</p>
<h2 id="synchronized与volatile"><a href="#synchronized与volatile" class="headerlink" title="synchronized与volatile"></a>synchronized与volatile</h2><h3 id="synchronized："><a href="#synchronized：" class="headerlink" title="synchronized："></a>synchronized：</h3><p>同步块大家都比较熟悉，通过 synchronized 关键字来实现，所有加上synchronized 和 块语句，在多线程访问的时候，同一时刻只能有一个线程能够用。经过反编译可知，synchronized将monitorenter和monitorexit指令插入到同步代码块的开始和结束处/异常处，且每个monitorenter必须有对应的monitorexit。</p>
<p>synchronized 修饰的方法 或者 代码块。</p>
<p>修饰普通方法时相当于把锁加到对象实例上</p>
<p>修饰静态方法时相当于把锁加到该类唯一的class对象</p>
<h3 id="volatile："><a href="#volatile：" class="headerlink" title="volatile："></a>volatile：</h3><p>用volatile修饰的变量，线程在每次使用变量的时候，都会去读主内存，取变量修改后的最新的值。</p>
<h4 id="JVM在运行时候的内存分配过程："><a href="#JVM在运行时候的内存分配过程：" class="headerlink" title="JVM在运行时候的内存分配过程："></a>JVM在运行时候的内存分配过程：</h4><p>有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个线程栈，<br>线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存<br>变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，<br>在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。<br><img src="https://s2.ax1x.com/2019/12/31/l1cs1O.png" alt="图片"><br>小结：加上volatile关键字，强制线程每次读取该值的时候都去“主内存”中取值。保证了线程安全。</p>
<h2 id="requestLayout、invalidate与postInvalidate区别"><a href="#requestLayout、invalidate与postInvalidate区别" class="headerlink" title="requestLayout、invalidate与postInvalidate区别"></a>requestLayout、invalidate与postInvalidate区别</h2><h3 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout:"></a>requestLayout:</h3><p>从方法名字可以知道，“请求布局”，那就是说，如果调用了这个方法，那么对于一个子View来说，应该会重新进行布局流程。但是，真实情况略有不同，如果子View调用了这个方法，其实会从View树重新进行一次测量、布局、绘制这三个流程，最终就会显示子View的最终情况。</p>
<h3 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate:"></a>invalidate:</h3><p>view的invalidate不会导致ViewRootImpl的invalidate被调用，而是递归调用父view的invalidateChildInParent，直到ViewRootImpl的invalidateChildInParent，然后触发peformTraversals，会导致当前view被重绘,由于mLayoutRequested为false，不会导致onMeasure和onLayout被调用，而OnDraw会被调用</p>
<h3 id="postInvalidate"><a href="#postInvalidate" class="headerlink" title="postInvalidate:"></a>postInvalidate:</h3><p>postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。</p>
<p><img src="https://s2.ax1x.com/2019/12/31/l1prYq.png" alt="图片"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/Binder机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/Binder机制/" itemprop="url">Binder机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-28T00:00:00+08:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/28/Binder机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/28/Binder机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="本篇文章的背景以及夙愿"><a href="#本篇文章的背景以及夙愿" class="headerlink" title="本篇文章的背景以及夙愿"></a>本篇文章的背景以及夙愿</h2><ul>
<li>1 了解Binder机制，毕竟挺难的</li>
<li>2 陪媳妇儿加班中，待着也是待着</li>
</ul>
<h2 id="正文之前需要说得Binder"><a href="#正文之前需要说得Binder" class="headerlink" title="正文之前需要说得Binder"></a>正文之前需要说得Binder</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>一句话，Binder是一种进程间通信机制</p>
<h3 id="Android为什么选择Binder"><a href="#Android为什么选择Binder" class="headerlink" title="Android为什么选择Binder"></a>Android为什么选择Binder</h3><p>Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于性能、稳定性和安全性几方面的原因。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</p>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<h2 id="Linux-下传统的进程间通信原理"><a href="#Linux-下传统的进程间通信原理" class="headerlink" title="Linux 下传统的进程间通信原理"></a>Linux 下传统的进程间通信原理</h2><p><img src="https://s2.ax1x.com/2019/12/28/lmA4FP.png" alt="图片"></p>
<h3 id="涉及几个概念："><a href="#涉及几个概念：" class="headerlink" title="涉及几个概念："></a>涉及几个概念：</h3><ul>
<li><p>1 进程隔离<br>简单的说就是操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。</p>
</li>
<li><p>2 进程空间划分<br>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
</li>
<li><p>3 系统调用：用户态与内核态<br>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助系统调用来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
</li>
</ul>
<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。<br>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。<br>当进程在执行用户自己的代码的时候，我们称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。</p>
<h3 id="传统通信原理简述"><a href="#传统通信原理简述" class="headerlink" title="传统通信原理简述"></a>传统通信原理简述</h3><p>通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。<br>如下图：<br><img src="https://s2.ax1x.com/2019/12/28/lmEgpT.png" alt="图片"></p>
<h3 id="传统的-IPC-通信方式缺点"><a href="#传统的-IPC-通信方式缺点" class="headerlink" title="传统的 IPC 通信方式缺点"></a>传统的 IPC 通信方式缺点</h3><ul>
<li>1 性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>2 接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>
</ul>
<h2 id="Binder跨进程通信原理"><a href="#Binder跨进程通信原理" class="headerlink" title="Binder跨进程通信原理"></a>Binder跨进程通信原理</h2><h3 id="涉及几个概念：-1"><a href="#涉及几个概念：-1" class="headerlink" title="涉及几个概念："></a>涉及几个概念：</h3><ul>
<li>1 动态内核可加载模块<br>模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。</li>
<li>2 内存映射<br>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。<br>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</li>
</ul>
<h3 id="Binder-IPC-实现步骤："><a href="#Binder-IPC-实现步骤：" class="headerlink" title="Binder IPC 实现步骤："></a>Binder IPC 实现步骤：</h3><ul>
<li>1 首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>
<li>2 接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系；</li>
<li>3 发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。<br>如下图：<br><img src="https://s2.ax1x.com/2019/12/28/lmDiGt.png" alt="图片"></li>
</ul>
<h2 id="Binder通信过程"><a href="#Binder通信过程" class="headerlink" title="Binder通信过程"></a>Binder通信过程</h2><p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h3 id="互联网通信过程："><a href="#互联网通信过程：" class="headerlink" title="互联网通信过程："></a>互联网通信过程：</h3><p>包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。<br>如下图：<br><img src="https://s2.ax1x.com/2019/12/29/lus9jx.md.png" alt="图片"><br>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之间的关系。<br>通常我们访问一个网页的步骤是这样的：首先在浏览器输入一个地址，如 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 然后按下回车键。但是并没有办法通过域名地址直接找到我们要访问的服务器，因此需要首先访问 DNS 域名服务器，域名服务器中保存了 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 对应的 ip 地址 10.249.23.13，然后通过这个 ip 地址才能放到到 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 对应的服务器。<br><img src="https://s2.ax1x.com/2019/12/29/lus2x1.png" alt="图片"></p>
<h3 id="Binder通信过程："><a href="#Binder通信过程：" class="headerlink" title="Binder通信过程："></a>Binder通信过程：</h3><p>大致能总结出 Binder 通信过程：</p>
<ul>
<li>1 首先，一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>2 Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>3 Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。<br><img src="https://s2.ax1x.com/2019/12/29/luy3sx.png" alt="图片"></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.jpg"
                alt="Coding_dog" />
            
              <p class="site-author-name" itemprop="name">Coding_dog</p>
              <p class="site-description motion-element" itemprop="description">你愿意陪我一起菜鸡变凤凰吗</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Coding_dog</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'lKEXk4PjEE7zRpQT1zDMocSF-gzGzoHsz',
        appKey: 'oUy3OQ2TDAHq3mNInqu0U6eH',
        placeholder: '说两句',
        avatar:'wavatar',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
