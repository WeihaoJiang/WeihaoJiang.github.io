<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="你愿意陪我一起菜鸡变凤凰吗">
<meta property="og:type" content="website">
<meta property="og:title" content="Coding_dog的成长笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Coding_dog的成长笔记">
<meta property="og:description" content="你愿意陪我一起菜鸡变凤凰吗">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coding_dog的成长笔记">
<meta name="twitter:description" content="你愿意陪我一起菜鸡变凤凰吗">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Coding_dog的成长笔记</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding_dog的成长笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/HTTP学习总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/25/HTTP学习总结/" itemprop="url">http学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-25T00:00:00+08:00">
                2020-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/25/HTTP学习总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/25/HTTP学习总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于http"><a href="#关于http" class="headerlink" title="关于http"></a>关于http</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HTTP是一种用于在通信双方(通常是客户端和服务器端)传输数据(包括但不限于图片、文本、音频等)的可靠的数据传输协议，而且是基于TCP的应用层协议，从更高层次封装了TCP的使用细节，使得网络操作更为简单。</p>
<h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><p><img src="https://s2.ax1x.com/2020/02/24/3G7ajS.png" alt="图片"><br>HTTP协议提供了几种请求方式，大家熟知的请求方式有8种GET、POST、DELETE、PUT、HEAD、TRACE、OPTIONS、CONNECT，其中最常用的是PUT（增）、DELETE(删)、POST（改）、GET（查）。</p>
<ul>
<li>get 获取资源：客户端通过URL获取服务端中的某个资源，请求参数放在URL中，然后服务端返回对应资源给客户端</li>
<li>post 传输实体主体：POST请求通常会用来提交HTML表单，把数据填在表单中，传给服务器，然后服务器对这些数据进行处理，虽然GET方法也可以用来传输主体实体，但是一般采用POST方法</li>
<li>put 传输文件：与GET相反，PUT向服务器写入数据，一般用来传输文件，把需要传输的文件放在请求报文的主体上，然后保存到URL指定的位置</li>
<li>delete 删除文件：与PUT相反，DELETE请求求服务器删除URL所指定的资源，请求参数放在URL中，但是服务端可以在客户端不知情下撤销此请求</li>
<li>head 获取报文首部：HEAD与GET类似，但服务器在响应中只返回首部不会返回主体部分，HEAD是用来在不获取资源的情况下获取资源的首部进行检查，如查看响应的状态码，看看资源是否被修改，对象是否存在</li>
<li>trace 追踪路径：客户端发起一个请求时，可能要穿过防火墙，代理，网关等，每一个中间点都会修改HTTP原始请求报文，TRACE允许请求最终发送给服务端时，看看它最终变成什么样，服务端会返回一个状态码200 OK的响应报文，报文主体包含了TARCE信息</li>
<li>options 询问支持的方法：OPTIONS询问服务端支持的用来查询指定URL资源的方法，这就让客户端不用访问那些实际的资源就能判定访问各种资源的最优方法</li>
<li>connect 要求使用隧道协议连接代理：CONNECT要求在与代理服务器通信时建立隧道，实现用隧道进行TCP通信，隧道就是经过加密的通信信路，一般使用SSL/TLS协议把通信内容加密后经隧道传输</li>
</ul>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>用于HTTP协议交换的信息称为HTTP报文，客户端发出的HTTP报文叫做请求报文，服务端返回的HTTP报文叫做响应报文，它们都是由多行数据构成的字符串文本<br><img src="https://s2.ax1x.com/2020/02/24/3GqajK.png" alt="格式如图"><br>大致可以分为两类</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>一个HTTP的请求报文通常由请求行，请求首部，空行(CR + LF)，请求主体4个部分组成，如图：<br><img src="https://s2.ax1x.com/2020/02/24/3GXN3n.png" alt="图片"><br>下面分别以get请求和post请求为例</p>
<h5 id="GET的请求报文"><a href="#GET的请求报文" class="headerlink" title="GET的请求报文"></a>GET的请求报文</h5><p>对于GET方法来说，它所有的请求参数都是拼接在URL最后，第一个参数前通过”?”连接，然后请求参数按照”key=value”格式进行追加，每个请求参数之间通过”&amp;”连接，如 ：<br><a href="http://www.myhost.com/text/?id=1&amp;…" target="_blank" rel="noopener">www.myhost.com/text/?id=1&amp;…</a><br>这个URL对于GET请求表示获取 <a href="http://www.myhost.com/text/" target="_blank" rel="noopener">www.myhost.com/text/</a> 位置下用户id为1，名为rain的文本，相应的请求报文格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /text/?id=1&amp;name=rain HTTP/1.1</span><br><span class="line">Host: www.myhost.com</span><br><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure></p>
<p>从上面的HTTP请求报文格式知，第一行为请求行，表明请求方式为GET，子路径为 /text/?id=1&amp;name=rain，HTTP版本为1.1，后两行为请求首部，Host为主机地址，Cache-Control为no-cache，表示客户端不接受服务端缓存过的资源，而GET的请求参数都在URL中，所以请求主体为空。</p>
<h5 id="POST的请求报文"><a href="#POST的请求报文" class="headerlink" title="POST的请求报文"></a>POST的请求报文</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST /local/ HTTP/1.1</span><br><span class="line">Host: www.myhost.com</span><br><span class="line">Accept-Encoding：gzip</span><br><span class="line">Content-Length: 222222</span><br><span class="line">Content-Type: multipart/from-data；boundary=dRGP2cPPTxE6WRTssnh4jC7HJLcSde</span><br><span class="line">Connection：Keep-Alive</span><br><span class="line"></span><br><span class="line">--dRGP2cPPTxE6WRTssnh4jC7HJLcSde</span><br><span class="line">Content-Disposition：from-data；name=“username”  //name = username</span><br><span class="line">Content-Type：text/plain：charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"></span><br><span class="line">rain										//value = rain</span><br><span class="line">--dRGP2cPPTxE6WRTssnh4jC7HJLcSde</span><br><span class="line">Content-Diaposition:from-data:name=&quot;image&quot;      //name = image</span><br><span class="line">filename=&quot;/storage/emulated/0/image/1234.png&quot;</span><br><span class="line">Content-Type:application/octet-stream</span><br><span class="line">Content-Transfer-Encoding:binary</span><br><span class="line"></span><br><span class="line">//...省略二进制数据					        //value = 二进制数据</span><br><span class="line">--dRGP2cPPTxE6WRTssnh4jC7HJLcSde--</span><br></pre></td></tr></table></figure>
<p>上述的请求报文的含义是向  <a href="http://www.myhost.com/local/" target="_blank" rel="noopener">www.myhost.com/local/</a>  这个地址发送一个POST请求，接受的内容编码方式为gzip，请求的数据长度为222222字节，请求的数据格式为 multipart/from-data（表单），报文的boundary值为dRGP2cPPTxE6WRTssnh4jC7HJLcSde，Keep-Alive为开启长连接，空行之后，接下来就是请求报文的主体，主体有两个请求参数：<br>一个是名为username，值为rain的文本；<br>一个是名为image，值为二进制数据的图片.</p>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>一个HTTP的响应报文通常由状态行、响应首部、空行(CR + LF)、响应主体组成<br><img src="https://s2.ax1x.com/2020/02/24/3Gx9cn.png" alt="格式如图"><br>比如这是一个GET请求的返回的响应报文格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP1.1 200 OK</span><br><span class="line">Data:Sat, 30, Dec 2006 23:23:00 GMT</span><br><span class="line">Content-Type:text/html；charset=UTF-8</span><br><span class="line">Content-Length:852</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">	//...省略文档内容</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面HTTP响应报文表示，HTTP协议版本为1.1，响应状态码为200，表示请求成功，返回数据的类型为text/html（html）, 编码为UTF-8，返回数据的内容长度为852字节，空行之后，接下来就是返回的数据，是一个html文档</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码的职责是当客户端向服务端发送请求时，描述服务端返回的请求结果，借助状态码，我们就可以得知服务端是正常处理了请求，还是出现了错误，下面是开发中经常遇见的状态码：</p>
<h4 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a>2XX成功</h4><p>2XX的响应结果表示请求被正常处理了.</p>
<ul>
<li>200 OK：请求没有问题，实体的主体部分包含了所请求的资源</li>
<li>204 No Content：该状态码表示服务端接收的请求已成功处理，但是在返回的响应报文中不包含主体部分，这说明请求处理成功，但是没有任何资源返回。比如当浏览器发出的请求处理后，返回204响应，那么浏览器显示的页面将不会发生任何更新；</li>
<li>206 Partial Content: 该状态码表示客户端进行了范围请求，而服务端成功返回了这一部分范围的资源，即响应报文的主体部分中会包含由Content-Range指定范围的内容。</li>
</ul>
<h4 id="3XX重定向"><a href="#3XX重定向" class="headerlink" title="3XX重定向"></a>3XX重定向</h4><p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。如果资源已经被移走，可发送一个重定向状态码和一个可选的Location首部来告知客户端资源已经被移走，以及现在可以在哪里找到它。浏览器就可以在不影响用户浏览体验的情况下透明地在新的位置找到所需资源了。</p>
<ul>
<li>301 Moved Permanently：永久性重定向，该状态码表示请求的资源已被分配了新的URL，以后都应使用新的URL来访问该资源，这时响应报文首部的Location字段会提示新的URL。例如你使用这个最后忘记加斜杠 / 的地址 <a href="http://www.myhost.com" target="_blank" rel="noopener">www.myhost.com</a> 来访问服务端，就会返回301状态码，提示你使用正确的地址访问，不过这些重定向的操作浏览器在背后已经替我们处理了，所以用户是无法感知的；</li>
<li>302 Found：临时重定向，该状态码表示请求的资源暂时被分配了新的URL，本次应使用新的URL来访问该资源，302代表资源不是被永久移动，而是临时移动，即本次会重定向到地址a，下一次可能会重定向到地址b或者不变，所以响应报文首部的Location字段提示的新URL并不是永久性的，而是临时性的；</li>
<li>303 See Other：临时重定向，该状态码表示请求的资源暂时被分配了新的URL，本次应使用新的URL通过GET方法来访问该资源，303和302功能相似，但是303明确表示客户端重定向时应采用GET方法获取资源，而302就没有这个要求。（但是在现实中，大部分浏览器都没有遵循规范，不管是301、302还是303，都会把POST改成GET，然后重新获取资源）；</li>
<li>304 Not Modified：304虽然被划分在3XX中，但是它和重定向没有任何关系，该状态码表示客户端访问的资源存在，但是未符合请求的附带条件，不允返回，这时返回的304响应报文不包含主体部分，请求的附带条件是指请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部。例如客户端想要检查本地资源缓存是否过期，就在GET请求中附带If-Modified-Since条件，If-Modified-Since的值是本地资源的Last-Modified(上一次修改时间)的值，服务端接收请求后，就会检查资源在服务端的上一次修改的时间是否比If-Modified-Since的值更新，如果没有，说明资源没有被修改过，返回304响应报文，告诉客户端可以继续使用本地缓存。</li>
</ul>
<h4 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h4><p>4XX的响应结果表示客户端发生错误的原因所在.</p>
<ul>
<li>400 Bad Request：该状态码表示客户端的请求报文中有语法错误，不能被服务端理解，当发生该错误后需要修改请求内容后再次发送；</li>
<li>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证的认证信息，401的响应报文会包含一个被请求资源的WWW-Authenticate首部用来质询用户信息，当浏览器初次接收到401响应，会弹出认证窗口，当浏览器第二次收到401响应，表示认证失败；</li>
<li>403 Forbidden：该状态码表示服务端收到了请求，但是拒绝提供服务，服务端不会给出拒绝的详细理由，例如没有文件的访问权限等都会返回404响应；</li>
<li>404 Not Found：该状态码表示请求资源在服务端上不存在，或者服务端拒绝请求但不想说明理由也会返回404；</li>
</ul>
<h4 id="5XX服务端错误"><a href="#5XX服务端错误" class="headerlink" title="5XX服务端错误"></a>5XX服务端错误</h4><p>5XX的响应结果表示服务端发送错误的原因所在.</p>
<ul>
<li>500 Internal Server Error：该状态码表示服务端执行请求时发生了不可预估的错误，它表明服务端Web应用存在bug或其他故障；</li>
<li>503 Server Unavailable：该状态码表示服务端当前不能处理客户端请求，一段时间后可能恢复正常，它表明服务端暂时处于超负载或停机维护状态，如果服务端得知故障恢复时间，它会在响应报文的Retry-After首部字段写入返回给客户端。</li>
</ul>
<h3 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie是用来管理客户端和服务端之间的状态，它是服务器发送到客户端并保存在本地的小型文本文件，其内容为一系列的键值对，Cookie并不属于HTTP/1.x的规范，但是由于HTTP的无状态特性，Cookie被广泛应用于各大Web网站的状态管理及用户识别。<br>Cookie的工作过程主要使用到了Set-Cookie和Cookie这两个首部，Set-Cookie首部存在于响应报文中，Set-Cookie首部包含服务端返回给客户端状态管理使用的Cookie信息，客户端收到响应后会从Set-Cookie首部中取出Cookie信息保存到本地；Cookie首部存在于请求报文中，Cookie首部包含客户端从服务端接收到的Cookie信息，每次客户端发起请求时，都会在请求报文的Cookie首部中携带Cookie信息发送给服务端。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>Cookie需要和服务端的Session配合使用，Cookie是存储在客户端中，而Session是存储在服务器端中，Session是服务端保存用户状态的方式，它们的工作过程大概如下：</p>
<ul>
<li>1 当用户登陆网站时，填入账号、密码等信息，然后提交表单，这些信息会被放入HTTP的请求报文，然后发送给服务端；</li>
<li>2 服务端收到请求后，验证该用户名和密码，如果正确，则为该用户创建一个Session对象，Session对象中保存了用户的状态信息，并生成Session对象的唯一ID，称为Session ID，然后把Session对象存储到内存或数据库中，根据Session ID根据从内存或数据库获取到Session对象；</li>
<li>3 接着服务端把Session ID的值以name=value的形式放入响应报文的Set-Cookie首部中，其中name为Session ID的名字，value就是Session ID的值，name=value形式的Session ID就称为Cookie，Set-Cookie首部除了Session ID之外，还有一些其他信息，如Cookie的有效期、Cookie的域名范围等，然后把这个响应报文发送给客户端；</li>
<li>4 客户端收到响应报文之后从Set-Cookie首部中取出所有Cookie信息，然后把它保存到本地，客户端有时候会收到不止一个Set-Cookie首部，如果有多个，每个Set-Cookie首部中的Cookie信息都要保存；</li>
<li>5 客户端之后对同一个服务端进行请求时都会从本地取出Cookie信息，这时可以校验Cookie的有效期、路径、域名等信息，然后取出其中的Cookie值放入请求报文的Cookie首部字段，如果有多个Cookie值，Cookie首部中就用 ; 分隔，然后把这个请求报文发送给服务端；</li>
<li>6 服务器收到请求后，从Cookie首部中取出Cookie，从Cookie中取出Session ID，然后用Session ID从内存或数据库取出用户信息，恢复用户之前的操作状态。</li>
</ul>
<p>关于Cookie与Session建议：<a href="https://zhuanlan.zhihu.com/p/27669892" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27669892</a><br>或者《图解http》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/24/TCP,UDP总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/24/TCP,UDP总结/" itemprop="url">TCP,UDP知识总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-24T00:00:00+08:00">
                2020-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/24/TCP,UDP总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/24/TCP,UDP总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TCP-UDP的对比"><a href="#TCP-UDP的对比" class="headerlink" title="TCP,UDP的对比"></a>TCP,UDP的对比</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP（Transmission Control Protocol，传输控制协议），是一种面向连接的，基于窗口滑动的可靠传输协议，提供可靠（无差错、不丢失、不重复、按顺序）的字节流数据传输服务。在传输效率和可靠性之间选择了后者，所以有开销大、传输速度慢的缺点。</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP（User Datagram Protocol，用户数据报协议），是一种无连接的非可靠传输层协议。UDP 不提供数据包分组、组装，不能对数据段进行排序，所以 UDP 数据段的首部非常简单。换句话说，当数据段发送出去之后，发送方是无法得知其是否完整且安全的到达了接收方的。这样的传输机制决定了它的最大优点就是快，同时也决定了它最大的缺点不可靠、不稳定。</p>
<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><h4 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP:"></a>TCP:</h4><ul>
<li>1 面向连接：需要通过三次握手建立连接。</li>
<li>2 点对点：一条 TCP 连接只能连接两个端点，一对一通信。</li>
<li>3 字节流传输：TCP 会将数据当作字节流进行处理，不尝试理解所传输的数据含义，仅把数据看作一连串的字节序列。</li>
<li>4 可靠传输：使用窗口滑动的流量控制和拥塞控制</li>
<li>5 首部开销大：最少20字节，最大60字节</li>
</ul>
<h4 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP:"></a>UDP:</h4><ul>
<li>1 无连接</li>
<li>2 支持单传，多传，广播（一对一，一对多，多对一，多对多）</li>
<li>3 对应用层交付的报文直接打包：不提供数据包分组、组装，不能对数据段进行排序</li>
<li>4 不可靠：尽最大努力交付，不使用流量控制和拥塞控制</li>
<li>5 首部开销小：仅8个字节</li>
</ul>
<h2 id="TCP-2"><a href="#TCP-2" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。<br><img src="https://s2.ax1x.com/2020/02/23/31cCgP.jpg" alt="图片"></p>
<ul>
<li>1 第一次握手：客户端将标志位SYN置为1（SYN为1时不能携带数据），随机产生一个值seq=x，作为TCP客户进程的初始序号，并将该数据包发送给服务器端，客户端进入SYN_SENT同步已发送状态，等待服务器端确认。</li>
<li>2 第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，表明这是一个TCP确认请求报文，ack=x+1,表明对客户进程初始序号的确认，随机产生一个值seq=y作为服务器进程的初始序号，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD同步已接收状态。</li>
<li>3 第三次握手：客户端收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，seq=x+1并将该数据包发送给服务器端，服务器端检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED连接已建立状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。<br>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。<br><img src="https://s2.ax1x.com/2020/02/23/33uXLD.png" alt="图片"></p>
<ul>
<li>1 第一次挥手：客户端发送一个FIN=1，ACK=1，用来关闭客户端到服务器端的数据传送,seq=u，u为之前客户端传送的数据的最后一个字节序号加1，ack=v,v为之前客户端收到的数据的最后一个字节序号加1，客户端进入FIN_WAIT_1终止等待1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>
<li>2 第二次挥手：服务器端收到FIN后进入CLOSE-WAIT关闭等待状态，ACK=1,seq=v,v表明之前服务器传送的数据的最后一个字节序号加1，ack=u+1(对收到客户端报文的确认)，对客户端，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 终止等待2状态，继续等待服务器端的FIN报文。</li>
<li>3 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=1，ACK=1,seq=w(半关闭状态下可能又发送了数据),ack=u+1（对收到客户端报文的重复确认）报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK最后确认状态。</li>
<li>4 第四次挥手：客户端收到报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ACK=1,seq=u+1,ack=w+1后进入TIME_WAIT时间等待状态，如果服务端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>
</ul>
<p>本文参考：<a href="https://www.youtube.com/watch?v=p799RP-YFY8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=p799RP-YFY8</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/22/网络模型知多少/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/22/网络模型知多少/" itemprop="url">网络模型知识总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-22T00:00:00+08:00">
                2020-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/22/网络模型知多少/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/22/网络模型知多少/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景以及夙愿"><a href="#背景以及夙愿" class="headerlink" title="背景以及夙愿"></a>背景以及夙愿</h2><p>都快还给老师了，往回捡一捡</p>
<h2 id="osi网络模型"><a href="#osi网络模型" class="headerlink" title="osi网络模型"></a>osi网络模型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>即开放式系统互联。 一般都叫OSI参考模型，是国际标准化组织为了普及网络应用而推出的，含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了</p>
<h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>由下到上分为物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3MOsot.md.jpg" alt="图片"></p>
<h4 id="各层功能定义概述"><a href="#各层功能定义概述" class="headerlink" title="各层功能定义概述"></a>各层功能定义概述</h4><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p>OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p>
<p>举例：某东上，卖家和买家都是我们所述的用户，他们的线上买卖行为，退货退款等都是应用层提供的网络服务</p>
<h5 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h5><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>举例：由于卖家A和买家B是不同国家的，他们之间的商定统一用英语作为交流的语言，所以此时表示层，就是将应用层的传递信息转翻译成英语。同时为了防止信息被人截获，A的人也会对这份信息单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</p>
<h5 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h5><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成，。      </p>
<p>举例：B跟A聊完，还想货比三家，就去找其他卖家聊，会话层掌握着其他卖家的信息，负责建立通话并记录通话，首先要找到其他卖家的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，随后终止通话。</p>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p>
<p>举例：传输层就相当于负责快递邮件收发的人，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p>
<p>举例：网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</p>
<h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。<br>数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。<br>MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p>
<h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<h2 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP/IP网络模型"></a>TCP/IP网络模型</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>如果说OSI网络模型是一种理想化的标准，那么TCP/IP就是一种成功的具体实现，它的分层：物理层，数据链路层，网络层，传输层，应用层<br>与OSI对应关系如下：<br><img src="https://s2.ax1x.com/2020/02/22/3Q28kd.md.jpg" alt="图片"></p>
<h3 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h3><p>下图以用户 a 向用户 b 发送邮件为例子：<br><img src="https://s2.ax1x.com/2020/02/23/31mTbj.png" alt="图片"></p>
<ul>
<li>1 ① 应用程序处理<br>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；<br>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</li>
<li>2 ② TCP 模块的处理<br>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</li>
<li>3 ③ IP 模块的处理<br>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</li>
<li>4 ④ 网络接口（以太网驱动）的处理<br>从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</li>
<li>5 ⑤ 网络接口（以太网驱动）的处理主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</li>
<li>6 ⑥ IP 模块的处理IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</li>
<li>7 ⑦ TCP 模块的处理<br>在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</li>
<li>8 ⑧ 应用程序的处理<br>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</li>
</ul>
<p>注：常常说的tcp,udp就是传输层的协议。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/30/零零散散/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/30/零零散散/" itemprop="url">零零散散</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-30T00:00:00+08:00">
                2019-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/30/零零散散/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/30/零零散散/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LeakCanary是如何检测到内存泄漏的？"><a href="#LeakCanary是如何检测到内存泄漏的？" class="headerlink" title="LeakCanary是如何检测到内存泄漏的？"></a>LeakCanary是如何检测到内存泄漏的？</h2><p>LeakCanay的入口是在application的onCreate()方法中声明的，其实用的就是Application的ActivityLifecycleCallbacks回调接口监听所有activity的onDestory()的，在这个方法进行RefWatcher.watch对这个对象进行监控。具体是这样做的，把activity对象封装成带key值和带引用队列(ReferenceQueue)的KeyedWeakReference对象，然后GC看弱引用对象有没有回收，没有回收的话就怀疑是泄漏了，需要二次确认。然后生成HPROF文件，分析这个快照文件有没有存在带这个key值的泄漏对象，如果没有，那么没有泄漏，否则找出最短路径，打印给我们，我们就能够找到这个泄漏对象了。</p>
<h2 id="如何判断app在前台还是后台"><a href="#如何判断app在前台还是后台" class="headerlink" title="如何判断app在前台还是后台?"></a>如何判断app在前台还是后台?</h2><p>Application类里有ActivityLifecycleCallbacks回调接口,可以监听Application的生命周期，通常执行onstart()视为前台，执行onStop()视为后台 </p>
<h2 id="WindowManager-addView-，View-getParent-分别对应？"><a href="#WindowManager-addView-，View-getParent-分别对应？" class="headerlink" title="WindowManager.addView()，View.getParent()分别对应？"></a>WindowManager.addView()，View.getParent()分别对应？</h2><p><img src="https://s2.ax1x.com/2019/12/31/l1g5Z9.png" alt="图片"></p>
<p>WindowManager.addView()是将DecorView作为根布局加入到PhoneWindow中去，而View.getParent()指得是普通子view的父view</p>
<h2 id="Serializable和Parcelable的区别？"><a href="#Serializable和Parcelable的区别？" class="headerlink" title="Serializable和Parcelable的区别？"></a>Serializable和Parcelable的区别？</h2><ul>
<li>1 效率不同，两者最大的区别在于 存储媒介的不同，Serializable会使用反射，这个过程中使用 I/O 读写存储在硬盘上，而 Parcelable 不需要用反射，直接 在内存中读写。很明显，内存的读写速度通常大于 IO 读写，所以在 Android 中传递数据优先选择 Parcelable。</li>
<li>2 用法不同<br>Serializable使用简单<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TestSerializable implements Serializable &#123;</span><br><span class="line">    String msg;</span><br><span class="line">    </span><br><span class="line">    List&lt;ItemBean&gt; datas;</span><br><span class="line">    </span><br><span class="line">    public static class ItemBean implements Serializable&#123;</span><br><span class="line">        String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Parcelable较为复杂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TestParcelable implements Parcelable &#123;</span><br><span class="line">    String msg;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(this.msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TestParcelable(String msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TestParcelable(Parcel in) &#123;</span><br><span class="line">        this.msg = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;TestParcelable&gt; CREATOR = new Creator&lt;TestParcelable&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public TestParcelable createFromParcel(Parcel source) &#123;</span><br><span class="line">            return new TestParcelable(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public TestParcelable[] newArray(int size) &#123;</span><br><span class="line">            return new TestParcelable[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Android里面为什么要设计出Bundle而不是直接用Map结构？"><a href="#Android里面为什么要设计出Bundle而不是直接用Map结构？" class="headerlink" title="Android里面为什么要设计出Bundle而不是直接用Map结构？"></a>Android里面为什么要设计出Bundle而不是直接用Map结构？</h3><ul>
<li>1 是在Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为了更加快速的进行数据的序列化和反序列化，系统封装了Bundle类，方便我们进行数据的传输。</li>
<li>2 Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数据对应下标，一个对象数组保存key和value，内部使用二分法对key进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，只适合于小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据量，我没见过在两个Activity之间传递10个以上数据的场景，所以相比之下，在这种情况下使用ArrayMap保存数据，在操作速度和内存占用上都具有优势，因此使用Bundle来传递数据，可以保证更快的速度和更少的内存占用。</li>
</ul>
<h2 id="Java自动装箱和自动拆箱"><a href="#Java自动装箱和自动拆箱" class="headerlink" title="Java自动装箱和自动拆箱"></a>Java自动装箱和自动拆箱</h2><p>装箱就是自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。<br>举例：int是基本数据类型，Integer是包装器类型，看Integer.valueOf ( int i ) 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;       </span><br><span class="line">        if (i &gt;= -128 &amp;&amp; i &lt;= 127)</span><br><span class="line">            return IntegerCache.cache[i + 127];</span><br><span class="line">            //如果i的值大于-128小于127则返回一个缓冲区中的一个Integer对象</span><br><span class="line">        return new Integer(i);</span><br><span class="line">        //否则返回 new 一个Integer 对象</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>原来IntegerCache 类在初始化的时候，生成了一个大小为 256 的integer 类型的常量池，并且integer.val 的值从-128-127，当我们运行 Integer c=a ;时，如果 -128&lt;=a&lt;=127时，不会再生成新的integer对象，直接从常量池中找到对应的已经初始化后的对象。当 a&lt;-128||a&gt;127时会生成一个新的对象。</p>
<h2 id="synchronized与volatile"><a href="#synchronized与volatile" class="headerlink" title="synchronized与volatile"></a>synchronized与volatile</h2><h3 id="synchronized："><a href="#synchronized：" class="headerlink" title="synchronized："></a>synchronized：</h3><p>同步块大家都比较熟悉，通过 synchronized 关键字来实现，所有加上synchronized 和 块语句，在多线程访问的时候，同一时刻只能有一个线程能够用<br>synchronized 修饰的方法 或者 代码块。</p>
<h3 id="volatile："><a href="#volatile：" class="headerlink" title="volatile："></a>volatile：</h3><p>用volatile修饰的变量，线程在每次使用变量的时候，都会去读主内存，取变量修改后的最新的值。</p>
<h4 id="JVM在运行时候的内存分配过程："><a href="#JVM在运行时候的内存分配过程：" class="headerlink" title="JVM在运行时候的内存分配过程："></a>JVM在运行时候的内存分配过程：</h4><p>有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个线程栈，<br>线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存<br>变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，<br>在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。<br><img src="https://s2.ax1x.com/2019/12/31/l1cs1O.png" alt="图片"><br>小结：加上volatile关键字，强制线程每次读取该值的时候都去“主内存”中取值。保证了线程安全。</p>
<h2 id="requestLayout、invalidate与postInvalidate区别"><a href="#requestLayout、invalidate与postInvalidate区别" class="headerlink" title="requestLayout、invalidate与postInvalidate区别"></a>requestLayout、invalidate与postInvalidate区别</h2><h3 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout:"></a>requestLayout:</h3><p>从方法名字可以知道，“请求布局”，那就是说，如果调用了这个方法，那么对于一个子View来说，应该会重新进行布局流程。但是，真实情况略有不同，如果子View调用了这个方法，其实会从View树重新进行一次测量、布局、绘制这三个流程，最终就会显示子View的最终情况。</p>
<h3 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate:"></a>invalidate:</h3><p>view的invalidate不会导致ViewRootImpl的invalidate被调用，而是递归调用父view的invalidateChildInParent，直到ViewRootImpl的invalidateChildInParent，然后触发peformTraversals，会导致当前view被重绘,由于mLayoutRequested为false，不会导致onMeasure和onLayout被调用，而OnDraw会被调用</p>
<h3 id="postInvalidate"><a href="#postInvalidate" class="headerlink" title="postInvalidate:"></a>postInvalidate:</h3><p>postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。</p>
<p><img src="https://s2.ax1x.com/2019/12/31/l1prYq.png" alt="图片"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/Binder机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/Binder机制/" itemprop="url">Binder机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-28T00:00:00+08:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/28/Binder机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/28/Binder机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="本篇文章的背景以及夙愿"><a href="#本篇文章的背景以及夙愿" class="headerlink" title="本篇文章的背景以及夙愿"></a>本篇文章的背景以及夙愿</h2><ul>
<li>1 了解Binder机制，毕竟挺难的</li>
<li>2 陪媳妇儿加班中，待着也是待着</li>
</ul>
<h2 id="正文之前需要说得Binder"><a href="#正文之前需要说得Binder" class="headerlink" title="正文之前需要说得Binder"></a>正文之前需要说得Binder</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>一句话，Binder是一种进程间通信机制</p>
<h3 id="Android为什么选择Binder"><a href="#Android为什么选择Binder" class="headerlink" title="Android为什么选择Binder"></a>Android为什么选择Binder</h3><p>Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于性能、稳定性和安全性几方面的原因。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</p>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<h2 id="Linux-下传统的进程间通信原理"><a href="#Linux-下传统的进程间通信原理" class="headerlink" title="Linux 下传统的进程间通信原理"></a>Linux 下传统的进程间通信原理</h2><p><img src="https://s2.ax1x.com/2019/12/28/lmA4FP.png" alt="图片"></p>
<h3 id="涉及几个概念："><a href="#涉及几个概念：" class="headerlink" title="涉及几个概念："></a>涉及几个概念：</h3><ul>
<li><p>1 进程隔离<br>简单的说就是操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。</p>
</li>
<li><p>2 进程空间划分<br>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
</li>
<li><p>3 系统调用：用户态与内核态<br>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助系统调用来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
</li>
</ul>
<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。<br>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。<br>当进程在执行用户自己的代码的时候，我们称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。</p>
<h3 id="传统通信原理简述"><a href="#传统通信原理简述" class="headerlink" title="传统通信原理简述"></a>传统通信原理简述</h3><p>通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。<br>如下图：<br><img src="https://s2.ax1x.com/2019/12/28/lmEgpT.png" alt="图片"></p>
<h3 id="传统的-IPC-通信方式缺点"><a href="#传统的-IPC-通信方式缺点" class="headerlink" title="传统的 IPC 通信方式缺点"></a>传统的 IPC 通信方式缺点</h3><ul>
<li>1 性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>2 接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>
</ul>
<h2 id="Binder跨进程通信原理"><a href="#Binder跨进程通信原理" class="headerlink" title="Binder跨进程通信原理"></a>Binder跨进程通信原理</h2><h3 id="涉及几个概念：-1"><a href="#涉及几个概念：-1" class="headerlink" title="涉及几个概念："></a>涉及几个概念：</h3><ul>
<li>1 动态内核可加载模块<br>模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。</li>
<li>2 内存映射<br>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。<br>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</li>
</ul>
<h3 id="Binder-IPC-实现步骤："><a href="#Binder-IPC-实现步骤：" class="headerlink" title="Binder IPC 实现步骤："></a>Binder IPC 实现步骤：</h3><ul>
<li>1 首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>
<li>2 接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系；</li>
<li>3 发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。<br>如下图：<br><img src="https://s2.ax1x.com/2019/12/28/lmDiGt.png" alt="图片"></li>
</ul>
<h2 id="Binder通信过程"><a href="#Binder通信过程" class="headerlink" title="Binder通信过程"></a>Binder通信过程</h2><p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h3 id="互联网通信过程："><a href="#互联网通信过程：" class="headerlink" title="互联网通信过程："></a>互联网通信过程：</h3><p>包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。<br>如下图：<br><img src="https://s2.ax1x.com/2019/12/29/lus9jx.md.png" alt="图片"><br>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之间的关系。<br>通常我们访问一个网页的步骤是这样的：首先在浏览器输入一个地址，如 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 然后按下回车键。但是并没有办法通过域名地址直接找到我们要访问的服务器，因此需要首先访问 DNS 域名服务器，域名服务器中保存了 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 对应的 ip 地址 10.249.23.13，然后通过这个 ip 地址才能放到到 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 对应的服务器。<br><img src="https://s2.ax1x.com/2019/12/29/lus2x1.png" alt="图片"></p>
<h3 id="Binder通信过程："><a href="#Binder通信过程：" class="headerlink" title="Binder通信过程："></a>Binder通信过程：</h3><p>大致能总结出 Binder 通信过程：</p>
<ul>
<li>1 首先，一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>2 Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>3 Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。<br><img src="https://s2.ax1x.com/2019/12/29/luy3sx.png" alt="图片"></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/24/Glide源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/24/Glide源码分析/" itemprop="url">Glide源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-24T00:00:00+08:00">
                2019-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/24/Glide源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/10/24/Glide源码分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Glide加载流程？"><a href="#Glide加载流程？" class="headerlink" title="Glide加载流程？"></a>Glide加载流程？</h2><p>先看一眼Glide最简单的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this).load(url).into(imageView);</span><br></pre></td></tr></table></figure></p>
<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p>再看一眼整体架构图<br><img src="https://s2.ax1x.com/2019/10/28/KcUoKH.png" alt="图片"><br>我们也从这三个方面来分析</p>
<h3 id="with-方法"><a href="#with-方法" class="headerlink" title="with()方法"></a>with()方法</h3><p>首先with()方法的参数是什么？</p>
<ul>
<li>1 传递Activity，则此次加载图片会在退出Activity后自动取消；</li>
<li>2 传递Fragment，则加载图片会在Fragment销毁时取消；</li>
<li>3 传递Application，那么Glide将无法管理图片请求生命周期。<br>然后看with()方法的源码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">       RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">       <span class="keyword">return</span> retriever.get(context);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">       RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">       <span class="keyword">return</span> retriever.get(activity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">       RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">       <span class="keyword">return</span> retriever.get(activity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@TargetApi</span>(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(android.app.Fragment fragment)</span> </span>&#123;</span><br><span class="line">       RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">       <span class="keyword">return</span> retriever.get(fragment);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">       RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">       <span class="keyword">return</span> retriever.get(fragment);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>每一个with()方法重载的代码都非常简单，都是先调用RequestManagerRetriever的静态get()方法得到一个RequestManagerRetriever对象，这个静态get()方法就是一个单例实现。然后再调用RequestManagerRetriever的实例get()方法，去获取RequestManager对象。换句话说，每一个Activity存在一个对应的RequestManager，每一个不同的Fragment也有其对应的RequestManager，而整个应用运行阶段同样会有一个RequestManager。这些不同的RequestManager通过RequestManagerRetriever.get获取。RequestManagerRetriever同样重载了多个get方法，以get(FragmentActivity)为例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestManagerRetriever</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">      <span class="keyword">return</span> supportFragmentGet(activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里从是否在主线程的角度来看：</p>
<ul>
<li>1 若在主线程，则获得Activity对应的FragmentManager来获得RequestManager（Fragment同理）。</li>
<li>2 若在非主线程，那么不管你是传入的Activity还是Fragment，都会被强制当成Application来处理 。</li>
</ul>
<p>也可以从传入Application和非Application的角度来看：</p>
<ul>
<li>1 传Application，因为Application对象的生命周期即应用程序的生命周期，因此Glide并不需要做什么特殊的处理，它自动就是和应用程序的生命周期是同步的，如果应用程序关闭的话，Glide的加载也会同时终止。</li>
<li>2 传非Application，传入非Application参数的情况。不管在Glide.with()方法中传入的是Activity、FragmentActivity、v4包下的Fragment、还是app包下的Fragment，最终的流程都是一样的，那就是会向当前的Activity当中添加一个隐藏的Fragment。因为Glide需要知道加载的生命周期。很简单的一个道理，如果你在某个Activity上正在加载着一张图片，结果图片还没加载出来，Activity就被用户关掉了，那么图片还应该继续加载吗？当然不应该。可是Glide并没有办法知道Activity的生命周期，于是Glide就使用了添加隐藏Fragment的这种小技巧，因为Fragment的生命周期和Activity是同步的，如果Activity被销毁了，Fragment是可以监听到的，这样Glide就可以捕获这个事件并停止图片加载了。</li>
</ul>
<p>那么</p>
<h4 id="如何绑定生命周期"><a href="#如何绑定生命周期" class="headerlink" title="如何绑定生命周期"></a>如何绑定生命周期</h4><p>继续接着上面的代码看supportFragmentGet<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RequestManager <span class="title">supportFragmentGet</span><span class="params">(Context context, FragmentManager fm)</span> </span>&#123;</span><br><span class="line">       SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);</span><br><span class="line">       RequestManager requestManager = current.getRequestManager();</span><br><span class="line">       <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">           requestManager = <span class="keyword">new</span> RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">           current.setRequestManager(requestManager);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> requestManager;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在fragment 中创建RequestManager，并且传入getLifecycle()，通过Lifecycle实现生命周期的绑定</p>
<h3 id="load-方法"><a href="#load-方法" class="headerlink" title="load()方法"></a>load()方法</h3><p><code>Glide.with</code>获得RequestManager之后，执行load方法设置图片源。图片源可以是：图片数据字节数组、File文件，网络图片地址等。以<code>load(String)</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestManager</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load方法默认设置目标资源为 <strong>Drawable</strong>，获得一个RequestBuilder。紧接着调用<code>RequestBuilder.load</code>方法记录加载的model(图片源)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(@Nullable Object model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    isModelSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestBuilder是请求构建者，用户可以使用它设置如：单独的缓存策略、加载成功前占位图、加载失败后显示图片等等加载图片的各种配置。当RequestBuilder 构建完成之后，接下来就等待执行这个请求。</p>
<h3 id="into-方法"><a href="#into-方法" class="headerlink" title="into()方法"></a>into()方法</h3><p><code>Glide.with</code>获得RequestManager之后，执行load方法设置图片源。图片源可以是：图片数据字节数组、File文件，网络图片地址等。以<code>load(String)</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestManager</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load方法默认设置目标资源为 <strong>Drawable</strong>，获得一个RequestBuilder。紧接着调用<code>RequestBuilder.load</code>方法记录加载的model(图片源)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(@Nullable Object model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    isModelSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestBuilder是请求构建者，用户可以使用它设置如：单独的缓存策略、加载成功前占位图、加载失败后显示图片等等加载图片的各种配置。当RequestBuilder 构建完成之后，接下来就等待执行这个请求。</p>
<p>使用Glide最简单的方式加载图片最后一个阶段就是执行into方法。从into方法为入口开始执行图片加载，逻辑也开始复杂起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestBuilder</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(@NonNull ImageView view)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line"></span><br><span class="line">    BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">        &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">        &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Clone in this method so that if we use this RequestBuilder to load into a View and then</span></span><br><span class="line">      <span class="comment">// into a different target, we don't retain the transformation applied based on the previous</span></span><br><span class="line">      <span class="comment">// View's scale type.</span></span><br><span class="line">      <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">        <span class="keyword">case</span> FIT_START:</span><br><span class="line">        <span class="keyword">case</span> FIT_END:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FIT_XY:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CENTER:</span><br><span class="line">        <span class="keyword">case</span> MATRIX:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// Do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> into(</span><br><span class="line">        glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">        <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">        requestOptions,</span><br><span class="line">        Executors.mainThreadExecutor());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，我们在执行into时传入一个ImageView用于显示。在这个into方法中，先确定本次加载的BaseRequestOptions，然后执行重载的另一个into方法。其中BaseRequestOptions就是上面我们提到的RequestBuilder可以设置图片加载的各种配置，这些配置选项就被封装在BaseRequestOptions中(RequestBuilder extends BaseRequestOptions)。而重载的into方法实现为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GenericRequestBuilder</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(Y target)</span> </span>&#123;</span><br><span class="line">        Util.assertMainThread();</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must pass in a non null Target"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must first set a model (try #load())"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Request previous = target.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            previous.clear();</span><br><span class="line">            requestTracker.removeRequest(previous);</span><br><span class="line">            previous.recycle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Request request = buildRequest(target);</span><br><span class="line">        target.setRequest(request);</span><br><span class="line">        lifecycle.addListener(target);</span><br><span class="line">        requestTracker.runRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个into方法中首先调用 buildRequest 构建了一个请求Request，然后把Request交给RequestManager跟踪(生命周期)并启动请求。<br>跟进requestTracker.runRequest()；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Starts tracking the given request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">      requests.add(request);</span><br><span class="line">      <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">          request.begin();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          pendingRequests.add(request);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>先判断Glide当前是不是处理暂停状态，如果不是暂停状态就调用Request的begin()方法来执行Request，否则的话就先将Request添加到待执行队列里面，等暂停状态解除了之后再执行。<br>跟进request.begin();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onException(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target.getSize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(<span class="string">"finished run method in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>跟进onException(null);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"load failed"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = Status.FAILED;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> what if this is a thumbnail request?</span></span><br><span class="line">    <span class="keyword">if</span> (requestListener == <span class="keyword">null</span> || !requestListener.onException(e, model, target, isFirstReadyResource())) &#123;</span><br><span class="line">        setErrorPlaceholder(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再跟setErrorPlaceholder(e);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">          Log.d(TAG, <span class="string">"load failed"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      status = Status.FAILED;</span><br><span class="line">      <span class="comment">//<span class="doctag">TODO:</span> what if this is a thumbnail request?</span></span><br><span class="line">      <span class="keyword">if</span> (requestListener == <span class="keyword">null</span> || !requestListener.onException(e, model, target, isFirstReadyResource())) &#123;</span><br><span class="line">          setErrorPlaceholder(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setErrorPlaceholder</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!canNotifyStatusChanged()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Drawable error = model == <span class="keyword">null</span> ? getFallbackDrawable() : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">        error = getErrorDrawable();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">          error = getPlaceholderDrawable();</span><br><span class="line">      &#125;</span><br><span class="line">      target.onLoadFailed(e, error);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>其实就是将这张error占位图显示到ImageView上而已，因为现在出现了异常，没办法展示正常的图片了。而如果你仔细看下刚才begin()方法的第15行，你会发现它又调用了一个target.onLoadStarted()方法，并传入了一个loading占位图，在也就说，在图片请求开始之前，会先使用这张占位图代替最终的图片显示。</p>
<p>回到begin()，主要是判断当前Request的各种状态并且设置占位图，而启动加载是在第四步开始的。当用户设置了图片的宽高时执行<code>onSizeReady</code>启动加载，而如果未设置则会执行<code>target.getSize(this)</code>计算目标View(需要显示的ImageView)的大小，在计算完之后，它也会调用onSizeReady()方法。也就是说，不管是哪种情况，最终都会调用到onSizeReady()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">      status = Status.RUNNING;</span><br><span class="line">      loadStatus =</span><br><span class="line">          engine.load(</span><br><span class="line">              glideContext,</span><br><span class="line">              model,</span><br><span class="line">              requestOptions.getSignature(),</span><br><span class="line">              <span class="keyword">this</span>.width,</span><br><span class="line">              <span class="keyword">this</span>.height,</span><br><span class="line">              requestOptions.getResourceClass(),</span><br><span class="line">              transcodeClass,</span><br><span class="line">              priority,</span><br><span class="line">              requestOptions.getDiskCacheStrategy(),</span><br><span class="line">              requestOptions.getTransformations(),</span><br><span class="line">              requestOptions.isTransformationRequired(),</span><br><span class="line">              requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">              requestOptions.getOptions(),</span><br><span class="line">              requestOptions.isMemoryCacheable(),</span><br><span class="line">              requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">              requestOptions.getUseAnimationPool(),</span><br><span class="line">              requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">              <span class="keyword">this</span>,</span><br><span class="line">              callbackExecutor);</span><br><span class="line">      <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onSizeReady将获得一系列的值一起传入到了Engine的load()方法当中开始加载图片。</p>
<p><strong>Engine</strong>类顾名思义:引擎，是Glide加载的发动机，跟进Engine的load()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="comment">//1、根据参数（模型、宽、高等）构建加载的标识key</span></span><br><span class="line">    EngineKey key =</span><br><span class="line">        keyFactory.buildKey(</span><br><span class="line">            model,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            transformations,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            options);</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Loaded resource from active resources"</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Loaded resource from cache"</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">      current.addCallback(cb, callbackExecutor);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Added to existing load"</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2、创建新的job并执行加载</span></span><br><span class="line">    EngineJob&lt;R&gt; engineJob =</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">            key,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache);</span><br><span class="line"> <span class="comment">// DecodeJob就是一个Runnable,EngineJob包含的线程池启动线程并能够接收线程中执行过程的回调</span></span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">        decodeJobFactory.build(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            key,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            diskCacheStrategy,</span><br><span class="line">            transformations,</span><br><span class="line">            isTransformationRequired,</span><br><span class="line">            isScaleOnlyOrNoTransform,</span><br><span class="line">            onlyRetrieveFromCache,</span><br><span class="line">            options,</span><br><span class="line">            engineJob);</span><br><span class="line"></span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">    engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line">    <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(<span class="string">"Started new load"</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果引擎中没有同样的正在加载的请求，此处会创建一个实现了Runable接口的DecodeJob并执行。<br>跟进engineJob.start(decodeJob);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EngineJob </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    GlideExecutor executor =</span><br><span class="line">        decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class="line">    executor.execute(decodeJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用线程池执行任务DecodeJob。</p>
<blockquote>
<p>如果需要获取一张图片，那么先从内存缓存中获得，内存缓存不需要进行额外的操作，只要匹配就能直接获取。但是内存缓存不存在，这时候就需要先检查磁盘缓存最后再决定是否需要向图片源(如网络)进行加载。而无论是进行图片磁盘缓存的获取还是向网络请求都是耗时操作，这时候就需要开启线程来执行加载。因此内存缓存一旦不存在，就会使用线程池开启DecodeJob异步任务。而DecodeJob中就会去磁盘缓存查找或者网络中下载图片。</p>
</blockquote>
<p>DecodeJob是实现了Runable接口的一个任务，当使用线程去执行这个任务，自然就会执行run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DecodeJob</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">      runWrapped();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>run方法中除了取消与加载失败的判断，核心的加载逻辑都放在了runWrapped中。在介绍这个方法之前，先简单的了解下Glide中磁盘缓存。 Glide可以缓存两种不同的数据在磁盘文件中：</p>
<ul>
<li>1 资源类型（Resource） - 曾被解码、转换并写入的磁盘缓存。如对原图片进行了缩放，存放缩放后的图片。</li>
<li>2 数据来源 (Data) - 原图片缓存</li>
</ul>
<p>而runWrapped方法的实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DecodeJob</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">      <span class="keyword">case</span> INITIALIZE: </span><br><span class="line">        <span class="comment">// 1. 获取任务的场景</span></span><br><span class="line">        stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">        <span class="comment">// 2. 获取这个场景的执行者</span></span><br><span class="line">        currentGenerator = getNextGenerator();</span><br><span class="line">        <span class="comment">// 3. 执行者执行任务</span></span><br><span class="line">        runGenerators();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">        <span class="comment">// 当图片数据无法从缓存加载时，会切换执行原因并记录，然后重新提交本任务给线程池</span></span><br><span class="line">        <span class="comment">// （使用另一个线程池执行图片源加载，如：网络加载任务）</span></span><br><span class="line">        runGenerators();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">        <span class="comment">// 切换为解码图片,获得的图片数据，比如网络下载了 a.png 得到其byte数组，</span></span><br><span class="line">        <span class="comment">// byte数组中记录的是png编码后的数据，BitmapFactory.decodeXX 会解码生成Bitmap对象</span></span><br><span class="line">        <span class="comment">// 同时解码过程中可能还需要进行缩放、变换等操作    </span></span><br><span class="line">        decodeFromRetrievedData();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized run reason: "</span> + runReason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stage <span class="title">getNextStage</span><span class="params">(Stage current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">       <span class="comment">// 1 如果配置的缓存策略允许从 资源缓存 中读数据, 则返回 Stage.RESOURCE_CACHE</span></span><br><span class="line">      <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">        <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">            ? Stage.RESOURCE_CACHE</span><br><span class="line">            : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">      <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">        <span class="comment">// 2 如果配置的缓存策略允许从 源数据缓存 中读数据, 则返回 Stage.DATA_CACHE</span></span><br><span class="line">        <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">            ? Stage.DATA_CACHE</span><br><span class="line">            : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">      <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">        <span class="comment">// 3 如果只允许从缓存中获取数据, 则直接 FINISH, 否则返回 Stage.SOURCE,表示加载一个新的资源</span></span><br><span class="line">        <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">      <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">case</span> FINISHED:</span><br><span class="line">        <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unrecognized stage: "</span> + current);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">      <span class="comment">// 资源磁盘缓存的执行者</span></span><br><span class="line">      <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">     <span class="comment">// 源数据磁盘缓存的执行者</span></span><br><span class="line">      <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">case</span> SOURCE:</span><br><span class="line">     <span class="comment">// 无缓存, 获取数据的源的执行者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">case</span> FINISHED:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized stage: "</span> + stage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 调用 DataFetcherGenerator.startNext() 执行请求操作</span></span><br><span class="line">    <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isCancelled</span><br><span class="line">        &amp;&amp; currentGenerator != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class="line">      <span class="comment">//如果执行者未执行，获取下一个场景的执行者</span></span><br><span class="line">      stage = getNextStage(stage);</span><br><span class="line">      currentGenerator = getNextGenerator();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class="line">        reschedule();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We've run out of stages and generators, give up.</span></span><br><span class="line">    <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">      notifyFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecodeJob 任务执行时, 它根据不同的场景, 获取不同的场景执行器, 然后调用了它们的 startNext 方法加载请求任务的数据。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>场景描述</th>
<th>场景执行者</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stage.RESOURCE_CACHE</td>
<td>从磁盘中获取转换后的图片缓存</td>
<td>ResourceCacheGenerator</td>
</tr>
<tr>
<td>Stage.DATA_CACHE</td>
<td>从磁盘中获取原图片缓存数据</td>
<td>DataCacheGenerator</td>
</tr>
<tr>
<td>Stage.SOURCE</td>
<td>图片源请求数据</td>
<td>SourceGenerator</td>
</tr>
</tbody>
</table>
<p>总的来说，Glide在加载图片的时候，会首先从内存缓存获取，如果内存缓存不存在，则会在磁盘缓存中查找，否则从源地址进行加载。</p>
<h2 id="Glide缓存"><a href="#Glide缓存" class="headerlink" title="Glide缓存"></a>Glide缓存</h2><p>简单来说分为 活动缓存（弱引用activeResources），内存缓存（LruResourceCache），资源缓存，数据缓存</p>
<h3 id="活动缓存和内存缓存"><a href="#活动缓存和内存缓存" class="headerlink" title="活动缓存和内存缓存"></a>活动缓存和内存缓存</h3><p>默认情况下，Glide自动就是开启内存缓存的。也就是说，当我们使用Glide加载了一张图片之后，这张图片就会被缓存到内存当中，只要在它还没从内存中被清除之前，下次使用Glide再加载这张图片都会直接从内存当中读取，而不用重新从网络或硬盘上读取了，这样无疑就可以大幅度提升图片的加载效率。比方说你在一个RecyclerView当中反复上下滑动，RecyclerView中只要是Glide加载过的图片都可以直接从内存当中迅速读取并展示出来，从而大大提升了用户体验。不过可以通过这种方式禁掉默认缓存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .skipMemoryCache(true)</span><br><span class="line">     .into(imageView);</span><br><span class="line">//skipMemoryCache传true就可以啦</span><br></pre></td></tr></table></figure></p>
<p>那么看一看原理：<br>load()方法中，我们当时分析到了在loadGeneric()方法中会调用Glide.buildStreamModelLoader()方法来获取一个ModelLoader对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, Y&gt; <span class="function">ModelLoader&lt;T, Y&gt; <span class="title">buildModelLoader</span><span class="params">(Class&lt;T&gt; modelClass, Class&lt;Y&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">           Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">               Log.d(TAG, <span class="string">"Unable to load null model, setting placeholder only"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Glide.get(context).getLoaderFactory().buildModelLoader(modelClass, resourceClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title">get</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">               <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   Context applicationContext = context.getApplicationContext();</span><br><span class="line">                   List&lt;GlideModule&gt; modules = <span class="keyword">new</span> ManifestParser(applicationContext).parse();</span><br><span class="line">                   GlideBuilder builder = <span class="keyword">new</span> GlideBuilder(applicationContext);</span><br><span class="line">                   <span class="keyword">for</span> (GlideModule <span class="keyword">module</span> : modules) &#123;</span><br><span class="line">                       <span class="keyword">module</span>.applyOptions(applicationContext, builder);</span><br><span class="line">                   &#125;</span><br><span class="line">                   glide = builder.createGlide();</span><br><span class="line">                   <span class="keyword">for</span> (GlideModule <span class="keyword">module</span> : modules) &#123;</span><br><span class="line">                       <span class="keyword">module</span>.registerComponents(applicationContext, glide);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> glide;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>跟createGlide（）方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Glide <span class="title">createGlide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (sourceService == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> cores = Math.max(<span class="number">1</span>, Runtime.getRuntime().availableProcessors());</span><br><span class="line">           sourceService = <span class="keyword">new</span> FifoPriorityThreadPoolExecutor(cores);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (diskCacheService == <span class="keyword">null</span>) &#123;</span><br><span class="line">           diskCacheService = <span class="keyword">new</span> FifoPriorityThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       MemorySizeCalculator calculator = <span class="keyword">new</span> MemorySizeCalculator(context);</span><br><span class="line">       <span class="keyword">if</span> (bitmapPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">               <span class="keyword">int</span> size = calculator.getBitmapPoolSize();</span><br><span class="line">               bitmapPool = <span class="keyword">new</span> LruBitmapPool(size);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               bitmapPool = <span class="keyword">new</span> BitmapPoolAdapter();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">           memoryCache = <span class="keyword">new</span> LruResourceCache(calculator.getMemoryCacheSize());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (diskCacheFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">           diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (engine == <span class="keyword">null</span>) &#123;</span><br><span class="line">           engine = <span class="keyword">new</span> Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (decodeFormat == <span class="keyword">null</span>) &#123;</span><br><span class="line">           decodeFormat = DecodeFormat.DEFAULT;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Glide(engine, memoryCache, bitmapPool, context, decodeFormat);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>而 memoryCache = new LruResourceCache(calculator.getMemoryCacheSize()); 就是Glide实现内存缓存所使用的LruCache对象了，有对象还不够，关键在于Engine类load()方法，在load()方法中Glide的图片加载过程中会调用两个方法来获取内存缓存，loadFromCache()和loadFromActiveResources()。这两个方法中一个使用的就是LruCache算法，另一个使用的就是弱引用。我们来看一下它们的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> <span class="keyword">implements</span> <span class="title">EngineJobListener</span>,</span></span><br><span class="line"><span class="class">        <span class="title">MemoryCache</span>.<span class="title">ResourceRemovedListener</span>,</span></span><br><span class="line"><span class="class">        <span class="title">EngineResource</span>.<span class="title">ResourceListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryCache cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class="keyword">boolean</span> isMemoryCacheable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">        <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cached.acquire();</span><br><span class="line">            activeResources.put(key, <span class="keyword">new</span> ResourceWeakReference(key, cached, getReferenceQueue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cached;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">        Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line">        <span class="keyword">final</span> EngineResource result;</span><br><span class="line">        <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">            result = (EngineResource) cached;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="keyword">new</span> EngineResource(cached, <span class="keyword">true</span> <span class="comment">/*isCacheable*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, <span class="keyword">boolean</span> isMemoryCacheable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EngineResource&lt;?&gt; active = <span class="keyword">null</span>;</span><br><span class="line">        WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key);</span><br><span class="line">        <span class="keyword">if</span> (activeRef != <span class="keyword">null</span>) &#123;</span><br><span class="line">            active = activeRef.get();</span><br><span class="line">            <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">                active.acquire();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                activeResources.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> active;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在loadFromCache()方法的一开始，首先就判断了isMemoryCacheable是不是false，如果是false的话就直接返回null，意思是刚刚的skipMemoryCache()方法，如果在这个方法中传入true，那么这里的isMemoryCacheable就会是false，表示内存缓存已被禁用。</p>
<p>我们继续住下看，接着调用了getEngineResourceFromCache()方法来获取缓存。在这个方法中，会使用缓存Key来从cache当中取值，而这里的cache对象就是在构建Glide对象时创建的LruResourceCache，那么说明这里其实使用的就是LruCache算法了。</p>
<p>但是，当我们从LruResourceCache中获取到缓存图片之后会将它从缓存中移除，然后将这个缓存图片存储到activeResources当中。activeResources就是一个弱引用的HashMap，用来缓存正在使用中的图片，我们可以看到，loadFromActiveResources()方法就是从activeResources这个HashMap当中取值的。使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。</p>
<p>概括一下来说，就是如果能从内存缓存当中读取到要加载的图片，那么就直接进行回调，如果读取不到的话，才会开启线程执行后面的图片加载逻辑。</p>
<h3 id="资源缓存，数据缓存"><a href="#资源缓存，数据缓存" class="headerlink" title="资源缓存，数据缓存"></a>资源缓存，数据缓存</h3><p>用法上，它也是可禁的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .diskCacheStrategy(DiskCacheStrategy.NONE)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure></p>
<p>调用diskCacheStrategy()方法并传入DiskCacheStrategy.NONE，就可以禁用掉Glide的硬盘缓存功能了。</p>
<p>这个diskCacheStrategy()方法基本上就是Glide硬盘缓存功能的一切，它可以接收四种参数：</p>
<p>DiskCacheStrategy.NONE： 表示不缓存任何内容。<br>DiskCacheStrategy.SOURCE： 表示只缓存原始图片。<br>DiskCacheStrategy.RESULT： 表示只缓存转换过后的图片（默认选项）。<br>DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。<br>上面四种参数的解释本身并没有什么难理解的地方，当我们使用Glide去加载一张图片的时候，Glide默认并不会将原始图片展示出来，而是会对图片进行压缩和转换（我们会在后面学习这方面的内容）。总之就是经过种种一系列操作之后得到的图片，就叫转换过后的图片。而Glide默认情况下在硬盘缓存的就是转换过后的图片，我们通过调用diskCacheStrategy()方法则可以改变这一默认行为。</p>
<p>接下来还是通过阅读源码来分析一下，Glide的硬盘缓存功能是如何实现的。<br>首先，和内存缓存类似，硬盘缓存的实现也是使用的LruCache算法，而且Google还提供了一个现成的工具类DiskLruCache<br>，Glide开启线程来加载图片后会执行EngineRunnable的run()方法，run()方法中又会调用一个decode()方法，那么我们重新再来看一下这个decode()方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Resource&lt;?&gt; decode() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDecodingFromCache()) &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeFromCache();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeFromSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里会分为两种情况，一种是调用decodeFromCache()方法从硬盘缓存当中读取图片，一种是调用decodeFromSource()来读取原始图片。默认情况下Glide会优先从缓存当中读取，只有缓存中不存在要读取的图片时，才会去读取原始图片。那么我们现在来看一下decodeFromCache()方法的源码，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Resource&lt;?&gt; decodeFromCache() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Resource&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = decodeJob.decodeResultFromCache();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"Exception decoding result from cache: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = decodeJob.decodeSourceFromCache();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里会先去调用DecodeJob的decodeResultFromCache()方法来获取缓存，如果获取不到，会再调用decodeSourceFromCache()方法获取缓存，这两个方法的区别其实就是DiskCacheStrategy.RESULT(压缩后的)和DiskCacheStrategy.SOURCE(原始的)<br>看一下这两个方法的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">decodeResultFromCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!diskCacheStrategy.cacheResult()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;T&gt; transformed = loadFromCache(resultKey);</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">decodeSourceFromCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!diskCacheStrategy.cacheSource()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line"></span><br><span class="line">    Resource&lt;T&gt; decoded = loadFromCache(resultKey.getOriginalKey());</span><br><span class="line">    <span class="keyword">return</span> transformEncodeAndTranscode(decoded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它们都是调用了loadFromCache()方法从缓存当中读取数据，如果是decodeResultFromCache()方法就直接将数据解码并返回，如果是decodeSourceFromCache()方法，还要调用一下transformEncodeAndTranscode()方法先将数据转换一下再解码并返回。<br>看一下loadFromCache()方法的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;T&gt; <span class="title">loadFromCache</span><span class="params">(Key key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File cacheFile = diskCacheProvider.getDiskCache().get(key);</span><br><span class="line">    <span class="keyword">if</span> (cacheFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Resource&lt;T&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            diskCacheProvider.getDiskCache().delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的逻辑非常简单，调用getDiskCache()方法获取到的就是Glide自己编写的DiskLruCache工具类的实例，然后调用它的get()方法并把缓存Key传入，就能得到硬盘缓存的文件了。如果文件为空就返回null，如果文件不为空则将它解码成Resource对象后返回即可。</p>
<h2 id="看源码之前不清楚的两个问题："><a href="#看源码之前不清楚的两个问题：" class="headerlink" title="看源码之前不清楚的两个问题："></a>看源码之前不清楚的两个问题：</h2><ul>
<li><p>1 Glide的方法能在子线程中使用吗？</p>
<blockquote>
<p>Glide的with()方法和load()方法是可以的，其中with()传入的context，若在非主线程，那么不管你是传入的Activity还是Fragment，都会被强制当成Application来处理，可能造成内存泄漏；而into()无法在主线程中使用，会抛出异常“You must call this method on the main thread”</p>
</blockquote>
</li>
<li><p>2 如何处理一个大图的缓存？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">true</span>;<span class="comment">//只读取图片，不加载到内存中</span></span><br><span class="line">        BitmapFactory.decodeFile(file, options);</span><br><span class="line">        options.inSampleSize=computeSampleSize(options, -<span class="number">1</span>, <span class="number">512</span>*<span class="number">512</span>);<span class="comment">//返回合适的inSampleSize值,inSampleSize是缩放参数，必须被二整除</span></span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">false</span>;<span class="comment">//加载到内存中</span></span><br><span class="line">        bitmap = BitmapFactory.decodeFile(file, options);</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/17/数据结构实用总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/17/数据结构实用总结/" itemprop="url">数据结构总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-17T00:00:00+08:00">
                2019-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/17/数据结构实用总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/10/17/数据结构实用总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>实际开发中很少实用数组了，最常见的就是ArrayList，所以从它说起</p>
<ul>
<li><p>1 首先它是基于动态数组的数据结构，和数组一样在物理上是连续的，初始化时大小为10，插入新元素时会判断是否需要扩容，扩容的步长为原大小的50%，扩容时需要复制原来数组，造成开销</p>
</li>
<li><p>2 优势是查找效率很高（因为物理上连续）时间复杂度为O(1)，而插入或者删除指定元素时却需要移动插入位置之后的所有元素，时间复杂度为O（n),而如果在最后面进行插入，那就不需要进行位移，时间复杂度为O(1)</p>
</li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>基于这种情况，于是有了LinkedList</p>
<ul>
<li>1 首先它内部使用基于链表的数据结构实现存储，所以它也具有链表的特点，每一个元素（结点）的地址不连续，通过引用找到当前结点的上一个结点和下一个结点，即插入和删除指定元素效率较高，而get和set则较为低效，时间复杂度为O(n)</li>
</ul>
<h2 id="ArrayList与LinkedList对比"><a href="#ArrayList与LinkedList对比" class="headerlink" title="ArrayList与LinkedList对比"></a>ArrayList与LinkedList对比</h2><p>ArrayList 是线性表（数组）<br>get() 直接读取第几个下标，复杂度 O(1)<br>add(E) 添加元素，直接在后面添加，复杂度O（1）<br>add(index, E)添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O（n）<br>remove（）删除元素，后面的元素需要逐个移动，复杂度O（n）</p>
<p>LinkedList 是链表的操作<br>get() 获取第几个元素，依次遍历，复杂度O(n)<br>add(E) 添加到末尾，复杂度O(1)<br>add(index, E) 添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n)<br>remove（）删除元素，直接指针指向操作，复杂度O(1)</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap可以接受null键值和值，而且是非synchronized的，以及HashMap储存的是键值对，使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法得到哈希值，再结合哈希值与HashMap的长度得到储存Entry对象的位置，而当我们new一个<br>HashMap对象时，没有指定长度的话默认长度是16，若指定了长度则会与指定长度最接近的2的整数次幂作为该对象的初始长度，当该对象的使用率达到0.75时，会发生扩容，扩容后长度依然必须是2的整数次幂。</p>
<p>关于上述内容有几个问题需要思考</p>
<h3 id="为什么HashMap的长度必须是2的整数次幂"><a href="#为什么HashMap的长度必须是2的整数次幂" class="headerlink" title="为什么HashMap的长度必须是2的整数次幂"></a>为什么HashMap的长度必须是2的整数次幂</h3><p>先来看一看HashMap是如何计算出储存每一个Entry对象的位置的</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8031371-0886d83c99bf0275.png?imageMogr2/auto-orient/strip|imageView2/2/w/986/format/webp" alt="图片"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Returns index for hash code h.</span><br><span class="line">    */</span><br><span class="line">   static int indexFor(int h, int length) &#123;</span><br><span class="line">       return h &amp; (length-1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>是对hashcode和(length-1)做与运算<br>此时若length为16或者其他2的幂,则length - 1的值是所有二进制位全为1，那么index的结果等同于hashcode后几位的值，只要输入的hashcode本身分布均匀,hash算法的结果就是均匀的，这样一来大大的降低了哈希碰撞的几率</p>
<h3 id="关于扩容"><a href="#关于扩容" class="headerlink" title="关于扩容"></a>关于扩容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threshold = (int)(capacity * loadFactor);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span><br><span class="line">            hash = (null != key) ? hash(key) : 0;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在put操作时，即向容器中添加元素时，判断当前容器中元素的个数是否达到阈值（当前数组长度乘以负载因子的值）的时候，就要自动扩容了，就是新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p>
<h4 id="扩容负载因子为什么是0-75"><a href="#扩容负载因子为什么是0-75" class="headerlink" title="扩容负载因子为什么是0.75"></a>扩容负载因子为什么是0.75</h4><ul>
<li>1 如果负载因子为0.5甚至更低的可能的话，最后得到的临时阈值明显会很小，这样的情况就会造成分配的内存的浪费，存在多余的没用的内存空间，也不满足了哈希表均匀分布的情况。</li>
<li>2 如果负载因子达到了1的情况，也就是Entry数组存满了才发生扩容，这样会出现大量的哈希冲突的情况，出现链表过长，因此造成get查询数据的效率。</li>
<li>3 因此选择了0.5~1的折中数也就是0.75，均衡解决了上面出现的情况,是一种平衡了时间空间开销的方法</li>
</ul>
<h3 id="HashMap的数据结构Java7和Java8及之后有所区别"><a href="#HashMap的数据结构Java7和Java8及之后有所区别" class="headerlink" title="HashMap的数据结构Java7和Java8及之后有所区别"></a>HashMap的数据结构Java7和Java8及之后有所区别</h3><p>Java7是数组+链表，当发生哈希冲突时以链表的形式存储，链表中存储格式是key-value键值对<br><img src="https://upload-images.jianshu.io/upload_images/8031371-44ed77820f471459.png?imageMogr2/auto-orient/strip|imageView2/2/w/883/format/webp" alt="图片"><br>Java8是数组+链表+红黑树，当发生哈希冲突时以链表的形式存储，当链表长度大于等于8时，以红黑树的形式存储<br><img src="https://upload-images.jianshu.io/upload_images/8031371-b057a459fa1cbccf.png?imageMogr2/auto-orient/strip|imageView2/2/w/1112/format/webp" alt="图片"></p>
<h4 id="为什么链表长度大于等于8时转为红黑树"><a href="#为什么链表长度大于等于8时转为红黑树" class="headerlink" title="为什么链表长度大于等于8时转为红黑树"></a>为什么链表长度大于等于8时转为红黑树</h4><p>这个8的设定很有讲究，是符合泊松分布概率统计学的，即经过概率分析认为超过8的概率很小，对泊松分布不太懂也没关系，在源码注释中有这么一段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* factorial(k)). The first values are:</span><br><span class="line">    *</span><br><span class="line">    * 0:    0.60653066</span><br><span class="line">    * 1:    0.30326533</span><br><span class="line">    * 2:    0.07581633</span><br><span class="line">    * 3:    0.01263606</span><br><span class="line">    * 4:    0.00157952</span><br><span class="line">    * 5:    0.00015795</span><br><span class="line">    * 6:    0.00001316</span><br><span class="line">    * 7:    0.00000094</span><br><span class="line">    * 8:    0.00000006</span><br><span class="line">    * more: less than 1 in ten million</span><br></pre></td></tr></table></figure></p>
<p>官方给的概率，可以说达到8就很难了，所以实际运用中存成红黑树的情况并不多</p>
<h3 id="HashMap为什么是线程不安全的"><a href="#HashMap为什么是线程不安全的" class="headerlink" title="HashMap为什么是线程不安全的"></a>HashMap为什么是线程不安全的</h3><ul>
<li>1 put的时候导致的多线程数据不一致<br>比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的 hash桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的 hash桶索引和线程B要插入的记录计算出来的 hash桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</li>
<li>2 resize而引起死循环<br>这种情况发生在HashMap自动扩容时，当2个线程同时检测到元素个数超过 数组大小 × 负载因子。此时2个线程会在put()方法中调用了resize()，两个线程同时修改一个链表结构会产生一个循环链表（JDK1.7中，会出现resize前后元素顺序倒置的情况）。接下来再想通过get()获取某一个元素，就会出现死循环。</li>
</ul>
<h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><ul>
<li>1 HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</li>
<li>2 HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</li>
<li>3 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li>
<li>4 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</li>
<li>5 HashMap不能保证随着时间的推移Map中的元素次序是不变的。</li>
</ul>
<h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h2><p>SparseArray构造方法中，创建了两个数组mKeys、mValues分别存放int与Object，其默认长度为10。<br>本质上就是两个数组</p>
<p>来看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 构造方法</span><br><span class="line">public SparseArray() &#123;</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构造方法</span><br><span class="line">public SparseArray(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity == 0) &#123;</span><br><span class="line">        mKeys = EmptyArray.INT;</span><br><span class="line">        mValues = EmptyArray.OBJECT;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // key value各自为一个数组，默认长度为10</span><br><span class="line">        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);</span><br><span class="line">        mKeys = new int[mValues.length];</span><br><span class="line">    &#125;</span><br><span class="line">    mSize = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结：</p>
<ul>
<li>1 SparseArray的key为int，value为Object</li>
<li>2 Android中，数据长度小于千时，用于替换HashMap,数据条数特别多的时候，效率会低于HashMap，因为它是基于二分查找去找数据的</li>
<li>3 占用内存空间小，没有额外的Entry对象</li>
</ul>
<h2 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h2><p>ArrayMap是一个键值对映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个磁盘记录键的哈希值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，区别是ArrayMap的key是哈希值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//构造方法</span><br><span class="line">public class ArrayMap&lt;K, V&gt; extends SimpleArrayMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;</span><br><span class="line">    MapCollections&lt;K, V&gt; mCollections;</span><br><span class="line"></span><br><span class="line">    public ArrayMap() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">//父类</span><br><span class="line"> int[] mHashes;</span><br><span class="line">    Object[] mArray;</span><br><span class="line">    public SimpleArrayMap() &#123;</span><br><span class="line">        mHashes = ContainerHelpers.EMPTY_INTS;</span><br><span class="line">        mArray = ContainerHelpers.EMPTY_OBJECTS;</span><br><span class="line">        mSize = 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>总结:<br>因为ArrayMap与SparseArray内部都使用了二分法进行从小到大的排序，所以当数据量很大的时候，效率至少降低一半，所以谷歌推荐数据量在千级以内时使用ArrayMap与SparseArray，数据量非常大时使用HashMap</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/16/view总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/16/view总结/" itemprop="url">View学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-16T00:00:00+08:00">
                2019-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/16/view总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/16/view总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景以及夙愿"><a href="#背景以及夙愿" class="headerlink" title="背景以及夙愿"></a>背景以及夙愿</h2><ul>
<li>1 写了一些自定义view的需求，希望有个总结，以供日后查阅</li>
<li>2 view不仅仅是自定义view，希望有个全面了解</li>
<li>3 养成研究源码的习惯</li>
</ul>
<h2 id="View概述"><a href="#View概述" class="headerlink" title="View概述"></a>View概述</h2><h3 id="官方文档的介绍"><a href="#官方文档的介绍" class="headerlink" title="官方文档的介绍"></a>官方文档的介绍</h3><p>View is the base class for widgets, which are used to create interactive UI components (buttons, text fields, etc.). The android.view.ViewGroup subclass is the base class for layouts, which are invisible containers that hold other Views (or other ViewGroups) and define their layout properties.<br>意思是说：View是窗口小部件的基类，用于创建交互式UI（Button,TextView等都是它的子类），而android.view.ViewGroup子类是布局的基类，它是包含其他视图（或其他ViewGroups）并定义其布局属性的不可见容器。<br>总结来说：我们看到的所有可视化UI组件都可以看做是View,下面从以下几个方面来了解它</p>
<h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><h3 id="srollTo和srollBy"><a href="#srollTo和srollBy" class="headerlink" title="srollTo和srollBy"></a>srollTo和srollBy</h3><h4 id="看看源码"><a href="#看看源码" class="headerlink" title="看看源码"></a>看看源码</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void scrollTo(int x, int y) &#123;</span><br><span class="line">    if (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        int oldX = mScrollX;</span><br><span class="line">        int oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        if (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Move the scrolled position of your view. This will cause a call to</span><br><span class="line"> * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be</span><br><span class="line"> * invalidated.</span><br><span class="line"> * @param x the amount of pixels to scroll by horizontally</span><br><span class="line"> * @param y the amount of pixels to scroll by vertically</span><br><span class="line"> */</span><br><span class="line">public void scrollBy(int x, int y) &#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><p> srollTo()方法：在当前视图内容偏移至(x , y)坐标处，即显示(可视)区域位于(x , y)坐标处。<br> srollBy()方法：在当前视图内容继续偏移(x , y)个单位，显示(可视)区域也跟着偏移(x,y)个单位。<br> srollTo()和srollBy()移动得都是view的内容，view本身并未移动</p>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p> 下面写了一个demo验证一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br><span class="line">       bn_scrollTo = findViewById(R.id.bn_scrollTo);</span><br><span class="line">       bn_scrollBy = findViewById(R.id.bn_scrollBy);</span><br><span class="line">       text = findViewById(R.id.tv_text);</span><br><span class="line"></span><br><span class="line">       bn_scrollTo.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line">               v.scrollTo(50,50);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       bn_scrollBy.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line">               v.scrollBy(50,50);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行效果<br><img src="https://s2.ax1x.com/2019/07/16/ZbpygP.gif" alt="图片"></p>
<h3 id="通过动画实现"><a href="#通过动画实现" class="headerlink" title="通过动画实现"></a>通过动画实现</h3><h4 id="看例子"><a href="#看例子" class="headerlink" title="看例子"></a>看例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        bn_scrollTo = findViewById(R.id.bn_scrollTo);</span><br><span class="line">        bn_scrollBy = findViewById(R.id.bn_scrollBy);</span><br><span class="line">        text = findViewById(R.id.tv_text);</span><br><span class="line"></span><br><span class="line">        bn_scrollTo.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                //v.scrollTo(50,50);</span><br><span class="line">                ObjectAnimator.ofFloat(bn_scrollTo,&quot;translationX&quot;,0,200,0,0).setDuration(1000).start();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bn_scrollBy.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                //v.scrollBy(50,50);</span><br><span class="line">                ObjectAnimator.ofFloat(bn_scrollBy,&quot;translationX&quot;,0,-200,0,0).setDuration(1000).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果<br><img src="https://s2.ax1x.com/2019/07/16/ZbZOQH.gif" alt="图片"></p>
<h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>这里使用了属性动画ObjectAnimator来实现滑动，个人理解动画并不属于滑动，只是实现了类似滑动的效果，我们可以通过调整动画持续时间setDuration()来做出具有弹性的滑动效果，这里不再多说，关于ObjectAnimator的其他方法可以<a href="https://blog.csdn.net/harvic880925/article/details/50598322" target="_blank" rel="noopener">参考</a></p>
<h3 id="改变LayoutParams"><a href="#改变LayoutParams" class="headerlink" title="改变LayoutParams"></a>改变LayoutParams</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) text.getLayoutParams();</span><br><span class="line">     params.width += 100;</span><br><span class="line">     params.leftMargin += 100;</span><br><span class="line">     text.requestLayout();</span><br></pre></td></tr></table></figure>
<h3 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h3><p>先来看看官方给出的使用样例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private Scroller mScroller = new Scroller(context);</span><br><span class="line">  ...</span><br><span class="line">  public void zoomIn() &#123;</span><br><span class="line">      // Revert any animation currently in progress</span><br><span class="line">      mScroller.forceFinished(true);</span><br><span class="line">      // Start scrolling by providing a starting point and</span><br><span class="line">      // the distance to travel</span><br><span class="line">      mScroller.startScroll(0, 0, 100, 0);</span><br><span class="line">      // Invalidate to request a redraw</span><br><span class="line">      invalidate();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用起来非常简单，我们一个一个方法往下分析<br>先来看看startScroll()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123;</span><br><span class="line">      mMode = SCROLL_MODE;</span><br><span class="line">      mFinished = false;</span><br><span class="line">      mDuration = duration;</span><br><span class="line">      mStartTime = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">      mStartX = startX;</span><br><span class="line">      mStartY = startY;</span><br><span class="line">      mFinalX = startX + dx;</span><br><span class="line">      mFinalY = startY + dy;</span><br><span class="line">      mDeltaX = dx;</span><br><span class="line">      mDeltaY = dy;</span><br><span class="line">      mDurationReciprocal = 1.0f / (float) mDuration;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>startScroll()方法中保存了滑动起点，滑动距离，滑动时间等等这种参数，但是未见具体滑动代码，真正使view产生滑动效果的是invalidate()<br>invalidate()方法会导致view重绘，draw方法中调用computeScroll(),computeScroll()是一个空方法需要自己重写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void computeScroll() &#123;</span><br><span class="line">     if (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">         scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">         invalidate();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>向Scroller获取scrollX，scrollY,通过scrollTo()进行滑动，然后再调用invalidate(),重复上述步骤，循环调用直到滑动结束，至于循环多少次呢，是由computeScrollOffset()决定的。<br>下面仅贴出关键代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Call this when you want to know the new location.  If it returns true,</span><br><span class="line">   * the animation is not yet finished.</span><br><span class="line">   */ </span><br><span class="line">  public boolean computeScrollOffset() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">      int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</span><br><span class="line">  </span><br><span class="line">      if (timePassed &lt; mDuration) &#123;</span><br><span class="line">          switch (mMode) &#123;</span><br><span class="line">          case SCROLL_MODE:</span><br><span class="line">              final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</span><br><span class="line">              mCurrX = mStartX + Math.round(x * mDeltaX);</span><br><span class="line">              mCurrY = mStartY + Math.round(x * mDeltaY);</span><br><span class="line">              break;</span><br><span class="line">         ...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          mCurrX = mFinalX;</span><br><span class="line">          mCurrY = mFinalY;</span><br><span class="line">          mFinished = true;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到是通过当前时间和滑动开始时间的差值所占滑动时间的份数来计算的，返回false则滑动结束，否则继续循环。</p>
<h2 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h2><p>这一节更多的会提炼成文字，源码的分析过程涉及子view，父view各自的事件分发三件套方法，不太容易形成书面语言<br>1、一个view的事件最先传递给它所在的activity的decorview,decorview是当前页面的顶层容器，我们setContentView(R.layout.xxx)设置的view就是decorview的子view<br>2、然后首先调用顶级View的dispathTouchEvent(),在这个方法中通过onInterceptTouchEvent()来判断是否拦截，如果返回true则由顶级view处理，如果返回false则需要判断是否设置了mOnTouchListener,是则调用onTouch(),否则调用onTouchEvent()<br>3、子view继续重复1，2步骤分发</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/19/kotlin总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/kotlin总结/" itemprop="url">Kotlin开发学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-19T00:00:00+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/19/kotlin总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/11/19/kotlin总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="本篇文章的背景以及夙愿"><a href="#本篇文章的背景以及夙愿" class="headerlink" title="本篇文章的背景以及夙愿"></a>本篇文章的背景以及夙愿</h2><ul>
<li>1 增强kotlin开发水平</li>
<li>2 保持更博客的习惯</li>
</ul>
<h2 id="为什么要学习kotlin"><a href="#为什么要学习kotlin" class="headerlink" title="为什么要学习kotlin"></a>为什么要学习kotlin</h2><p>（因为本人是Android开发，所以仅从Android角度来说）</p>
<ul>
<li>1 简介：<br>大型项目迭代过程中，阅读代码+写新需求是必不可少的，不论是同事的代码还是自己的代码，因此代码的简洁程度就成了提升生产力的关键</li>
<li>2 安全可靠：<br>kotlin的设计是可以防止程序因为某些错误挂掉的，举一个例子：空安全，简而言之就是kotlin帮助我们避开空指针异常这类错误，节省后期找错误一步一步debug的时间，这个后面详细说</li>
<li>3 互操作性：<br>和Java无缝连接，几乎可以使用所有Java库</li>
</ul>
<h2 id="个人体验kotlin与Java不同之处"><a href="#个人体验kotlin与Java不同之处" class="headerlink" title="个人体验kotlin与Java不同之处"></a>个人体验kotlin与Java不同之处</h2><p>（val,var常量变量声明，fun声明方法等等请自行百度，此处仅记录用惯了Java原生开发改用kotlin导致不舒服的地方）</p>
<h3 id="when关键字的使用"><a href="#when关键字的使用" class="headerlink" title="when关键字的使用"></a>when关键字的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">when (status) &#123;</span><br><span class="line">STATUS_CAR_GOOD -&gt; &#123;</span><br><span class="line">selectedView(tv_car_status_good, iv_car_status_good)</span><br><span class="line">curCarStatus = getData()?.priceResultKey?.high</span><br><span class="line">&#125;</span><br><span class="line">STATUS_CAR_COMM -&gt; &#123;</span><br><span class="line">selectedView(tv_car_status_common, iv_car_status_common)</span><br><span class="line">curCarStatus = getData()?.priceResultKey?.middle</span><br><span class="line">&#125;</span><br><span class="line">STATUS_CAR_DIFF -&gt; &#123;</span><br><span class="line">selectedView(tv_car_status_diff, iv_car_status_diff)</span><br><span class="line">curCarStatus = getData()?.priceResultKey?.low</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for循环的变形使用"><a href="#for循环的变形使用" class="headerlink" title="for循环的变形使用"></a>for循环的变形使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (itemData in golds) &#123;</span><br><span class="line">num ++</span><br><span class="line">if (num &gt; 3) &#123;</span><br><span class="line">return</span><br><span class="line"> &#125;</span><br><span class="line"> val itemCtrl = AppraiserItemCtrl(mContext, golds)</span><br><span class="line"> val itemView = itemCtrl.createView(ll_appraiser_list)</span><br><span class="line"> itemView.layoutParams = mLayoutParams</span><br><span class="line"> ll_appraiser_list.addView(itemView)</span><br><span class="line"> itemCtrl.setData(itemData)</span><br><span class="line"> itemCtrl.bindView()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i in 1..100)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意kotlin的区间是闭合的，第二个值始终是区间的一部分</p>
<h3 id="object关键字在声明单例，接口时的使用"><a href="#object关键字在声明单例，接口时的使用" class="headerlink" title="object关键字在声明单例，接口时的使用"></a>object关键字在声明单例，接口时的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mContentListRecyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() &#123;</span><br><span class="line">override fun onScrollStateChanged(recyclerView: RecyclerView?, newState: Int) &#123;</span><br><span class="line">super.onScrollStateChanged(recyclerView, newState)</span><br><span class="line">if (recyclerView == null) &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">when (newState) &#123;</span><br><span class="line">RecyclerView.SCROLL_STATE_IDLE -&gt; &#123;</span><br><span class="line">if (!recyclerView.canScrollVertically(-1)) &#123;</span><br><span class="line">appbar.setExpanded(true, true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">RecyclerView.SCROLL_STATE_DRAGGING -&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">RecyclerView.SCROLL_STATE_SETTLING -&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="伴生对象代替static"><a href="#伴生对象代替static" class="headerlink" title="伴生对象代替static"></a>伴生对象代替static</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">companion object &#123;</span><br><span class="line">const val TYPE_AROUND = 0</span><br><span class="line">const val TYPE_REFERENCE = 1</span><br><span class="line">const val TYPE_RECOM_CAR = 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>companion object修饰的对象或方法，等同于静态对象或方法</p>
<h3 id="创建单例"><a href="#创建单例" class="headerlink" title="创建单例"></a>创建单例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object Resource &#123;</span><br><span class="line">    val name = &quot;Name&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="压缩代码方面"><a href="#压缩代码方面" class="headerlink" title="压缩代码方面"></a>压缩代码方面</h3><ul>
<li>1 findviewbyid<br>kotlin是不需要写findviewbyid的，可直接指向id</li>
<li>2 with和apply</li>
</ul>
<h3 id="可空性"><a href="#可空性" class="headerlink" title="可空性"></a>可空性</h3><ul>
<li>1 ?.<br>可空修饰符<br>对有可能为空的变量用该修饰符修饰可以避免空指针异常，被？修饰的变量只会调用非空值的方法，若为空会返回null</li>
<li><p>2 ?:<br>kotlin中没有像Java中的三元判断，但个人感觉这个很像，一定程度上可以替代，详见代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun strLenSafe(s:String):Int = s?.length ?: 0 </span><br><span class="line">&gt;&gt;&gt;println(strLenSafe(&quot;abc&quot;))</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt;println(strLenSafe(null))</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 let<br>.let{ }是不为空的时候执行,否则什么都不会发生</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val data = ...</span><br><span class="line"></span><br><span class="line">data?.let &#123;</span><br><span class="line">    ... // 如果不为空，请执行此块操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4 lateinit<br>在Kotlin中，声明为具有非空类型的属性必须在构造函数中初始化，但是往往不希望在构造函数中初始化，例如在通过依赖注入或单元测试的设置方法来初始化属性的时候，不能在构造器中提供一个非空的初始化语句，为了处理这种情况，就要在属性上加lateinit关键字来延迟初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class BuyAndSellAppraiseCtrl(context: Context) : Ctrl&lt;GAppraiseResultResponse&gt;(context) &#123;</span><br><span class="line">    private lateinit var tv_car_status_top_msg: TextView</span><br><span class="line">    private lateinit var tv_ge_ren_che: TextView</span><br><span class="line">    private lateinit var tv_ge_ren_che_value: TextView</span><br><span class="line">    private lateinit var tv_ge_ren_che_area1: TextView</span><br><span class="line">    private lateinit var tv_che_shang_che: TextView</span><br><span class="line">    private lateinit var tv_che_shang_che_value: TextView</span><br><span class="line">    private lateinit var tv_che_shang_che_area1: TextView</span><br><span class="line">    private lateinit var tv_che_shang_shou_che: TextView</span><br><span class="line">    private lateinit var tv_che_shang_shou_che_value: TextView</span><br><span class="line">    private lateinit var tv_che_shang_shou_che_area1: TextView</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>lateinit只能够在var类型的属性中，不能用于构造函数，而且属性不能有自定义的getter和setting，这些属性必须是非空类型，并且不能是基本类型。</p>
<ul>
<li>5 !!<br>不可空修饰符<br>个人认为使用场景不是很多，而且会带来很多问题，慎用<br>未完待续^_^</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/09/handler_sum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/09/handler_sum/" itemprop="url">handler学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-09T00:00:00+08:00">
                2018-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/09/handler_sum/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/09/09/handler_sum/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景以及夙愿"><a href="#背景以及夙愿" class="headerlink" title="背景以及夙愿"></a>背景以及夙愿</h2><ul>
<li>1 练习博客排版</li>
<li>2 尝试阅读源码，从熟悉的handler开始</li>
<li>3 习惯养成</li>
</ul>
<h2 id="handler是什么？"><a href="#handler是什么？" class="headerlink" title="handler是什么？"></a>handler是什么？</h2><p>Handler主要用于异步消息的处理： 有点类似辅助类，封装了消息投递、消息处理等接口。当发出一个消息之后，首先进入一个消息队列，发送消息的函数即刻返回，而另外一个部分在消息队列中逐一将消息取出，然后对消息进行处理，也就是发送消息和接收消息不是同步的处理。 这种机制通常用来处理相对耗时比较长的操作。</p>
<h2 id="handler使用场景"><a href="#handler使用场景" class="headerlink" title="handler使用场景"></a>handler使用场景</h2><p>在Android系统中出于性能优化考虑，Android的UI操作并不是线程安全的，这意味着如果有多个线程并发操作UI组件，可能导致线程安全问题。为了解决这个问题，Android制定了一条简单的原则，只允许UI线程（亦即主线程）修改Activity中的UI组件。但实际上，有部分UI需要在子线程中控制其修改逻辑，因此子线程需要通过handler通知主线程修改UI，实现线程间通信。</p>
<h2 id="handler的使用"><a href="#handler的使用" class="headerlink" title="handler的使用"></a>handler的使用</h2><h3 id="1-post或postDelayed"><a href="#1-post或postDelayed" class="headerlink" title="1 post或postDelayed"></a>1 post或postDelayed</h3><p>区别在于一个立即执行，一个延时执行<br>下面以延时操作为例</p>
<p>直接上代码举个小例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Handler().postDelayed(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        goHome();//可做UI操作等等</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 2000); // 延时2秒</span><br></pre></td></tr></table></figure></p>
<h3 id="2-sendMessage"><a href="#2-sendMessage" class="headerlink" title="2 sendMessage"></a>2 sendMessage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private TabLayout mTab;</span><br><span class="line">    private ViewPager mVp;</span><br><span class="line">    private ViewPagerAapter mvpAapter;</span><br><span class="line">    public ArrayList&lt;String&gt; mlist = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public ArrayList&lt;ImageView&gt; mlistIv = new ArrayList&lt;&gt;();</span><br><span class="line">    private ImageView v1, v2, v3;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mVp = findViewById(R.id.view1);</span><br><span class="line">        mTab = findViewById(R.id.tab);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line"></span><br><span class="line">        mlist.add(&quot;daxifu&quot;);</span><br><span class="line">        mlist.add(&quot;erxifu&quot;);</span><br><span class="line">        mlist.add(&quot;sanxifu&quot;);</span><br><span class="line"></span><br><span class="line">        //mTab.setTabMode(TabLayout.MODE_FIXED);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; mlist.size(); i++) &#123;</span><br><span class="line">            mTab.addTab(mTab.newTab().setText(mlist.get(i)));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        v1 = new ImageView(this);</span><br><span class="line">        v2 = new ImageView(this);</span><br><span class="line">        v3 = new ImageView(this);</span><br><span class="line"></span><br><span class="line">        v1.setImageResource(R.drawable.app_launch_01);</span><br><span class="line">        v2.setImageResource(R.drawable.app_launch_02);</span><br><span class="line">        v3.setImageResource(R.drawable.app_launch_03);</span><br><span class="line"></span><br><span class="line">//        v1.setScaleType(ImageView.ScaleType.FIT_XY);</span><br><span class="line">//        v2.setScaleType(ImageView.ScaleType.FIT_XY);</span><br><span class="line">//        v3.setScaleType(ImageView.ScaleType.FIT_XY);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mlistIv.add(v1);</span><br><span class="line">        mlistIv.add(v2);</span><br><span class="line">        mlistIv.add(v3);</span><br><span class="line"></span><br><span class="line">        mTab.setupWithViewPager(mVp);</span><br><span class="line"></span><br><span class="line">        mvpAapter = new ViewPagerAapter(mlist, mlistIv);</span><br><span class="line">        mVp.setAdapter(mvpAapter);</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line"></span><br><span class="line">                for (int i  = 1; i &lt; 4; i++)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(3000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Message message = new Message();</span><br><span class="line">                    message.what = i;</span><br><span class="line"></span><br><span class="line">                    mhandler.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    private Handler mhandler = new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    v1.setImageResource(R.drawable.app_fuli_01);</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    v2.setImageResource(R.drawable.app_fuli_02);</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">                case 3:</span><br><span class="line">                    v3.setImageResource(R.drawable.app_fuli_03);</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><img src="https://s1.ax1x.com/2018/09/15/iV8gAA.gif" alt="图片"></p>
<h3 id="handler的内存泄漏"><a href="#handler的内存泄漏" class="headerlink" title="handler的内存泄漏"></a>handler的内存泄漏</h3><p>上面的代码有没有发现一些问题或风险，没错就是内存泄漏</p>
<h4 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h4><p>Java使用有向图机制，通过GC自动检查内存中的对象（什么时候检查由虚拟机决定），如果GC发现一个或一组对象为不可到达状态，则将该对象从内存中回收。也就是说，一个对象不被任何引用所指向，则该对象会在被GC发现的时候被回收；另外，如果一组对象中只包含互相的引用，而没有来自它们外部的引用（例如有两个对象A和B互相持有引用，但没有任何外部对象持有指向A或B的引用），这仍然属于不可到达，同样会被GC回收。而一旦GC因为某些对象持有外部引用而无法回收资源时就会发生内存泄露，这部分内存即没有被使用又无法被回收，积少成多就会造成oom，以现在的手机性能造成oom的情况极少，但内存泄露处理仍是android代码质量高低的重要标准之一</p>
<h4 id="为什么handler会造成内存泄露"><a href="#为什么handler会造成内存泄露" class="headerlink" title="为什么handler会造成内存泄露"></a>为什么handler会造成内存泄露</h4><p>当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用（不然你怎么可能通过Handler来操作Activity中的View？）。而Handler通常会伴随着一个耗时的后台线程（例如从网络拉取图片）一起出现，这个后台线程在任务执行完毕（例如图片下载完毕）之后，通过消息机制通知Handler，然后Handler把图片更新到界面。然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用（不然它怎么发消息给Handler？），这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束（例如图片下载完毕）。另外，如果你执行了Handler的postDelayed()方法，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，那么在你设定的delay到达之前，会有一条MessageQueue -&gt; Message -&gt; Handler -&gt; Activity的链，导致你的Activity被持有引用而无法被回收。</p>
<h4 id="如何来处理handler内存泄露"><a href="#如何来处理handler内存泄露" class="headerlink" title="如何来处理handler内存泄露"></a>如何来处理handler内存泄露</h4><p>目前方式有如下几种</p>
<h5 id="方法一：通过程序逻辑来进行保护。"><a href="#方法一：通过程序逻辑来进行保护。" class="headerlink" title="方法一：通过程序逻辑来进行保护。"></a>方法一：通过程序逻辑来进行保护。</h5><p>1.在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。</p>
<p>2.如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。</p>
<h5 id="方法二：将Handler声明为静态类和加入弱引用"><a href="#方法二：将Handler声明为静态类和加入弱引用" class="headerlink" title="方法二：将Handler声明为静态类和加入弱引用"></a>方法二：将Handler声明为静态类和加入弱引用</h5><p>有很多文章说设为静态类就可以了，但是实际操作事会发现，由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）：</p>
<h6 id="小扩展：什么是弱引用？"><a href="#小扩展：什么是弱引用？" class="headerlink" title="小扩展：什么是弱引用？"></a>小扩展：什么是弱引用？</h6><p>WeakReference弱引用，与强引用（即我们常说的引用）相对，它的特点是，GC在回收时会忽略掉弱引用，即就算有弱引用指向某对象，但只要该对象没有被强引用指向（实际上多数时候还要求没有软引用，但此处软引用的概念可以忽略），该对象就会在被GC检查到时回收掉。对于上面的代码，用户在关闭Activity之后，就算后台线程还没结束，但由于仅有一条来自Handler的弱引用指向Activity，所以GC仍然会在检查的时候把Activity回收掉。这样，内存泄露的问题就不会出现了。</p>
<h6 id="上面的杨幂demo修正版本："><a href="#上面的杨幂demo修正版本：" class="headerlink" title="上面的杨幂demo修正版本："></a>上面的杨幂demo修正版本：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">//仅给出部分代码，主要看handler的变动</span><br><span class="line">  @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line">        final MyHandler myHandler = new MyHandler(this);</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line"></span><br><span class="line">                for (int i  = 1; i &lt; 4; i++)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(3000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Message message = new Message();</span><br><span class="line">                    message.what = i;</span><br><span class="line"></span><br><span class="line">                    myHandler.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   class MyHandler extends Handler&#123;</span><br><span class="line"></span><br><span class="line">        WeakReference&lt;SwipeViewPager&gt; mWeak;</span><br><span class="line"></span><br><span class="line">        public MyHandler(SwipeViewPager swipeViewPager) &#123;</span><br><span class="line">            mWeak = new WeakReference&lt;SwipeViewPager&gt;(swipeViewPager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">            SwipeViewPager swipeViewPager = (SwipeViewPager) mWeak.get();</span><br><span class="line"></span><br><span class="line">            if (swipeViewPager != null) &#123;</span><br><span class="line">                switch (msg.what) &#123;</span><br><span class="line">                    case AUTO_SCORLL:</span><br><span class="line">                        if (isStart) &#123;</span><br><span class="line">                            if (vpAd.getChildCount() &gt; 1) &#123;</span><br><span class="line">                                vpAd.setCurrentItem(vpAd.getCurrentItem() + 1, true);</span><br><span class="line">                            &#125;</span><br><span class="line">                            mHandler.sendEmptyMessageDelayed(AUTO_SCORLL, 5000);</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="handler源码分析"><a href="#handler源码分析" class="headerlink" title="handler源码分析"></a>handler源码分析</h2><h3 id="handler机制概括"><a href="#handler机制概括" class="headerlink" title="handler机制概括"></a>handler机制概括</h3><p>首先用一张图来概括handler以及它的四大“组件”的工作过程</p>
<p><img src="https://s1.ax1x.com/2018/09/27/iMbeEj.png" alt="图片"><br> handler具有两个功能，1.发送消息 2.处理消息<br> handler将消息发送到消息队列，由looper通过轮询从消息队列中将消息取出并派发(通过dispatchMessage()方法)给相应的hanndler，再通过重写handleMessage()方法处理。</p>
<h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>找到构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">        this(null, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> this跟进去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">       if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">           final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">           if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                   (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">               Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                   klass.getCanonicalName());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mLooper = Looper.myLooper(); //指定了looper对象</span><br><span class="line">       if (mLooper == null) &#123;</span><br><span class="line">           //如果是在子线程中，没有首先调用Looper.prepare()的话就会抛出该异常，具体原因稍后分析looper时再分析</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">               &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       mQueue = mLooper.mQueue;   //绑定消息队列</span><br><span class="line">       mCallback = callback;</span><br><span class="line">       mAsynchronous = async;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到主要做了两件事</p>
<ul>
<li>1 指定了looper对象</li>
<li>2 绑定消息队列<br>那么问题来了，我们需要看一下looper的源码，本菜鸡看的时候着实被吓一跳，没有头绪苦思冥想一番想到看一眼官方文档是怎么介绍它的，以下是官网给的使用范例</li>
</ul>
<h3 id="looper"><a href="#looper" class="headerlink" title="looper"></a>looper</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LooperThread extends Thread &#123;</span><br><span class="line">    public Handler mHandler;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line"></span><br><span class="line">        mHandler = new Handler() &#123;</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                // process incoming messages here</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到调用顺序</p>
<ul>
<li>1 Looper.prepare()</li>
<li>2 Looper.loop()<br>以下分别贴出源码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void prepare() &#123;</span><br><span class="line">     prepare(true);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">     if (sThreadLocal.get() != null) &#123; //看这里</span><br><span class="line">         //ThreadLocal相当于一个容器，是线程内部的数据存储类，通过它可以在指定线程中存储数据，</span><br><span class="line">         只有在指定线程中才能获取到存储的数据，对于其他线程是无法获取到的，通过对sThreadLocal.get()的判空，保证了一个线程只能set一个looper</span><br><span class="line">         throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>sThreadLocal若为null则new一个looper对象，若不为null抛出异常。<br>说明</p>
<ul>
<li>1 Looper.prepare()只能调用一次</li>
<li>2 一个线程中仅有一个looper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123; </span><br><span class="line"></span><br><span class="line">      final Looper me = myLooper();</span><br><span class="line">      if (me == null) &#123;</span><br><span class="line">          throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //获取looper实例中的消息队列</span><br><span class="line">      final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">      // Make sure the identity of this thread is that of the local process,</span><br><span class="line">      // and keep track of what that identity token actually is.</span><br><span class="line">      Binder.clearCallingIdentity();</span><br><span class="line">      final long ident = Binder.clearCallingIdentity();</span><br><span class="line">      //无限遍历</span><br><span class="line">      for (;;) &#123; </span><br><span class="line">          //从消息队列中取出消息</span><br><span class="line">          Message msg = queue.next(); // might block</span><br><span class="line">          if (msg == null) &#123;</span><br><span class="line">              // No message indicates that the message queue is quitting.（若取出消息为null则线程阻塞 --翻译一下怕后期自己看不懂）</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">          final Printer logging = me.mLogging;</span><br><span class="line">          if (logging != null) &#123;</span><br><span class="line">              logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                      msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">          final long traceTag = me.mTraceTag;</span><br><span class="line">          if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">              Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">          &#125;</span><br><span class="line">          final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">          final long end;</span><br><span class="line">          try &#123;</span><br><span class="line">              //把消息分发给hangler，稍后分析源码</span><br><span class="line">              msg.target.dispatchMessage(msg);</span><br><span class="line">              end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              if (traceTag != 0) &#123;</span><br><span class="line">                  Trace.traceEnd(traceTag);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (slowDispatchThresholdMs &gt; 0) &#123;</span><br><span class="line">              final long time = end - start;</span><br><span class="line">              if (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                  Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;</span><br><span class="line">                          + Thread.currentThread().getName() + &quot;, h=&quot; +</span><br><span class="line">                          msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (logging != null) &#123;</span><br><span class="line">              logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Make sure that during the course of dispatching the</span><br><span class="line">          // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">          final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">          if (ident != newIdent) &#123;</span><br><span class="line">              Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                      + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                      + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                      + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                      + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">          &#125;</span><br><span class="line">          //释放</span><br><span class="line">          msg.recycleUnchecked();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="曾经的疑问之一：用handler用了好多次，哪次也没写looper-prepare-和looper-loop-也跑的好好的。"><a href="#曾经的疑问之一：用handler用了好多次，哪次也没写looper-prepare-和looper-loop-也跑的好好的。" class="headerlink" title="曾经的疑问之一：用handler用了好多次，哪次也没写looper.prepare()和looper.loop()也跑的好好的。"></a>曾经的疑问之一：用handler用了好多次，哪次也没写looper.prepare()和looper.loop()也跑的好好的。</h4><p>读完源码发现，早在UI线程创建之初，就绑定了一个looper，凡是在主线程中显示什么什么，都不需要我们自己初始化looper，默认使用主线程的looper，那么代码中是什么时候创建主线程的looper的呢，再上一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//在Android应用进程启动时，会默认创建1个主线程</span><br><span class="line">// 创建时，会自动调用ActivityThread的1个静态的main（）方法 = 应用程序的入口</span><br><span class="line">// main（）内则会调用Looper.prepareMainLooper()为主线程生成1个Looper对象</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">        // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">        // disable it here, but selectively enable it later (via</span><br><span class="line">        // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">        CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        // Set the reporter for event logging in libcore</span><br><span class="line">        EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">        // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // End of event ActivityThreadMain.</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="dispatchMessage-msg-分析"><a href="#dispatchMessage-msg-分析" class="headerlink" title="dispatchMessage(msg)分析"></a>dispatchMessage(msg)分析</h3><p>下面我们看dispatchMessage(msg)是如何把消息分发给handler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Handle system messages here.</span><br><span class="line">    */</span><br><span class="line">   public void dispatchMessage(Message msg) &#123;</span><br><span class="line">       if (msg.callback != null) &#123;</span><br><span class="line">           handleCallback(msg); </span><br><span class="line"></span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (mCallback != null) &#123;</span><br><span class="line">               if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //若msg.callback属性为空，则代表使用了sendMessage</span><br><span class="line">           handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>1 检查message的callback是否为null，不为空就交给handleCallback(msg)来处理消息，<br>message的callback是一个runnable对象，实际就是handler.post()所传递的runnable参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static void handleCallback(Message message) &#123;</span><br><span class="line">       message.callback.run();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 检查mCallback是否为空，不为空就调用mCallback.handleMessage(msg)来处理消息，Callback是一个接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Callback interface you can use when instantiating a Handler to avoid</span><br><span class="line">  * having to implement your own subclass of Handler.</span><br><span class="line">  *</span><br><span class="line">  * @param msg A &#123;@link android.os.Message Message&#125; object</span><br><span class="line">  * @return True if no further handling is desired</span><br><span class="line">  */</span><br><span class="line"> public interface Callback &#123;</span><br><span class="line">     public boolean handleMessage(Message msg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 通过callback可以使用Handler mhandler = new Handler(Callback)来创建handler对象，那么callback是什么呢？<br> 上文注释里给出了说明：当不想派生handler的子类时可以使用callback创建handler对象，下面是本例使用callback创建的代码（本人不建议使用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity implements Callback&#123;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  中间代码</span><br><span class="line">   </span><br><span class="line">  */</span><br><span class="line">  @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">      super.onResume();</span><br><span class="line">      final Handler mhandler = new Handler(this);</span><br><span class="line">      new Thread()&#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              super.run();</span><br><span class="line"></span><br><span class="line">              for (int i  = 1; i &lt; 4; i++)&#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      Thread.sleep(3000);</span><br><span class="line">                  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                  Message message = new Message();</span><br><span class="line">                  message.what = i;</span><br><span class="line">                  mhandler.sendMessage(message);</span><br><span class="line">               &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">    @Override</span><br><span class="line">     public boolean handleMessage(Message msg) &#123;</span><br><span class="line">      switch (msg.what) &#123;</span><br><span class="line">          case 1:</span><br><span class="line">              v1.setImageResource(R.drawable.app_fuli_01);</span><br><span class="line"></span><br><span class="line">              break;</span><br><span class="line">          case 2:</span><br><span class="line">              v2.setImageResource(R.drawable.app_fuli_02);</span><br><span class="line"></span><br><span class="line">              break;</span><br><span class="line">          case 3:</span><br><span class="line">              v3.setImageResource(R.drawable.app_fuli_03);</span><br><span class="line"></span><br><span class="line">              break;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 最后通过handleMessage来处理消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Subclasses must implement this to receive messages.</span><br><span class="line">  */</span><br><span class="line"> public void handleMessage(Message msg) &#123;</span><br><span class="line">     //这是一个空方法，需要我们自己在代码业务中重写</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="MessageQueen"><a href="#MessageQueen" class="headerlink" title="MessageQueen"></a>MessageQueen</h3><p>我们一直称呼它为消息队列，但实际它是一个单链表结构，在handler机制中我们设计MessageQueen的两个方法，取出和插入</p>
<h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">        // Return here if the message loop has already quit and been disposed.</span><br><span class="line">        // This can happen if the application tries to restart a looper after quit</span><br><span class="line">        // which is not supported.</span><br><span class="line">        final long ptr = mPtr;</span><br><span class="line">        if (ptr == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">        int nextPollTimeoutMillis = 0;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                // Try to retrieve the next message.  Return if found.</span><br><span class="line">                final long now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = null;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                    // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                    do &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                if (msg != null) &#123;</span><br><span class="line">                    if (now &lt; msg.when) &#123;</span><br><span class="line">                        // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // Got a message.</span><br><span class="line">                        mBlocked = false;</span><br><span class="line">                        if (prevMsg != null) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = null;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        return msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // No more messages.</span><br><span class="line">                    nextPollTimeoutMillis = -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Process the quit message now that all pending messages have been handled.</span><br><span class="line">                if (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // If first time idle, then get the number of idlers to run.</span><br><span class="line">                // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">                // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">                if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                    // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                    mBlocked = true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Run the idle handlers.</span><br><span class="line">            // We only ever reach this code block during the first iteration.</span><br><span class="line">            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">                boolean keep = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!keep) &#123;</span><br><span class="line">                    synchronized (this) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">            pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">            // While calling an idle handler, a new message could have been delivered</span><br><span class="line">            // so go back and look again for a pending message without waiting.</span><br><span class="line">            nextPollTimeoutMillis = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>简单的说，这个函数就是从从头Head取出下一个Message，如果队列中没有message了，那么则可以取处理IdleHandler接口。当队列中没有消息或者消息指定了等待时间，那么线程会进入等待状态。<br>函数中有两个变量<br>int pendingIdleHandlerCount = -1;空闲的IdleHandler个数，只有在第一次迭代的时候为-1。<br>int nextPollTimeoutMillis = 0;下一轮等待时间，如果当前消息队列中没哟消息，需要等待的时间。<br>如果等待时间不为零，执行flush pending command，刷新等待时间。然后执行nativePollOnce(ptr, nextPollTimeoutMillis);其功能是查询消息队列中有没有消息。如果消息为空，那么nextPollTimeoutMillis=-1，接着等待消息，如果不为空，那么就处理这个消息。当我们设置的等待时间到了，将msg从Message中取出来并返回msg，如果没有返回，则说明没有消息需要处理，既然没有消息需要处理，检查以下是否要退出队列，如果退出返回null，否则那么就可以处理IdleHandler，处理完IdleHandler后将nextPollTimeoutMillis设为0（因为在处理IdleHandler的时候可能来消息），重新检测消息。</p>
<h4 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage()"></a>enqueueMessage()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">     if (msg.target == null) &#123;</span><br><span class="line">         throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     if (msg.isInUse()) &#123;</span><br><span class="line">         throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     synchronized (this) &#123;</span><br><span class="line">         if (mQuitting) &#123;</span><br><span class="line">             IllegalStateException e = new IllegalStateException(</span><br><span class="line">                     msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">             Log.w(TAG, e.getMessage(), e);</span><br><span class="line">             msg.recycle();</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         msg.markInUse();</span><br><span class="line">         msg.when = when;</span><br><span class="line">         Message p = mMessages;</span><br><span class="line">         boolean needWake;</span><br><span class="line"></span><br><span class="line">         //判断，如果mMessages对象为空，或者when为0也就是立刻执行，或者新消息的when时间比mMessages队列的when时间还要早</span><br><span class="line">         if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">             // New head, wake up the event queue if blocked.</span><br><span class="line">             //官方注释，当前消息作为新的队列头部，如果阻塞则唤醒</span><br><span class="line">             //就把新的msg插到mMessages的前面 并把next指向它，也就是队列的最前面，等待loop的轮询。</span><br><span class="line">             msg.next = p;</span><br><span class="line">             mMessages = msg;</span><br><span class="line">             needWake = mBlocked;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">             官方注释：插入队列中间。 通常我们不必醒来</span><br><span class="line">             // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">             // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">             needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">             Message prev;</span><br><span class="line">             //when是新消息的执行时间，p.when的是队列中message消息的执行时间，</span><br><span class="line">             如果找到比新的message还要晚执行的消息，</span><br><span class="line">             就执行msg.next = p;prev.next = msg;</span><br><span class="line">             也就是把插到该消息的前面，优先执行新的消息。</span><br><span class="line">             for (;;) &#123;</span><br><span class="line">                 prev = p;</span><br><span class="line">                 p = p.next;</span><br><span class="line">                 if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                     needWake = false;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             msg.next = p; // invariant: p == prev.next</span><br><span class="line">             prev.next = msg;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">         if (needWake) &#123;</span><br><span class="line">             nativeWake(mPtr);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.jpg"
                alt="Coding_dog" />
            
              <p class="site-author-name" itemprop="name">Coding_dog</p>
              <p class="site-description motion-element" itemprop="description">你愿意陪我一起菜鸡变凤凰吗</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Coding_dog</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'lKEXk4PjEE7zRpQT1zDMocSF-gzGzoHsz',
        appKey: 'oUy3OQ2TDAHq3mNInqu0U6eH',
        placeholder: '说两句',
        avatar:'wavatar',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
