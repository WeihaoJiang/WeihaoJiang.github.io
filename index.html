<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="你愿意陪我一起菜鸡变凤凰吗">
<meta property="og:type" content="website">
<meta property="og:title" content="Coding_dog的成长笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Coding_dog的成长笔记">
<meta property="og:description" content="你愿意陪我一起菜鸡变凤凰吗">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coding_dog的成长笔记">
<meta name="twitter:description" content="你愿意陪我一起菜鸡变凤凰吗">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Coding_dog的成长笔记</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding_dog的成长笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/Binder机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/Binder机制/" itemprop="url">Binder机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-28T00:00:00+08:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/28/Binder机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/28/Binder机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="本篇文章的背景以及夙愿"><a href="#本篇文章的背景以及夙愿" class="headerlink" title="本篇文章的背景以及夙愿"></a>本篇文章的背景以及夙愿</h2><ul>
<li>1 了解Binder机制，毕竟挺难的</li>
<li>2 陪媳妇儿加班中，待着也是待着</li>
</ul>
<h2 id="正文之前需要说得Binder"><a href="#正文之前需要说得Binder" class="headerlink" title="正文之前需要说得Binder"></a>正文之前需要说得Binder</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>一句话，Binder是一种进程间通信机制</p>
<h3 id="Android为什么选择Binder"><a href="#Android为什么选择Binder" class="headerlink" title="Android为什么选择Binder"></a>Android为什么选择Binder</h3><p>Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于性能、稳定性和安全性几方面的原因。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</p>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<h2 id="Linux-下传统的进程间通信原理"><a href="#Linux-下传统的进程间通信原理" class="headerlink" title="Linux 下传统的进程间通信原理"></a>Linux 下传统的进程间通信原理</h2><p><img src="https://s2.ax1x.com/2019/12/28/lmA4FP.png" alt="图片"></p>
<h3 id="涉及几个概念："><a href="#涉及几个概念：" class="headerlink" title="涉及几个概念："></a>涉及几个概念：</h3><ul>
<li><p>1 进程隔离<br>简单的说就是操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。</p>
</li>
<li><p>2 进程空间划分<br>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
</li>
<li><p>3 系统调用：用户态与内核态<br>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助系统调用来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
</li>
</ul>
<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。<br>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。<br>当进程在执行用户自己的代码的时候，我们称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。</p>
<h3 id="传统通信原理简述"><a href="#传统通信原理简述" class="headerlink" title="传统通信原理简述"></a>传统通信原理简述</h3><p>通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。<br>如下图：<br><img src="https://s2.ax1x.com/2019/12/28/lmEgpT.png" alt="图片"></p>
<h3 id="传统的-IPC-通信方式缺点"><a href="#传统的-IPC-通信方式缺点" class="headerlink" title="传统的 IPC 通信方式缺点"></a>传统的 IPC 通信方式缺点</h3><ul>
<li>1 性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>2 接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>
</ul>
<h2 id="Binder跨进程通信原理"><a href="#Binder跨进程通信原理" class="headerlink" title="Binder跨进程通信原理"></a>Binder跨进程通信原理</h2><h3 id="涉及几个概念：-1"><a href="#涉及几个概念：-1" class="headerlink" title="涉及几个概念："></a>涉及几个概念：</h3><ul>
<li>1 动态内核可加载模块<br>模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。</li>
<li>2 内存映射<br>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。<br>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</li>
</ul>
<h3 id="Binder-IPC-实现步骤："><a href="#Binder-IPC-实现步骤：" class="headerlink" title="Binder IPC 实现步骤："></a>Binder IPC 实现步骤：</h3><ul>
<li>1 首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>
<li>2 接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系；</li>
<li>3 发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。<br>如下图：<br><img src="https://s2.ax1x.com/2019/12/28/lmDiGt.png" alt="图片"></li>
</ul>
<h2 id="Binder通信过程"><a href="#Binder通信过程" class="headerlink" title="Binder通信过程"></a>Binder通信过程</h2><p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h3 id="互联网通信过程："><a href="#互联网通信过程：" class="headerlink" title="互联网通信过程："></a>互联网通信过程：</h3><p>包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。<br>如下图：<br><img src="https://s2.ax1x.com/2019/12/29/lus9jx.md.png" alt="图片"><br>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之间的关系。<br>通常我们访问一个网页的步骤是这样的：首先在浏览器输入一个地址，如 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 然后按下回车键。但是并没有办法通过域名地址直接找到我们要访问的服务器，因此需要首先访问 DNS 域名服务器，域名服务器中保存了 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 对应的 ip 地址 10.249.23.13，然后通过这个 ip 地址才能放到到 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 对应的服务器。<br><img src="https://s2.ax1x.com/2019/12/29/lus2x1.png" alt="图片"></p>
<h3 id="Binder通信过程："><a href="#Binder通信过程：" class="headerlink" title="Binder通信过程："></a>Binder通信过程：</h3><p>大致能总结出 Binder 通信过程：</p>
<ul>
<li>1 首先，一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>2 Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>3 Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。<br><img src="https://s2.ax1x.com/2019/12/29/luy3sx.png" alt="图片"></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/24/Glide源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/24/Glide源码分析/" itemprop="url">Glide源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-24T00:00:00+08:00">
                2019-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/24/Glide源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/10/24/Glide源码分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Glide加载流程？"><a href="#Glide加载流程？" class="headerlink" title="Glide加载流程？"></a>Glide加载流程？</h2><p>先看一眼Glide最简单的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this).load(url).into(imageView);</span><br></pre></td></tr></table></figure></p>
<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p>再看一眼整体架构图<br><img src="https://s2.ax1x.com/2019/10/28/KcUoKH.png" alt="图片"><br>我们也从这三个方面来分析</p>
<h3 id="with-方法"><a href="#with-方法" class="headerlink" title="with()方法"></a>with()方法</h3><p>首先with()方法的参数是什么？</p>
<ul>
<li>1 传递Activity，则此次加载图片会在退出Activity后自动取消；</li>
<li>2 传递Fragment，则加载图片会在Fragment销毁时取消；</li>
<li>3 传递Application，那么Glide将无法管理图片请求生命周期。<br>然后看with()方法的源码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">       RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">       <span class="keyword">return</span> retriever.get(context);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">       RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">       <span class="keyword">return</span> retriever.get(activity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">       RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">       <span class="keyword">return</span> retriever.get(activity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@TargetApi</span>(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(android.app.Fragment fragment)</span> </span>&#123;</span><br><span class="line">       RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">       <span class="keyword">return</span> retriever.get(fragment);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">       RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">       <span class="keyword">return</span> retriever.get(fragment);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>每一个with()方法重载的代码都非常简单，都是先调用RequestManagerRetriever的静态get()方法得到一个RequestManagerRetriever对象，这个静态get()方法就是一个单例实现。然后再调用RequestManagerRetriever的实例get()方法，去获取RequestManager对象。换句话说，每一个Activity存在一个对应的RequestManager，每一个不同的Fragment也有其对应的RequestManager，而整个应用运行阶段同样会有一个RequestManager。这些不同的RequestManager通过RequestManagerRetriever.get获取。RequestManagerRetriever同样重载了多个get方法，以get(FragmentActivity)为例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestManagerRetriever</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">      <span class="keyword">return</span> supportFragmentGet(activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里从是否在主线程的角度来看：</p>
<ul>
<li>1 若在主线程，则获得Activity对应的FragmentManager来获得RequestManager（Fragment同理）。</li>
<li>2 若在非主线程，那么不管你是传入的Activity还是Fragment，都会被强制当成Application来处理 。</li>
</ul>
<p>也可以从传入Application和非Application的角度来看：</p>
<ul>
<li>1 传Application，因为Application对象的生命周期即应用程序的生命周期，因此Glide并不需要做什么特殊的处理，它自动就是和应用程序的生命周期是同步的，如果应用程序关闭的话，Glide的加载也会同时终止。</li>
<li>2 传非Application，传入非Application参数的情况。不管在Glide.with()方法中传入的是Activity、FragmentActivity、v4包下的Fragment、还是app包下的Fragment，最终的流程都是一样的，那就是会向当前的Activity当中添加一个隐藏的Fragment。因为Glide需要知道加载的生命周期。很简单的一个道理，如果你在某个Activity上正在加载着一张图片，结果图片还没加载出来，Activity就被用户关掉了，那么图片还应该继续加载吗？当然不应该。可是Glide并没有办法知道Activity的生命周期，于是Glide就使用了添加隐藏Fragment的这种小技巧，因为Fragment的生命周期和Activity是同步的，如果Activity被销毁了，Fragment是可以监听到的，这样Glide就可以捕获这个事件并停止图片加载了。</li>
</ul>
<p>那么</p>
<h4 id="如何绑定生命周期"><a href="#如何绑定生命周期" class="headerlink" title="如何绑定生命周期"></a>如何绑定生命周期</h4><p>继续接着上面的代码看supportFragmentGet<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RequestManager <span class="title">supportFragmentGet</span><span class="params">(Context context, FragmentManager fm)</span> </span>&#123;</span><br><span class="line">       SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);</span><br><span class="line">       RequestManager requestManager = current.getRequestManager();</span><br><span class="line">       <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">           requestManager = <span class="keyword">new</span> RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">           current.setRequestManager(requestManager);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> requestManager;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在fragment 中创建RequestManager，并且传入getLifecycle()，通过Lifecycle实现生命周期的绑定</p>
<h3 id="load-方法"><a href="#load-方法" class="headerlink" title="load()方法"></a>load()方法</h3><p><code>Glide.with</code>获得RequestManager之后，执行load方法设置图片源。图片源可以是：图片数据字节数组、File文件，网络图片地址等。以<code>load(String)</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestManager</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load方法默认设置目标资源为 <strong>Drawable</strong>，获得一个RequestBuilder。紧接着调用<code>RequestBuilder.load</code>方法记录加载的model(图片源)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(@Nullable Object model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    isModelSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestBuilder是请求构建者，用户可以使用它设置如：单独的缓存策略、加载成功前占位图、加载失败后显示图片等等加载图片的各种配置。当RequestBuilder 构建完成之后，接下来就等待执行这个请求。</p>
<h3 id="into-方法"><a href="#into-方法" class="headerlink" title="into()方法"></a>into()方法</h3><p><code>Glide.with</code>获得RequestManager之后，执行load方法设置图片源。图片源可以是：图片数据字节数组、File文件，网络图片地址等。以<code>load(String)</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestManager</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load方法默认设置目标资源为 <strong>Drawable</strong>，获得一个RequestBuilder。紧接着调用<code>RequestBuilder.load</code>方法记录加载的model(图片源)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(@Nullable Object model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    isModelSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestBuilder是请求构建者，用户可以使用它设置如：单独的缓存策略、加载成功前占位图、加载失败后显示图片等等加载图片的各种配置。当RequestBuilder 构建完成之后，接下来就等待执行这个请求。</p>
<p>使用Glide最简单的方式加载图片最后一个阶段就是执行into方法。从into方法为入口开始执行图片加载，逻辑也开始复杂起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestBuilder</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(@NonNull ImageView view)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line"></span><br><span class="line">    BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">        &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">        &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Clone in this method so that if we use this RequestBuilder to load into a View and then</span></span><br><span class="line">      <span class="comment">// into a different target, we don't retain the transformation applied based on the previous</span></span><br><span class="line">      <span class="comment">// View's scale type.</span></span><br><span class="line">      <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">        <span class="keyword">case</span> FIT_START:</span><br><span class="line">        <span class="keyword">case</span> FIT_END:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FIT_XY:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CENTER:</span><br><span class="line">        <span class="keyword">case</span> MATRIX:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// Do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> into(</span><br><span class="line">        glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">        <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">        requestOptions,</span><br><span class="line">        Executors.mainThreadExecutor());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，我们在执行into时传入一个ImageView用于显示。在这个into方法中，先确定本次加载的BaseRequestOptions，然后执行重载的另一个into方法。其中BaseRequestOptions就是上面我们提到的RequestBuilder可以设置图片加载的各种配置，这些配置选项就被封装在BaseRequestOptions中(RequestBuilder extends BaseRequestOptions)。而重载的into方法实现为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GenericRequestBuilder</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(Y target)</span> </span>&#123;</span><br><span class="line">        Util.assertMainThread();</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must pass in a non null Target"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must first set a model (try #load())"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Request previous = target.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            previous.clear();</span><br><span class="line">            requestTracker.removeRequest(previous);</span><br><span class="line">            previous.recycle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Request request = buildRequest(target);</span><br><span class="line">        target.setRequest(request);</span><br><span class="line">        lifecycle.addListener(target);</span><br><span class="line">        requestTracker.runRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个into方法中首先调用 buildRequest 构建了一个请求Request，然后把Request交给RequestManager跟踪(生命周期)并启动请求。<br>跟进requestTracker.runRequest()；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Starts tracking the given request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">      requests.add(request);</span><br><span class="line">      <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">          request.begin();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          pendingRequests.add(request);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>先判断Glide当前是不是处理暂停状态，如果不是暂停状态就调用Request的begin()方法来执行Request，否则的话就先将Request添加到待执行队列里面，等暂停状态解除了之后再执行。<br>跟进request.begin();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onException(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target.getSize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(<span class="string">"finished run method in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>跟进onException(null);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"load failed"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = Status.FAILED;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> what if this is a thumbnail request?</span></span><br><span class="line">    <span class="keyword">if</span> (requestListener == <span class="keyword">null</span> || !requestListener.onException(e, model, target, isFirstReadyResource())) &#123;</span><br><span class="line">        setErrorPlaceholder(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再跟setErrorPlaceholder(e);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">          Log.d(TAG, <span class="string">"load failed"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      status = Status.FAILED;</span><br><span class="line">      <span class="comment">//<span class="doctag">TODO:</span> what if this is a thumbnail request?</span></span><br><span class="line">      <span class="keyword">if</span> (requestListener == <span class="keyword">null</span> || !requestListener.onException(e, model, target, isFirstReadyResource())) &#123;</span><br><span class="line">          setErrorPlaceholder(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setErrorPlaceholder</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!canNotifyStatusChanged()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Drawable error = model == <span class="keyword">null</span> ? getFallbackDrawable() : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">        error = getErrorDrawable();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">          error = getPlaceholderDrawable();</span><br><span class="line">      &#125;</span><br><span class="line">      target.onLoadFailed(e, error);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>其实就是将这张error占位图显示到ImageView上而已，因为现在出现了异常，没办法展示正常的图片了。而如果你仔细看下刚才begin()方法的第15行，你会发现它又调用了一个target.onLoadStarted()方法，并传入了一个loading占位图，在也就说，在图片请求开始之前，会先使用这张占位图代替最终的图片显示。</p>
<p>回到begin()，主要是判断当前Request的各种状态并且设置占位图，而启动加载是在第四步开始的。当用户设置了图片的宽高时执行<code>onSizeReady</code>启动加载，而如果未设置则会执行<code>target.getSize(this)</code>计算目标View(需要显示的ImageView)的大小，在计算完之后，它也会调用onSizeReady()方法。也就是说，不管是哪种情况，最终都会调用到onSizeReady()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">      status = Status.RUNNING;</span><br><span class="line">      loadStatus =</span><br><span class="line">          engine.load(</span><br><span class="line">              glideContext,</span><br><span class="line">              model,</span><br><span class="line">              requestOptions.getSignature(),</span><br><span class="line">              <span class="keyword">this</span>.width,</span><br><span class="line">              <span class="keyword">this</span>.height,</span><br><span class="line">              requestOptions.getResourceClass(),</span><br><span class="line">              transcodeClass,</span><br><span class="line">              priority,</span><br><span class="line">              requestOptions.getDiskCacheStrategy(),</span><br><span class="line">              requestOptions.getTransformations(),</span><br><span class="line">              requestOptions.isTransformationRequired(),</span><br><span class="line">              requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">              requestOptions.getOptions(),</span><br><span class="line">              requestOptions.isMemoryCacheable(),</span><br><span class="line">              requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">              requestOptions.getUseAnimationPool(),</span><br><span class="line">              requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">              <span class="keyword">this</span>,</span><br><span class="line">              callbackExecutor);</span><br><span class="line">      <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onSizeReady将获得一系列的值一起传入到了Engine的load()方法当中开始加载图片。</p>
<p><strong>Engine</strong>类顾名思义:引擎，是Glide加载的发动机，跟进Engine的load()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="comment">//1、根据参数（模型、宽、高等）构建加载的标识key</span></span><br><span class="line">    EngineKey key =</span><br><span class="line">        keyFactory.buildKey(</span><br><span class="line">            model,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            transformations,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            options);</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Loaded resource from active resources"</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Loaded resource from cache"</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">      current.addCallback(cb, callbackExecutor);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Added to existing load"</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2、创建新的job并执行加载</span></span><br><span class="line">    EngineJob&lt;R&gt; engineJob =</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">            key,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache);</span><br><span class="line"> <span class="comment">// DecodeJob就是一个Runnable,EngineJob包含的线程池启动线程并能够接收线程中执行过程的回调</span></span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">        decodeJobFactory.build(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            key,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            diskCacheStrategy,</span><br><span class="line">            transformations,</span><br><span class="line">            isTransformationRequired,</span><br><span class="line">            isScaleOnlyOrNoTransform,</span><br><span class="line">            onlyRetrieveFromCache,</span><br><span class="line">            options,</span><br><span class="line">            engineJob);</span><br><span class="line"></span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">    engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line">    <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(<span class="string">"Started new load"</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果引擎中没有同样的正在加载的请求，此处会创建一个实现了Runable接口的DecodeJob并执行。<br>跟进engineJob.start(decodeJob);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EngineJob </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    GlideExecutor executor =</span><br><span class="line">        decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class="line">    executor.execute(decodeJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用线程池执行任务DecodeJob。</p>
<blockquote>
<p>如果需要获取一张图片，那么先从内存缓存中获得，内存缓存不需要进行额外的操作，只要匹配就能直接获取。但是内存缓存不存在，这时候就需要先检查磁盘缓存最后再决定是否需要向图片源(如网络)进行加载。而无论是进行图片磁盘缓存的获取还是向网络请求都是耗时操作，这时候就需要开启线程来执行加载。因此内存缓存一旦不存在，就会使用线程池开启DecodeJob异步任务。而DecodeJob中就会去磁盘缓存查找或者网络中下载图片。</p>
</blockquote>
<p>DecodeJob是实现了Runable接口的一个任务，当使用线程去执行这个任务，自然就会执行run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DecodeJob</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">      runWrapped();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>run方法中除了取消与加载失败的判断，核心的加载逻辑都放在了runWrapped中。在介绍这个方法之前，先简单的了解下Glide中磁盘缓存。 Glide可以缓存两种不同的数据在磁盘文件中：</p>
<ul>
<li>1 资源类型（Resource） - 曾被解码、转换并写入的磁盘缓存。如对原图片进行了缩放，存放缩放后的图片。</li>
<li>2 数据来源 (Data) - 原图片缓存</li>
</ul>
<p>而runWrapped方法的实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DecodeJob</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">      <span class="keyword">case</span> INITIALIZE: </span><br><span class="line">        <span class="comment">// 1. 获取任务的场景</span></span><br><span class="line">        stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">        <span class="comment">// 2. 获取这个场景的执行者</span></span><br><span class="line">        currentGenerator = getNextGenerator();</span><br><span class="line">        <span class="comment">// 3. 执行者执行任务</span></span><br><span class="line">        runGenerators();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">        <span class="comment">// 当图片数据无法从缓存加载时，会切换执行原因并记录，然后重新提交本任务给线程池</span></span><br><span class="line">        <span class="comment">// （使用另一个线程池执行图片源加载，如：网络加载任务）</span></span><br><span class="line">        runGenerators();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">        <span class="comment">// 切换为解码图片,获得的图片数据，比如网络下载了 a.png 得到其byte数组，</span></span><br><span class="line">        <span class="comment">// byte数组中记录的是png编码后的数据，BitmapFactory.decodeXX 会解码生成Bitmap对象</span></span><br><span class="line">        <span class="comment">// 同时解码过程中可能还需要进行缩放、变换等操作    </span></span><br><span class="line">        decodeFromRetrievedData();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized run reason: "</span> + runReason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stage <span class="title">getNextStage</span><span class="params">(Stage current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">       <span class="comment">// 1 如果配置的缓存策略允许从 资源缓存 中读数据, 则返回 Stage.RESOURCE_CACHE</span></span><br><span class="line">      <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">        <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">            ? Stage.RESOURCE_CACHE</span><br><span class="line">            : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">      <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">        <span class="comment">// 2 如果配置的缓存策略允许从 源数据缓存 中读数据, 则返回 Stage.DATA_CACHE</span></span><br><span class="line">        <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">            ? Stage.DATA_CACHE</span><br><span class="line">            : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">      <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">        <span class="comment">// 3 如果只允许从缓存中获取数据, 则直接 FINISH, 否则返回 Stage.SOURCE,表示加载一个新的资源</span></span><br><span class="line">        <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">      <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">case</span> FINISHED:</span><br><span class="line">        <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unrecognized stage: "</span> + current);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">      <span class="comment">// 资源磁盘缓存的执行者</span></span><br><span class="line">      <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">     <span class="comment">// 源数据磁盘缓存的执行者</span></span><br><span class="line">      <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">case</span> SOURCE:</span><br><span class="line">     <span class="comment">// 无缓存, 获取数据的源的执行者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">case</span> FINISHED:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized stage: "</span> + stage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 调用 DataFetcherGenerator.startNext() 执行请求操作</span></span><br><span class="line">    <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isCancelled</span><br><span class="line">        &amp;&amp; currentGenerator != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class="line">      <span class="comment">//如果执行者未执行，获取下一个场景的执行者</span></span><br><span class="line">      stage = getNextStage(stage);</span><br><span class="line">      currentGenerator = getNextGenerator();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class="line">        reschedule();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We've run out of stages and generators, give up.</span></span><br><span class="line">    <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">      notifyFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecodeJob 任务执行时, 它根据不同的场景, 获取不同的场景执行器, 然后调用了它们的 startNext 方法加载请求任务的数据。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>场景描述</th>
<th>场景执行者</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stage.RESOURCE_CACHE</td>
<td>从磁盘中获取转换后的图片缓存</td>
<td>ResourceCacheGenerator</td>
</tr>
<tr>
<td>Stage.DATA_CACHE</td>
<td>从磁盘中获取原图片缓存数据</td>
<td>DataCacheGenerator</td>
</tr>
<tr>
<td>Stage.SOURCE</td>
<td>图片源请求数据</td>
<td>SourceGenerator</td>
</tr>
</tbody>
</table>
<p>总的来说，Glide在加载图片的时候，会首先从内存缓存获取，如果内存缓存不存在，则会在磁盘缓存中查找，否则从源地址进行加载。</p>
<h2 id="Glide缓存"><a href="#Glide缓存" class="headerlink" title="Glide缓存"></a>Glide缓存</h2><p>简单来说分为 活动缓存（弱引用activeResources），内存缓存（LruResourceCache），资源缓存，数据缓存</p>
<h3 id="活动缓存和内存缓存"><a href="#活动缓存和内存缓存" class="headerlink" title="活动缓存和内存缓存"></a>活动缓存和内存缓存</h3><p>默认情况下，Glide自动就是开启内存缓存的。也就是说，当我们使用Glide加载了一张图片之后，这张图片就会被缓存到内存当中，只要在它还没从内存中被清除之前，下次使用Glide再加载这张图片都会直接从内存当中读取，而不用重新从网络或硬盘上读取了，这样无疑就可以大幅度提升图片的加载效率。比方说你在一个RecyclerView当中反复上下滑动，RecyclerView中只要是Glide加载过的图片都可以直接从内存当中迅速读取并展示出来，从而大大提升了用户体验。不过可以通过这种方式禁掉默认缓存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .skipMemoryCache(true)</span><br><span class="line">     .into(imageView);</span><br><span class="line">//skipMemoryCache传true就可以啦</span><br></pre></td></tr></table></figure></p>
<p>那么看一看原理：<br>load()方法中，我们当时分析到了在loadGeneric()方法中会调用Glide.buildStreamModelLoader()方法来获取一个ModelLoader对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, Y&gt; <span class="function">ModelLoader&lt;T, Y&gt; <span class="title">buildModelLoader</span><span class="params">(Class&lt;T&gt; modelClass, Class&lt;Y&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">           Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">               Log.d(TAG, <span class="string">"Unable to load null model, setting placeholder only"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Glide.get(context).getLoaderFactory().buildModelLoader(modelClass, resourceClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title">get</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">               <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   Context applicationContext = context.getApplicationContext();</span><br><span class="line">                   List&lt;GlideModule&gt; modules = <span class="keyword">new</span> ManifestParser(applicationContext).parse();</span><br><span class="line">                   GlideBuilder builder = <span class="keyword">new</span> GlideBuilder(applicationContext);</span><br><span class="line">                   <span class="keyword">for</span> (GlideModule <span class="keyword">module</span> : modules) &#123;</span><br><span class="line">                       <span class="keyword">module</span>.applyOptions(applicationContext, builder);</span><br><span class="line">                   &#125;</span><br><span class="line">                   glide = builder.createGlide();</span><br><span class="line">                   <span class="keyword">for</span> (GlideModule <span class="keyword">module</span> : modules) &#123;</span><br><span class="line">                       <span class="keyword">module</span>.registerComponents(applicationContext, glide);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> glide;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>跟createGlide（）方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Glide <span class="title">createGlide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (sourceService == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> cores = Math.max(<span class="number">1</span>, Runtime.getRuntime().availableProcessors());</span><br><span class="line">           sourceService = <span class="keyword">new</span> FifoPriorityThreadPoolExecutor(cores);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (diskCacheService == <span class="keyword">null</span>) &#123;</span><br><span class="line">           diskCacheService = <span class="keyword">new</span> FifoPriorityThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       MemorySizeCalculator calculator = <span class="keyword">new</span> MemorySizeCalculator(context);</span><br><span class="line">       <span class="keyword">if</span> (bitmapPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">               <span class="keyword">int</span> size = calculator.getBitmapPoolSize();</span><br><span class="line">               bitmapPool = <span class="keyword">new</span> LruBitmapPool(size);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               bitmapPool = <span class="keyword">new</span> BitmapPoolAdapter();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">           memoryCache = <span class="keyword">new</span> LruResourceCache(calculator.getMemoryCacheSize());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (diskCacheFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">           diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (engine == <span class="keyword">null</span>) &#123;</span><br><span class="line">           engine = <span class="keyword">new</span> Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (decodeFormat == <span class="keyword">null</span>) &#123;</span><br><span class="line">           decodeFormat = DecodeFormat.DEFAULT;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Glide(engine, memoryCache, bitmapPool, context, decodeFormat);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>而 memoryCache = new LruResourceCache(calculator.getMemoryCacheSize()); 就是Glide实现内存缓存所使用的LruCache对象了，有对象还不够，关键在于Engine类load()方法，在load()方法中Glide的图片加载过程中会调用两个方法来获取内存缓存，loadFromCache()和loadFromActiveResources()。这两个方法中一个使用的就是LruCache算法，另一个使用的就是弱引用。我们来看一下它们的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> <span class="keyword">implements</span> <span class="title">EngineJobListener</span>,</span></span><br><span class="line"><span class="class">        <span class="title">MemoryCache</span>.<span class="title">ResourceRemovedListener</span>,</span></span><br><span class="line"><span class="class">        <span class="title">EngineResource</span>.<span class="title">ResourceListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryCache cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class="keyword">boolean</span> isMemoryCacheable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">        <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cached.acquire();</span><br><span class="line">            activeResources.put(key, <span class="keyword">new</span> ResourceWeakReference(key, cached, getReferenceQueue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cached;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">        Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line">        <span class="keyword">final</span> EngineResource result;</span><br><span class="line">        <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">            result = (EngineResource) cached;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="keyword">new</span> EngineResource(cached, <span class="keyword">true</span> <span class="comment">/*isCacheable*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, <span class="keyword">boolean</span> isMemoryCacheable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EngineResource&lt;?&gt; active = <span class="keyword">null</span>;</span><br><span class="line">        WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key);</span><br><span class="line">        <span class="keyword">if</span> (activeRef != <span class="keyword">null</span>) &#123;</span><br><span class="line">            active = activeRef.get();</span><br><span class="line">            <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">                active.acquire();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                activeResources.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> active;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在loadFromCache()方法的一开始，首先就判断了isMemoryCacheable是不是false，如果是false的话就直接返回null，意思是刚刚的skipMemoryCache()方法，如果在这个方法中传入true，那么这里的isMemoryCacheable就会是false，表示内存缓存已被禁用。</p>
<p>我们继续住下看，接着调用了getEngineResourceFromCache()方法来获取缓存。在这个方法中，会使用缓存Key来从cache当中取值，而这里的cache对象就是在构建Glide对象时创建的LruResourceCache，那么说明这里其实使用的就是LruCache算法了。</p>
<p>但是，当我们从LruResourceCache中获取到缓存图片之后会将它从缓存中移除，然后将这个缓存图片存储到activeResources当中。activeResources就是一个弱引用的HashMap，用来缓存正在使用中的图片，我们可以看到，loadFromActiveResources()方法就是从activeResources这个HashMap当中取值的。使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。</p>
<p>概括一下来说，就是如果能从内存缓存当中读取到要加载的图片，那么就直接进行回调，如果读取不到的话，才会开启线程执行后面的图片加载逻辑。</p>
<h3 id="资源缓存，数据缓存"><a href="#资源缓存，数据缓存" class="headerlink" title="资源缓存，数据缓存"></a>资源缓存，数据缓存</h3><p>用法上，它也是可禁的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .diskCacheStrategy(DiskCacheStrategy.NONE)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure></p>
<p>调用diskCacheStrategy()方法并传入DiskCacheStrategy.NONE，就可以禁用掉Glide的硬盘缓存功能了。</p>
<p>这个diskCacheStrategy()方法基本上就是Glide硬盘缓存功能的一切，它可以接收四种参数：</p>
<p>DiskCacheStrategy.NONE： 表示不缓存任何内容。<br>DiskCacheStrategy.SOURCE： 表示只缓存原始图片。<br>DiskCacheStrategy.RESULT： 表示只缓存转换过后的图片（默认选项）。<br>DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。<br>上面四种参数的解释本身并没有什么难理解的地方，当我们使用Glide去加载一张图片的时候，Glide默认并不会将原始图片展示出来，而是会对图片进行压缩和转换（我们会在后面学习这方面的内容）。总之就是经过种种一系列操作之后得到的图片，就叫转换过后的图片。而Glide默认情况下在硬盘缓存的就是转换过后的图片，我们通过调用diskCacheStrategy()方法则可以改变这一默认行为。</p>
<p>接下来还是通过阅读源码来分析一下，Glide的硬盘缓存功能是如何实现的。<br>首先，和内存缓存类似，硬盘缓存的实现也是使用的LruCache算法，而且Google还提供了一个现成的工具类DiskLruCache<br>，Glide开启线程来加载图片后会执行EngineRunnable的run()方法，run()方法中又会调用一个decode()方法，那么我们重新再来看一下这个decode()方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Resource&lt;?&gt; decode() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDecodingFromCache()) &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeFromCache();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeFromSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里会分为两种情况，一种是调用decodeFromCache()方法从硬盘缓存当中读取图片，一种是调用decodeFromSource()来读取原始图片。默认情况下Glide会优先从缓存当中读取，只有缓存中不存在要读取的图片时，才会去读取原始图片。那么我们现在来看一下decodeFromCache()方法的源码，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Resource&lt;?&gt; decodeFromCache() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Resource&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = decodeJob.decodeResultFromCache();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"Exception decoding result from cache: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = decodeJob.decodeSourceFromCache();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里会先去调用DecodeJob的decodeResultFromCache()方法来获取缓存，如果获取不到，会再调用decodeSourceFromCache()方法获取缓存，这两个方法的区别其实就是DiskCacheStrategy.RESULT(压缩后的)和DiskCacheStrategy.SOURCE(原始的)<br>看一下这两个方法的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">decodeResultFromCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!diskCacheStrategy.cacheResult()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;T&gt; transformed = loadFromCache(resultKey);</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">decodeSourceFromCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!diskCacheStrategy.cacheSource()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line"></span><br><span class="line">    Resource&lt;T&gt; decoded = loadFromCache(resultKey.getOriginalKey());</span><br><span class="line">    <span class="keyword">return</span> transformEncodeAndTranscode(decoded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它们都是调用了loadFromCache()方法从缓存当中读取数据，如果是decodeResultFromCache()方法就直接将数据解码并返回，如果是decodeSourceFromCache()方法，还要调用一下transformEncodeAndTranscode()方法先将数据转换一下再解码并返回。<br>看一下loadFromCache()方法的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;T&gt; <span class="title">loadFromCache</span><span class="params">(Key key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File cacheFile = diskCacheProvider.getDiskCache().get(key);</span><br><span class="line">    <span class="keyword">if</span> (cacheFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Resource&lt;T&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            diskCacheProvider.getDiskCache().delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的逻辑非常简单，调用getDiskCache()方法获取到的就是Glide自己编写的DiskLruCache工具类的实例，然后调用它的get()方法并把缓存Key传入，就能得到硬盘缓存的文件了。如果文件为空就返回null，如果文件不为空则将它解码成Resource对象后返回即可。</p>
<h2 id="看源码之前不清楚的两个问题："><a href="#看源码之前不清楚的两个问题：" class="headerlink" title="看源码之前不清楚的两个问题："></a>看源码之前不清楚的两个问题：</h2><ul>
<li><p>1 Glide的方法能在子线程中使用吗？</p>
<blockquote>
<p>Glide的with()方法和load()方法是可以的，其中with()传入的context，若在非主线程，那么不管你是传入的Activity还是Fragment，都会被强制当成Application来处理，可能造成内存泄漏；而into()无法在主线程中使用，会抛出异常“You must call this method on the main thread”</p>
</blockquote>
</li>
<li><p>2 如何处理一个大图的缓存？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">true</span>;<span class="comment">//只读取图片，不加载到内存中</span></span><br><span class="line">        BitmapFactory.decodeFile(file, options);</span><br><span class="line">        options.inSampleSize=computeSampleSize(options, -<span class="number">1</span>, <span class="number">512</span>*<span class="number">512</span>);<span class="comment">//返回合适的inSampleSize值,inSampleSize是缩放参数，必须被二整除</span></span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">false</span>;<span class="comment">//加载到内存中</span></span><br><span class="line">        bitmap = BitmapFactory.decodeFile(file, options);</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/17/数据结构实用总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/17/数据结构实用总结/" itemprop="url">数据结构总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-17T00:00:00+08:00">
                2019-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/17/数据结构实用总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/10/17/数据结构实用总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>实际开发中很少实用数组了，最常见的就是ArrayList，所以从它说起</p>
<ul>
<li><p>1 首先它是基于动态数组的数据结构，和数组一样在物理上是连续的，初始化时大小为10，插入新元素时会判断是否需要扩容，扩容的步长为原大小的50%，扩容时需要复制原来数组，造成开销</p>
</li>
<li><p>2 优势是查找效率很高（因为物理上连续）时间复杂度为O(1)，而插入或者删除指定元素时却需要移动插入位置之后的所有元素，时间复杂度为O（n),而如果在最后面进行插入，那就不需要进行位移，时间复杂度为O(1)</p>
</li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>基于这种情况，于是有了LinkedList</p>
<ul>
<li>1 首先它内部使用基于链表的数据结构实现存储，所以它也具有链表的特点，每一个元素（结点）的地址不连续，通过引用找到当前结点的上一个结点和下一个结点，即插入和删除指定元素效率较高，而get和set则较为低效，时间复杂度为O(n)</li>
</ul>
<h2 id="ArrayList与LinkedList对比"><a href="#ArrayList与LinkedList对比" class="headerlink" title="ArrayList与LinkedList对比"></a>ArrayList与LinkedList对比</h2><p>ArrayList 是线性表（数组）<br>get() 直接读取第几个下标，复杂度 O(1)<br>add(E) 添加元素，直接在后面添加，复杂度O（1）<br>add(index, E)添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O（n）<br>remove（）删除元素，后面的元素需要逐个移动，复杂度O（n）</p>
<p>LinkedList 是链表的操作<br>get() 获取第几个元素，依次遍历，复杂度O(n)<br>add(E) 添加到末尾，复杂度O(1)<br>add(index, E) 添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n)<br>remove（）删除元素，直接指针指向操作，复杂度O(1)</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap可以接受null键值和值，而且是非synchronized的，以及HashMap储存的是键值对，使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法得到哈希值，再结合哈希值与HashMap的长度得到储存Entry对象的位置，而当我们new一个<br>HashMap对象时，没有指定长度的话默认长度是16，若指定了长度则会与指定长度最接近的2的整数次幂作为该对象的初始长度，当该对象的使用率达到0.75时，会发生扩容，扩容后长度依然必须是2的整数次幂。</p>
<p>关于上述内容有几个问题需要思考</p>
<h3 id="为什么HashMap的长度必须是2的整数次幂"><a href="#为什么HashMap的长度必须是2的整数次幂" class="headerlink" title="为什么HashMap的长度必须是2的整数次幂"></a>为什么HashMap的长度必须是2的整数次幂</h3><p>先来看一看HashMap是如何计算出储存每一个Entry对象的位置的</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8031371-0886d83c99bf0275.png?imageMogr2/auto-orient/strip|imageView2/2/w/986/format/webp" alt="图片"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Returns index for hash code h.</span><br><span class="line">    */</span><br><span class="line">   static int indexFor(int h, int length) &#123;</span><br><span class="line">       return h &amp; (length-1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>是对hashcode和(length-1)做与运算<br>此时若length为16或者其他2的幂,则length - 1的值是所有二进制位全为1，那么index的结果等同于hashcode后几位的值，只要输入的hashcode本身分布均匀,hash算法的结果就是均匀的，这样一来大大的降低了哈希碰撞的几率</p>
<h3 id="关于扩容"><a href="#关于扩容" class="headerlink" title="关于扩容"></a>关于扩容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threshold = (int)(capacity * loadFactor);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span><br><span class="line">            hash = (null != key) ? hash(key) : 0;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在put操作时，即向容器中添加元素时，判断当前容器中元素的个数是否达到阈值（当前数组长度乘以负载因子的值）的时候，就要自动扩容了，就是新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p>
<h4 id="扩容负载因子为什么是0-75"><a href="#扩容负载因子为什么是0-75" class="headerlink" title="扩容负载因子为什么是0.75"></a>扩容负载因子为什么是0.75</h4><p>-1.如果负载因子为0.5甚至更低的可能的话，最后得到的临时阈值明显会很小，这样的情况就会造成分配的内存的浪费，存在多余的没用的内存空间，也不满足了哈希表均匀分布的情况。<br>-2.如果负载因子达到了1的情况，也就是Entry数组存满了才发生扩容，这样会出现大量的哈希冲突的情况，出现链表过长，因此造成get查询数据的效率。<br>-3.因此选择了0.5~1的折中数也就是0.75，均衡解决了上面出现的情况,是一种平衡了时间空间开销的方法</p>
<h3 id="HashMap的数据结构Java7和Java8及之后有所区别"><a href="#HashMap的数据结构Java7和Java8及之后有所区别" class="headerlink" title="HashMap的数据结构Java7和Java8及之后有所区别"></a>HashMap的数据结构Java7和Java8及之后有所区别</h3><p>Java7是数组+链表，当发生哈希冲突时以链表的形式存储，链表中存储格式是key-value键值对<br><img src="https://upload-images.jianshu.io/upload_images/8031371-44ed77820f471459.png?imageMogr2/auto-orient/strip|imageView2/2/w/883/format/webp" alt="图片"><br>Java8是数组+链表+红黑树，当发生哈希冲突时以链表的形式存储，当链表长度大于等于8时，以红黑树的形式存储<br><img src="https://upload-images.jianshu.io/upload_images/8031371-b057a459fa1cbccf.png?imageMogr2/auto-orient/strip|imageView2/2/w/1112/format/webp" alt="图片"></p>
<h4 id="为什么链表长度大于等于8时转为红黑树"><a href="#为什么链表长度大于等于8时转为红黑树" class="headerlink" title="为什么链表长度大于等于8时转为红黑树"></a>为什么链表长度大于等于8时转为红黑树</h4><p>这个8的设定很有讲究，是符合泊松分布概率统计学的，即经过概率分析认为超过8的概率很小，对泊松分布不太懂也没关系，在源码注释中有这么一段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* factorial(k)). The first values are:</span><br><span class="line">    *</span><br><span class="line">    * 0:    0.60653066</span><br><span class="line">    * 1:    0.30326533</span><br><span class="line">    * 2:    0.07581633</span><br><span class="line">    * 3:    0.01263606</span><br><span class="line">    * 4:    0.00157952</span><br><span class="line">    * 5:    0.00015795</span><br><span class="line">    * 6:    0.00001316</span><br><span class="line">    * 7:    0.00000094</span><br><span class="line">    * 8:    0.00000006</span><br><span class="line">    * more: less than 1 in ten million</span><br></pre></td></tr></table></figure></p>
<p>官方给的概率，可以说达到8就很难了，所以实际运用中存成红黑树的情况并不多</p>
<h3 id="HashMap为什么是线程不安全的"><a href="#HashMap为什么是线程不安全的" class="headerlink" title="HashMap为什么是线程不安全的"></a>HashMap为什么是线程不安全的</h3><ul>
<li>1 put的时候导致的多线程数据不一致<br>比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的 hash桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的 hash桶索引和线程B要插入的记录计算出来的 hash桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</li>
<li>2 resize而引起死循环<br>这种情况发生在HashMap自动扩容时，当2个线程同时检测到元素个数超过 数组大小 × 负载因子。此时2个线程会在put()方法中调用了resize()，两个线程同时修改一个链表结构会产生一个循环链表（JDK1.7中，会出现resize前后元素顺序倒置的情况）。接下来再想通过get()获取某一个元素，就会出现死循环。</li>
</ul>
<h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><ul>
<li>1 HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</li>
<li>2 HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</li>
<li>3 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li>
<li>4 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</li>
<li>5 HashMap不能保证随着时间的推移Map中的元素次序是不变的。</li>
</ul>
<h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h2><p>SparseArray构造方法中，创建了两个数组mKeys、mValues分别存放int与Object，其默认长度为10。<br>本质上就是两个数组</p>
<p>来看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 构造方法</span><br><span class="line">public SparseArray() &#123;</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构造方法</span><br><span class="line">public SparseArray(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity == 0) &#123;</span><br><span class="line">        mKeys = EmptyArray.INT;</span><br><span class="line">        mValues = EmptyArray.OBJECT;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // key value各自为一个数组，默认长度为10</span><br><span class="line">        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);</span><br><span class="line">        mKeys = new int[mValues.length];</span><br><span class="line">    &#125;</span><br><span class="line">    mSize = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结：</p>
<ul>
<li>1 SparseArray的key为int，value为Object</li>
<li>2 Android中，数据长度小于千时，用于替换HashMap,数据条数特别多的时候，效率会低于HashMap，因为它是基于二分查找去找数据的</li>
<li>3 占用内存空间小，没有额外的Entry对象</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/16/view总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/16/view总结/" itemprop="url">View学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-16T00:00:00+08:00">
                2019-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/16/view总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/16/view总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景以及夙愿"><a href="#背景以及夙愿" class="headerlink" title="背景以及夙愿"></a>背景以及夙愿</h2><ul>
<li>1 写了一些自定义view的需求，希望有个总结，以供日后查阅</li>
<li>2 view不仅仅是自定义view，希望有个全面了解</li>
<li>3 养成研究源码的习惯</li>
</ul>
<h2 id="View概述"><a href="#View概述" class="headerlink" title="View概述"></a>View概述</h2><h3 id="官方文档的介绍"><a href="#官方文档的介绍" class="headerlink" title="官方文档的介绍"></a>官方文档的介绍</h3><p>View is the base class for widgets, which are used to create interactive UI components (buttons, text fields, etc.). The android.view.ViewGroup subclass is the base class for layouts, which are invisible containers that hold other Views (or other ViewGroups) and define their layout properties.<br>意思是说：View是窗口小部件的基类，用于创建交互式UI（Button,TextView等都是它的子类），而android.view.ViewGroup子类是布局的基类，它是包含其他视图（或其他ViewGroups）并定义其布局属性的不可见容器。<br>总结来说：我们看到的所有可视化UI组件都可以看做是View,下面从以下几个方面来了解它</p>
<h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><h3 id="srollTo和srollBy"><a href="#srollTo和srollBy" class="headerlink" title="srollTo和srollBy"></a>srollTo和srollBy</h3><h4 id="看看源码"><a href="#看看源码" class="headerlink" title="看看源码"></a>看看源码</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void scrollTo(int x, int y) &#123;</span><br><span class="line">    if (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        int oldX = mScrollX;</span><br><span class="line">        int oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        if (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Move the scrolled position of your view. This will cause a call to</span><br><span class="line"> * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be</span><br><span class="line"> * invalidated.</span><br><span class="line"> * @param x the amount of pixels to scroll by horizontally</span><br><span class="line"> * @param y the amount of pixels to scroll by vertically</span><br><span class="line"> */</span><br><span class="line">public void scrollBy(int x, int y) &#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><p> srollTo()方法：在当前视图内容偏移至(x , y)坐标处，即显示(可视)区域位于(x , y)坐标处。<br> srollBy()方法：在当前视图内容继续偏移(x , y)个单位，显示(可视)区域也跟着偏移(x,y)个单位。<br> srollTo()和srollBy()移动得都是view的内容，view本身并未移动</p>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p> 下面写了一个demo验证一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br><span class="line">       bn_scrollTo = findViewById(R.id.bn_scrollTo);</span><br><span class="line">       bn_scrollBy = findViewById(R.id.bn_scrollBy);</span><br><span class="line">       text = findViewById(R.id.tv_text);</span><br><span class="line"></span><br><span class="line">       bn_scrollTo.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line">               v.scrollTo(50,50);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       bn_scrollBy.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line">               v.scrollBy(50,50);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行效果<br><img src="https://s2.ax1x.com/2019/07/16/ZbpygP.gif" alt="图片"></p>
<h3 id="通过动画实现"><a href="#通过动画实现" class="headerlink" title="通过动画实现"></a>通过动画实现</h3><h4 id="看例子"><a href="#看例子" class="headerlink" title="看例子"></a>看例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        bn_scrollTo = findViewById(R.id.bn_scrollTo);</span><br><span class="line">        bn_scrollBy = findViewById(R.id.bn_scrollBy);</span><br><span class="line">        text = findViewById(R.id.tv_text);</span><br><span class="line"></span><br><span class="line">        bn_scrollTo.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                //v.scrollTo(50,50);</span><br><span class="line">                ObjectAnimator.ofFloat(bn_scrollTo,&quot;translationX&quot;,0,200,0,0).setDuration(1000).start();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bn_scrollBy.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                //v.scrollBy(50,50);</span><br><span class="line">                ObjectAnimator.ofFloat(bn_scrollBy,&quot;translationX&quot;,0,-200,0,0).setDuration(1000).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果<br><img src="https://s2.ax1x.com/2019/07/16/ZbZOQH.gif" alt="图片"></p>
<h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>这里使用了属性动画ObjectAnimator来实现滑动，个人理解动画并不属于滑动，只是实现了类似滑动的效果，我们可以通过调整动画持续时间setDuration()来做出具有弹性的滑动效果，这里不再多说，关于ObjectAnimator的其他方法可以<a href="https://blog.csdn.net/harvic880925/article/details/50598322" target="_blank" rel="noopener">参考</a></p>
<h3 id="改变LayoutParams"><a href="#改变LayoutParams" class="headerlink" title="改变LayoutParams"></a>改变LayoutParams</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) text.getLayoutParams();</span><br><span class="line">     params.width += 100;</span><br><span class="line">     params.leftMargin += 100;</span><br><span class="line">     text.requestLayout();</span><br></pre></td></tr></table></figure>
<h3 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h3><p>先来看看官方给出的使用样例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private Scroller mScroller = new Scroller(context);</span><br><span class="line">  ...</span><br><span class="line">  public void zoomIn() &#123;</span><br><span class="line">      // Revert any animation currently in progress</span><br><span class="line">      mScroller.forceFinished(true);</span><br><span class="line">      // Start scrolling by providing a starting point and</span><br><span class="line">      // the distance to travel</span><br><span class="line">      mScroller.startScroll(0, 0, 100, 0);</span><br><span class="line">      // Invalidate to request a redraw</span><br><span class="line">      invalidate();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用起来非常简单，我们一个一个方法往下分析<br>先来看看startScroll()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123;</span><br><span class="line">      mMode = SCROLL_MODE;</span><br><span class="line">      mFinished = false;</span><br><span class="line">      mDuration = duration;</span><br><span class="line">      mStartTime = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">      mStartX = startX;</span><br><span class="line">      mStartY = startY;</span><br><span class="line">      mFinalX = startX + dx;</span><br><span class="line">      mFinalY = startY + dy;</span><br><span class="line">      mDeltaX = dx;</span><br><span class="line">      mDeltaY = dy;</span><br><span class="line">      mDurationReciprocal = 1.0f / (float) mDuration;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>startScroll()方法中保存了滑动起点，滑动距离，滑动时间等等这种参数，但是未见具体滑动代码，真正使view产生滑动效果的是invalidate()<br>invalidate()方法会导致view重绘，draw方法中调用computeScroll(),computeScroll()是一个空方法需要自己重写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void computeScroll() &#123;</span><br><span class="line">     if (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">         scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">         invalidate();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>向Scroller获取scrollX，scrollY,通过scrollTo()进行滑动，然后再调用invalidate(),重复上述步骤，循环调用直到滑动结束，至于循环多少次呢，是由computeScrollOffset()决定的。<br>下面仅贴出关键代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Call this when you want to know the new location.  If it returns true,</span><br><span class="line">   * the animation is not yet finished.</span><br><span class="line">   */ </span><br><span class="line">  public boolean computeScrollOffset() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">      int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</span><br><span class="line">  </span><br><span class="line">      if (timePassed &lt; mDuration) &#123;</span><br><span class="line">          switch (mMode) &#123;</span><br><span class="line">          case SCROLL_MODE:</span><br><span class="line">              final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</span><br><span class="line">              mCurrX = mStartX + Math.round(x * mDeltaX);</span><br><span class="line">              mCurrY = mStartY + Math.round(x * mDeltaY);</span><br><span class="line">              break;</span><br><span class="line">         ...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          mCurrX = mFinalX;</span><br><span class="line">          mCurrY = mFinalY;</span><br><span class="line">          mFinished = true;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到是通过当前时间和滑动开始时间的差值所占滑动时间的份数来计算的，返回false则滑动结束，否则继续循环。</p>
<h2 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h2><p>这一节更多的会提炼成文字，源码的分析过程涉及子view，父view各自的事件分发三件套方法，不太容易形成书面语言<br>1、一个view的事件最先传递给它所在的activity的decorview,decorview是当前页面的顶层容器，我们setContentView(R.layout.xxx)设置的view就是decorview的子view<br>2、然后首先调用顶级View的dispathTouchEvent(),在这个方法中通过onInterceptTouchEvent()来判断是否拦截，如果返回true则由顶级view处理，如果返回false则需要判断是否设置了mOnTouchListener,是则调用onTouch(),否则调用onTouchEvent()<br>3、子view继续重复1，2步骤分发</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/19/kotlin总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/kotlin总结/" itemprop="url">Kotlin开发学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-19T00:00:00+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/19/kotlin总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/11/19/kotlin总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="本篇文章的背景以及夙愿"><a href="#本篇文章的背景以及夙愿" class="headerlink" title="本篇文章的背景以及夙愿"></a>本篇文章的背景以及夙愿</h2><ul>
<li>1 增强kotlin开发水平</li>
<li>2 保持更博客的习惯</li>
</ul>
<h2 id="为什么要学习kotlin"><a href="#为什么要学习kotlin" class="headerlink" title="为什么要学习kotlin"></a>为什么要学习kotlin</h2><p>（因为本人是Android开发，所以仅从Android角度来说）</p>
<ul>
<li>1 简介：<br>大型项目迭代过程中，阅读代码+写新需求是必不可少的，不论是同事的代码还是自己的代码，因此代码的简洁程度就成了提升生产力的关键</li>
<li>2 安全可靠：<br>kotlin的设计是可以防止程序因为某些错误挂掉的，举一个例子：空安全，简而言之就是kotlin帮助我们避开空指针异常这类错误，节省后期找错误一步一步debug的时间，这个后面详细说</li>
<li>3 互操作性：<br>和Java无缝连接，几乎可以使用所有Java库</li>
</ul>
<h2 id="个人体验kotlin与Java不同之处"><a href="#个人体验kotlin与Java不同之处" class="headerlink" title="个人体验kotlin与Java不同之处"></a>个人体验kotlin与Java不同之处</h2><p>（val,var常量变量声明，fun声明方法等等请自行百度，此处仅记录用惯了Java原生开发改用kotlin导致不舒服的地方）</p>
<h3 id="when关键字的使用"><a href="#when关键字的使用" class="headerlink" title="when关键字的使用"></a>when关键字的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">when (status) &#123;</span><br><span class="line">STATUS_CAR_GOOD -&gt; &#123;</span><br><span class="line">selectedView(tv_car_status_good, iv_car_status_good)</span><br><span class="line">curCarStatus = getData()?.priceResultKey?.high</span><br><span class="line">&#125;</span><br><span class="line">STATUS_CAR_COMM -&gt; &#123;</span><br><span class="line">selectedView(tv_car_status_common, iv_car_status_common)</span><br><span class="line">curCarStatus = getData()?.priceResultKey?.middle</span><br><span class="line">&#125;</span><br><span class="line">STATUS_CAR_DIFF -&gt; &#123;</span><br><span class="line">selectedView(tv_car_status_diff, iv_car_status_diff)</span><br><span class="line">curCarStatus = getData()?.priceResultKey?.low</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for循环的变形使用"><a href="#for循环的变形使用" class="headerlink" title="for循环的变形使用"></a>for循环的变形使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (itemData in golds) &#123;</span><br><span class="line">num ++</span><br><span class="line">if (num &gt; 3) &#123;</span><br><span class="line">return</span><br><span class="line"> &#125;</span><br><span class="line"> val itemCtrl = AppraiserItemCtrl(mContext, golds)</span><br><span class="line"> val itemView = itemCtrl.createView(ll_appraiser_list)</span><br><span class="line"> itemView.layoutParams = mLayoutParams</span><br><span class="line"> ll_appraiser_list.addView(itemView)</span><br><span class="line"> itemCtrl.setData(itemData)</span><br><span class="line"> itemCtrl.bindView()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i in 1..100)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意kotlin的区间是闭合的，第二个值始终是区间的一部分</p>
<h3 id="object关键字在声明单例，接口时的使用"><a href="#object关键字在声明单例，接口时的使用" class="headerlink" title="object关键字在声明单例，接口时的使用"></a>object关键字在声明单例，接口时的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mContentListRecyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() &#123;</span><br><span class="line">override fun onScrollStateChanged(recyclerView: RecyclerView?, newState: Int) &#123;</span><br><span class="line">super.onScrollStateChanged(recyclerView, newState)</span><br><span class="line">if (recyclerView == null) &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">when (newState) &#123;</span><br><span class="line">RecyclerView.SCROLL_STATE_IDLE -&gt; &#123;</span><br><span class="line">if (!recyclerView.canScrollVertically(-1)) &#123;</span><br><span class="line">appbar.setExpanded(true, true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">RecyclerView.SCROLL_STATE_DRAGGING -&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">RecyclerView.SCROLL_STATE_SETTLING -&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="伴生对象代替static"><a href="#伴生对象代替static" class="headerlink" title="伴生对象代替static"></a>伴生对象代替static</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">companion object &#123;</span><br><span class="line">const val TYPE_AROUND = 0</span><br><span class="line">const val TYPE_REFERENCE = 1</span><br><span class="line">const val TYPE_RECOM_CAR = 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>companion object修饰的对象或方法，等同于静态对象或方法</p>
<h3 id="创建单例"><a href="#创建单例" class="headerlink" title="创建单例"></a>创建单例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object Resource &#123;</span><br><span class="line">    val name = &quot;Name&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="压缩代码方面"><a href="#压缩代码方面" class="headerlink" title="压缩代码方面"></a>压缩代码方面</h3><ul>
<li>1 findviewbyid<br>kotlin是不需要写findviewbyid的，可直接指向id</li>
<li>2 with和apply</li>
</ul>
<h3 id="可空性"><a href="#可空性" class="headerlink" title="可空性"></a>可空性</h3><ul>
<li>1 ?.<br>可空修饰符<br>对有可能为空的变量用该修饰符修饰可以避免空指针异常，被？修饰的变量只会调用非空值的方法，若为空会返回null</li>
<li><p>2 ?:<br>kotlin中没有像Java中的三元判断，但个人感觉这个很像，一定程度上可以替代，详见代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun strLenSafe(s:String):Int = s?.length ?: 0 </span><br><span class="line">&gt;&gt;&gt;println(strLenSafe(&quot;abc&quot;))</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt;println(strLenSafe(null))</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 let<br>.let{ }是不为空的时候执行,否则什么都不会发生</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val data = ...</span><br><span class="line"></span><br><span class="line">data?.let &#123;</span><br><span class="line">    ... // 如果不为空，请执行此块操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4 lateinit<br>在Kotlin中，声明为具有非空类型的属性必须在构造函数中初始化，但是往往不希望在构造函数中初始化，例如在通过依赖注入或单元测试的设置方法来初始化属性的时候，不能在构造器中提供一个非空的初始化语句，为了处理这种情况，就要在属性上加lateinit关键字来延迟初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class BuyAndSellAppraiseCtrl(context: Context) : Ctrl&lt;GAppraiseResultResponse&gt;(context) &#123;</span><br><span class="line">    private lateinit var tv_car_status_top_msg: TextView</span><br><span class="line">    private lateinit var tv_ge_ren_che: TextView</span><br><span class="line">    private lateinit var tv_ge_ren_che_value: TextView</span><br><span class="line">    private lateinit var tv_ge_ren_che_area1: TextView</span><br><span class="line">    private lateinit var tv_che_shang_che: TextView</span><br><span class="line">    private lateinit var tv_che_shang_che_value: TextView</span><br><span class="line">    private lateinit var tv_che_shang_che_area1: TextView</span><br><span class="line">    private lateinit var tv_che_shang_shou_che: TextView</span><br><span class="line">    private lateinit var tv_che_shang_shou_che_value: TextView</span><br><span class="line">    private lateinit var tv_che_shang_shou_che_area1: TextView</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>lateinit只能够在var类型的属性中，不能用于构造函数，而且属性不能有自定义的getter和setting，这些属性必须是非空类型，并且不能是基本类型。</p>
<ul>
<li>5 !!<br>不可空修饰符<br>个人认为使用场景不是很多，而且会带来很多问题，慎用<br>未完待续^_^</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/09/handler_sum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/09/handler_sum/" itemprop="url">handler学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-09T00:00:00+08:00">
                2018-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/09/handler_sum/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/09/09/handler_sum/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景以及夙愿"><a href="#背景以及夙愿" class="headerlink" title="背景以及夙愿"></a>背景以及夙愿</h2><ul>
<li>1 练习博客排版</li>
<li>2 尝试阅读源码，从熟悉的handler开始</li>
<li>3 习惯养成</li>
</ul>
<h2 id="handler是什么？"><a href="#handler是什么？" class="headerlink" title="handler是什么？"></a>handler是什么？</h2><p>Handler主要用于异步消息的处理： 有点类似辅助类，封装了消息投递、消息处理等接口。当发出一个消息之后，首先进入一个消息队列，发送消息的函数即刻返回，而另外一个部分在消息队列中逐一将消息取出，然后对消息进行处理，也就是发送消息和接收消息不是同步的处理。 这种机制通常用来处理相对耗时比较长的操作。</p>
<h2 id="handler使用场景"><a href="#handler使用场景" class="headerlink" title="handler使用场景"></a>handler使用场景</h2><p>在Android系统中出于性能优化考虑，Android的UI操作并不是线程安全的，这意味着如果有多个线程并发操作UI组件，可能导致线程安全问题。为了解决这个问题，Android制定了一条简单的原则，只允许UI线程（亦即主线程）修改Activity中的UI组件。但实际上，有部分UI需要在子线程中控制其修改逻辑，因此子线程需要通过handler通知主线程修改UI，实现线程间通信。</p>
<h2 id="handler的使用"><a href="#handler的使用" class="headerlink" title="handler的使用"></a>handler的使用</h2><h3 id="1-post或postDelayed"><a href="#1-post或postDelayed" class="headerlink" title="1 post或postDelayed"></a>1 post或postDelayed</h3><p>区别在于一个立即执行，一个延时执行<br>下面以延时操作为例</p>
<p>直接上代码举个小例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Handler().postDelayed(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        goHome();//可做UI操作等等</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 2000); // 延时2秒</span><br></pre></td></tr></table></figure></p>
<h3 id="2-sendMessage"><a href="#2-sendMessage" class="headerlink" title="2 sendMessage"></a>2 sendMessage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private TabLayout mTab;</span><br><span class="line">    private ViewPager mVp;</span><br><span class="line">    private ViewPagerAapter mvpAapter;</span><br><span class="line">    public ArrayList&lt;String&gt; mlist = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public ArrayList&lt;ImageView&gt; mlistIv = new ArrayList&lt;&gt;();</span><br><span class="line">    private ImageView v1, v2, v3;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mVp = findViewById(R.id.view1);</span><br><span class="line">        mTab = findViewById(R.id.tab);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line"></span><br><span class="line">        mlist.add(&quot;daxifu&quot;);</span><br><span class="line">        mlist.add(&quot;erxifu&quot;);</span><br><span class="line">        mlist.add(&quot;sanxifu&quot;);</span><br><span class="line"></span><br><span class="line">        //mTab.setTabMode(TabLayout.MODE_FIXED);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; mlist.size(); i++) &#123;</span><br><span class="line">            mTab.addTab(mTab.newTab().setText(mlist.get(i)));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        v1 = new ImageView(this);</span><br><span class="line">        v2 = new ImageView(this);</span><br><span class="line">        v3 = new ImageView(this);</span><br><span class="line"></span><br><span class="line">        v1.setImageResource(R.drawable.app_launch_01);</span><br><span class="line">        v2.setImageResource(R.drawable.app_launch_02);</span><br><span class="line">        v3.setImageResource(R.drawable.app_launch_03);</span><br><span class="line"></span><br><span class="line">//        v1.setScaleType(ImageView.ScaleType.FIT_XY);</span><br><span class="line">//        v2.setScaleType(ImageView.ScaleType.FIT_XY);</span><br><span class="line">//        v3.setScaleType(ImageView.ScaleType.FIT_XY);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mlistIv.add(v1);</span><br><span class="line">        mlistIv.add(v2);</span><br><span class="line">        mlistIv.add(v3);</span><br><span class="line"></span><br><span class="line">        mTab.setupWithViewPager(mVp);</span><br><span class="line"></span><br><span class="line">        mvpAapter = new ViewPagerAapter(mlist, mlistIv);</span><br><span class="line">        mVp.setAdapter(mvpAapter);</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line"></span><br><span class="line">                for (int i  = 1; i &lt; 4; i++)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(3000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Message message = new Message();</span><br><span class="line">                    message.what = i;</span><br><span class="line"></span><br><span class="line">                    mhandler.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    private Handler mhandler = new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    v1.setImageResource(R.drawable.app_fuli_01);</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    v2.setImageResource(R.drawable.app_fuli_02);</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">                case 3:</span><br><span class="line">                    v3.setImageResource(R.drawable.app_fuli_03);</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><img src="https://s1.ax1x.com/2018/09/15/iV8gAA.gif" alt="图片"></p>
<h3 id="handler的内存泄漏"><a href="#handler的内存泄漏" class="headerlink" title="handler的内存泄漏"></a>handler的内存泄漏</h3><p>上面的代码有没有发现一些问题或风险，没错就是内存泄漏</p>
<h4 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h4><p>Java使用有向图机制，通过GC自动检查内存中的对象（什么时候检查由虚拟机决定），如果GC发现一个或一组对象为不可到达状态，则将该对象从内存中回收。也就是说，一个对象不被任何引用所指向，则该对象会在被GC发现的时候被回收；另外，如果一组对象中只包含互相的引用，而没有来自它们外部的引用（例如有两个对象A和B互相持有引用，但没有任何外部对象持有指向A或B的引用），这仍然属于不可到达，同样会被GC回收。而一旦GC因为某些对象持有外部引用而无法回收资源时就会发生内存泄露，这部分内存即没有被使用又无法被回收，积少成多就会造成oom，以现在的手机性能造成oom的情况极少，但内存泄露处理仍是android代码质量高低的重要标准之一</p>
<h4 id="为什么handler会造成内存泄露"><a href="#为什么handler会造成内存泄露" class="headerlink" title="为什么handler会造成内存泄露"></a>为什么handler会造成内存泄露</h4><p>当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用（不然你怎么可能通过Handler来操作Activity中的View？）。而Handler通常会伴随着一个耗时的后台线程（例如从网络拉取图片）一起出现，这个后台线程在任务执行完毕（例如图片下载完毕）之后，通过消息机制通知Handler，然后Handler把图片更新到界面。然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用（不然它怎么发消息给Handler？），这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束（例如图片下载完毕）。另外，如果你执行了Handler的postDelayed()方法，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，那么在你设定的delay到达之前，会有一条MessageQueue -&gt; Message -&gt; Handler -&gt; Activity的链，导致你的Activity被持有引用而无法被回收。</p>
<h4 id="如何来处理handler内存泄露"><a href="#如何来处理handler内存泄露" class="headerlink" title="如何来处理handler内存泄露"></a>如何来处理handler内存泄露</h4><p>目前方式有如下几种</p>
<h5 id="方法一：通过程序逻辑来进行保护。"><a href="#方法一：通过程序逻辑来进行保护。" class="headerlink" title="方法一：通过程序逻辑来进行保护。"></a>方法一：通过程序逻辑来进行保护。</h5><p>1.在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。</p>
<p>2.如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。</p>
<h5 id="方法二：将Handler声明为静态类和加入弱引用"><a href="#方法二：将Handler声明为静态类和加入弱引用" class="headerlink" title="方法二：将Handler声明为静态类和加入弱引用"></a>方法二：将Handler声明为静态类和加入弱引用</h5><p>有很多文章说设为静态类就可以了，但是实际操作事会发现，由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）：</p>
<h6 id="小扩展：什么是弱引用？"><a href="#小扩展：什么是弱引用？" class="headerlink" title="小扩展：什么是弱引用？"></a>小扩展：什么是弱引用？</h6><p>WeakReference弱引用，与强引用（即我们常说的引用）相对，它的特点是，GC在回收时会忽略掉弱引用，即就算有弱引用指向某对象，但只要该对象没有被强引用指向（实际上多数时候还要求没有软引用，但此处软引用的概念可以忽略），该对象就会在被GC检查到时回收掉。对于上面的代码，用户在关闭Activity之后，就算后台线程还没结束，但由于仅有一条来自Handler的弱引用指向Activity，所以GC仍然会在检查的时候把Activity回收掉。这样，内存泄露的问题就不会出现了。</p>
<h6 id="上面的杨幂demo修正版本："><a href="#上面的杨幂demo修正版本：" class="headerlink" title="上面的杨幂demo修正版本："></a>上面的杨幂demo修正版本：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">//仅给出部分代码，主要看handler的变动</span><br><span class="line">  @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line">        final MyHandler myHandler = new MyHandler(this);</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line"></span><br><span class="line">                for (int i  = 1; i &lt; 4; i++)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(3000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Message message = new Message();</span><br><span class="line">                    message.what = i;</span><br><span class="line"></span><br><span class="line">                    myHandler.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   class MyHandler extends Handler&#123;</span><br><span class="line"></span><br><span class="line">        WeakReference&lt;SwipeViewPager&gt; mWeak;</span><br><span class="line"></span><br><span class="line">        public MyHandler(SwipeViewPager swipeViewPager) &#123;</span><br><span class="line">            mWeak = new WeakReference&lt;SwipeViewPager&gt;(swipeViewPager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">            SwipeViewPager swipeViewPager = (SwipeViewPager) mWeak.get();</span><br><span class="line"></span><br><span class="line">            if (swipeViewPager != null) &#123;</span><br><span class="line">                switch (msg.what) &#123;</span><br><span class="line">                    case AUTO_SCORLL:</span><br><span class="line">                        if (isStart) &#123;</span><br><span class="line">                            if (vpAd.getChildCount() &gt; 1) &#123;</span><br><span class="line">                                vpAd.setCurrentItem(vpAd.getCurrentItem() + 1, true);</span><br><span class="line">                            &#125;</span><br><span class="line">                            mHandler.sendEmptyMessageDelayed(AUTO_SCORLL, 5000);</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="handler源码分析"><a href="#handler源码分析" class="headerlink" title="handler源码分析"></a>handler源码分析</h2><h3 id="handler机制概括"><a href="#handler机制概括" class="headerlink" title="handler机制概括"></a>handler机制概括</h3><p>首先用一张图来概括handler以及它的四大“组件”的工作过程</p>
<p><img src="https://s1.ax1x.com/2018/09/27/iMbeEj.png" alt="图片"><br> handler具有两个功能，1.发送消息 2.处理消息<br> handler将消息发送到消息队列，由looper通过轮询从消息队列中将消息取出并派发(通过dispatchMessage()方法)给相应的hanndler，再通过重写handleMessage()方法处理。</p>
<h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>找到构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">        this(null, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> this跟进去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">       if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">           final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">           if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                   (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">               Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                   klass.getCanonicalName());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mLooper = Looper.myLooper(); //指定了looper对象</span><br><span class="line">       if (mLooper == null) &#123;</span><br><span class="line">           //如果是在子线程中，没有首先调用Looper.prepare()的话就会抛出该异常，具体原因稍后分析looper时再分析</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">               &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       mQueue = mLooper.mQueue;   //绑定消息队列</span><br><span class="line">       mCallback = callback;</span><br><span class="line">       mAsynchronous = async;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到主要做了两件事</p>
<ul>
<li>1 指定了looper对象</li>
<li>2 绑定消息队列<br>那么问题来了，我们需要看一下looper的源码，本菜鸡看的时候着实被吓一跳，没有头绪苦思冥想一番想到看一眼官方文档是怎么介绍它的，以下是官网给的使用范例</li>
</ul>
<h3 id="looper"><a href="#looper" class="headerlink" title="looper"></a>looper</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LooperThread extends Thread &#123;</span><br><span class="line">    public Handler mHandler;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line"></span><br><span class="line">        mHandler = new Handler() &#123;</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                // process incoming messages here</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到调用顺序</p>
<ul>
<li>1 Looper.prepare()</li>
<li>2 Looper.loop()<br>以下分别贴出源码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void prepare() &#123;</span><br><span class="line">     prepare(true);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">     if (sThreadLocal.get() != null) &#123; //看这里</span><br><span class="line">         //ThreadLocal相当于一个容器，是线程内部的数据存储类，通过它可以在指定线程中存储数据，</span><br><span class="line">         只有在指定线程中才能获取到存储的数据，对于其他线程是无法获取到的，通过对sThreadLocal.get()的判空，保证了一个线程只能set一个looper</span><br><span class="line">         throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>sThreadLocal若为null则new一个looper对象，若不为null抛出异常。<br>说明</p>
<ul>
<li>1 Looper.prepare()只能调用一次</li>
<li>2 一个线程中仅有一个looper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123; </span><br><span class="line"></span><br><span class="line">      final Looper me = myLooper();</span><br><span class="line">      if (me == null) &#123;</span><br><span class="line">          throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //获取looper实例中的消息队列</span><br><span class="line">      final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">      // Make sure the identity of this thread is that of the local process,</span><br><span class="line">      // and keep track of what that identity token actually is.</span><br><span class="line">      Binder.clearCallingIdentity();</span><br><span class="line">      final long ident = Binder.clearCallingIdentity();</span><br><span class="line">      //无限遍历</span><br><span class="line">      for (;;) &#123; </span><br><span class="line">          //从消息队列中取出消息</span><br><span class="line">          Message msg = queue.next(); // might block</span><br><span class="line">          if (msg == null) &#123;</span><br><span class="line">              // No message indicates that the message queue is quitting.（若取出消息为null则线程阻塞 --翻译一下怕后期自己看不懂）</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">          final Printer logging = me.mLogging;</span><br><span class="line">          if (logging != null) &#123;</span><br><span class="line">              logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                      msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">          final long traceTag = me.mTraceTag;</span><br><span class="line">          if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">              Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">          &#125;</span><br><span class="line">          final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">          final long end;</span><br><span class="line">          try &#123;</span><br><span class="line">              //把消息分发给hangler，稍后分析源码</span><br><span class="line">              msg.target.dispatchMessage(msg);</span><br><span class="line">              end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              if (traceTag != 0) &#123;</span><br><span class="line">                  Trace.traceEnd(traceTag);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (slowDispatchThresholdMs &gt; 0) &#123;</span><br><span class="line">              final long time = end - start;</span><br><span class="line">              if (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                  Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;</span><br><span class="line">                          + Thread.currentThread().getName() + &quot;, h=&quot; +</span><br><span class="line">                          msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (logging != null) &#123;</span><br><span class="line">              logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Make sure that during the course of dispatching the</span><br><span class="line">          // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">          final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">          if (ident != newIdent) &#123;</span><br><span class="line">              Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                      + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                      + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                      + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                      + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">          &#125;</span><br><span class="line">          //释放</span><br><span class="line">          msg.recycleUnchecked();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="曾经的疑问之一：用handler用了好多次，哪次也没写looper-prepare-和looper-loop-也跑的好好的。"><a href="#曾经的疑问之一：用handler用了好多次，哪次也没写looper-prepare-和looper-loop-也跑的好好的。" class="headerlink" title="曾经的疑问之一：用handler用了好多次，哪次也没写looper.prepare()和looper.loop()也跑的好好的。"></a>曾经的疑问之一：用handler用了好多次，哪次也没写looper.prepare()和looper.loop()也跑的好好的。</h4><p>读完源码发现，早在UI线程创建之初，就绑定了一个looper，凡是在主线程中显示什么什么，都不需要我们自己初始化looper，默认使用主线程的looper，那么代码中是什么时候创建主线程的looper的呢，再上一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//在Android应用进程启动时，会默认创建1个主线程</span><br><span class="line">// 创建时，会自动调用ActivityThread的1个静态的main（）方法 = 应用程序的入口</span><br><span class="line">// main（）内则会调用Looper.prepareMainLooper()为主线程生成1个Looper对象</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">        // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">        // disable it here, but selectively enable it later (via</span><br><span class="line">        // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">        CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        // Set the reporter for event logging in libcore</span><br><span class="line">        EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">        // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // End of event ActivityThreadMain.</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="dispatchMessage-msg-分析"><a href="#dispatchMessage-msg-分析" class="headerlink" title="dispatchMessage(msg)分析"></a>dispatchMessage(msg)分析</h3><p>下面我们看dispatchMessage(msg)是如何把消息分发给handler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Handle system messages here.</span><br><span class="line">    */</span><br><span class="line">   public void dispatchMessage(Message msg) &#123;</span><br><span class="line">       if (msg.callback != null) &#123;</span><br><span class="line">           handleCallback(msg); </span><br><span class="line"></span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (mCallback != null) &#123;</span><br><span class="line">               if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //若msg.callback属性为空，则代表使用了sendMessage</span><br><span class="line">           handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>1 检查message的callback是否为null，不为空就交给handleCallback(msg)来处理消息，<br>message的callback是一个runnable对象，实际就是handler.post()所传递的runnable参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static void handleCallback(Message message) &#123;</span><br><span class="line">       message.callback.run();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 检查mCallback是否为空，不为空就调用mCallback.handleMessage(msg)来处理消息，Callback是一个接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Callback interface you can use when instantiating a Handler to avoid</span><br><span class="line">  * having to implement your own subclass of Handler.</span><br><span class="line">  *</span><br><span class="line">  * @param msg A &#123;@link android.os.Message Message&#125; object</span><br><span class="line">  * @return True if no further handling is desired</span><br><span class="line">  */</span><br><span class="line"> public interface Callback &#123;</span><br><span class="line">     public boolean handleMessage(Message msg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 通过callback可以使用Handler mhandler = new Handler(Callback)来创建handler对象，那么callback是什么呢？<br> 上文注释里给出了说明：当不想派生handler的子类时可以使用callback创建handler对象，下面是本例使用callback创建的代码（本人不建议使用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity implements Callback&#123;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  中间代码</span><br><span class="line">   </span><br><span class="line">  */</span><br><span class="line">  @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">      super.onResume();</span><br><span class="line">      final Handler mhandler = new Handler(this);</span><br><span class="line">      new Thread()&#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              super.run();</span><br><span class="line"></span><br><span class="line">              for (int i  = 1; i &lt; 4; i++)&#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      Thread.sleep(3000);</span><br><span class="line">                  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                  Message message = new Message();</span><br><span class="line">                  message.what = i;</span><br><span class="line">                  mhandler.sendMessage(message);</span><br><span class="line">               &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">    @Override</span><br><span class="line">     public boolean handleMessage(Message msg) &#123;</span><br><span class="line">      switch (msg.what) &#123;</span><br><span class="line">          case 1:</span><br><span class="line">              v1.setImageResource(R.drawable.app_fuli_01);</span><br><span class="line"></span><br><span class="line">              break;</span><br><span class="line">          case 2:</span><br><span class="line">              v2.setImageResource(R.drawable.app_fuli_02);</span><br><span class="line"></span><br><span class="line">              break;</span><br><span class="line">          case 3:</span><br><span class="line">              v3.setImageResource(R.drawable.app_fuli_03);</span><br><span class="line"></span><br><span class="line">              break;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 最后通过handleMessage来处理消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Subclasses must implement this to receive messages.</span><br><span class="line">  */</span><br><span class="line"> public void handleMessage(Message msg) &#123;</span><br><span class="line">     //这是一个空方法，需要我们自己在代码业务中重写</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="MessageQueen"><a href="#MessageQueen" class="headerlink" title="MessageQueen"></a>MessageQueen</h3><p>我们一直称呼它为消息队列，但实际它是一个单链表结构，在handler机制中我们设计MessageQueen的两个方法，取出和插入</p>
<h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">        // Return here if the message loop has already quit and been disposed.</span><br><span class="line">        // This can happen if the application tries to restart a looper after quit</span><br><span class="line">        // which is not supported.</span><br><span class="line">        final long ptr = mPtr;</span><br><span class="line">        if (ptr == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">        int nextPollTimeoutMillis = 0;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                // Try to retrieve the next message.  Return if found.</span><br><span class="line">                final long now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = null;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                    // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                    do &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                if (msg != null) &#123;</span><br><span class="line">                    if (now &lt; msg.when) &#123;</span><br><span class="line">                        // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // Got a message.</span><br><span class="line">                        mBlocked = false;</span><br><span class="line">                        if (prevMsg != null) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = null;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        return msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // No more messages.</span><br><span class="line">                    nextPollTimeoutMillis = -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Process the quit message now that all pending messages have been handled.</span><br><span class="line">                if (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // If first time idle, then get the number of idlers to run.</span><br><span class="line">                // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">                // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">                if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                    // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                    mBlocked = true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Run the idle handlers.</span><br><span class="line">            // We only ever reach this code block during the first iteration.</span><br><span class="line">            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">                boolean keep = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!keep) &#123;</span><br><span class="line">                    synchronized (this) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">            pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">            // While calling an idle handler, a new message could have been delivered</span><br><span class="line">            // so go back and look again for a pending message without waiting.</span><br><span class="line">            nextPollTimeoutMillis = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>简单的说，这个函数就是从从头Head取出下一个Message，如果队列中没有message了，那么则可以取处理IdleHandler接口。当队列中没有消息或者消息指定了等待时间，那么线程会进入等待状态。<br>函数中有两个变量<br>int pendingIdleHandlerCount = -1;空闲的IdleHandler个数，只有在第一次迭代的时候为-1。<br>int nextPollTimeoutMillis = 0;下一轮等待时间，如果当前消息队列中没哟消息，需要等待的时间。<br>如果等待时间不为零，执行flush pending command，刷新等待时间。然后执行nativePollOnce(ptr, nextPollTimeoutMillis);其功能是查询消息队列中有没有消息。如果消息为空，那么nextPollTimeoutMillis=-1，接着等待消息，如果不为空，那么就处理这个消息。当我们设置的等待时间到了，将msg从Message中取出来并返回msg，如果没有返回，则说明没有消息需要处理，既然没有消息需要处理，检查以下是否要退出队列，如果退出返回null，否则那么就可以处理IdleHandler，处理完IdleHandler后将nextPollTimeoutMillis设为0（因为在处理IdleHandler的时候可能来消息），重新检测消息。</p>
<h4 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage()"></a>enqueueMessage()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">     if (msg.target == null) &#123;</span><br><span class="line">         throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     if (msg.isInUse()) &#123;</span><br><span class="line">         throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     synchronized (this) &#123;</span><br><span class="line">         if (mQuitting) &#123;</span><br><span class="line">             IllegalStateException e = new IllegalStateException(</span><br><span class="line">                     msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">             Log.w(TAG, e.getMessage(), e);</span><br><span class="line">             msg.recycle();</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         msg.markInUse();</span><br><span class="line">         msg.when = when;</span><br><span class="line">         Message p = mMessages;</span><br><span class="line">         boolean needWake;</span><br><span class="line"></span><br><span class="line">         //判断，如果mMessages对象为空，或者when为0也就是立刻执行，或者新消息的when时间比mMessages队列的when时间还要早</span><br><span class="line">         if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">             // New head, wake up the event queue if blocked.</span><br><span class="line">             //官方注释，当前消息作为新的队列头部，如果阻塞则唤醒</span><br><span class="line">             //就把新的msg插到mMessages的前面 并把next指向它，也就是队列的最前面，等待loop的轮询。</span><br><span class="line">             msg.next = p;</span><br><span class="line">             mMessages = msg;</span><br><span class="line">             needWake = mBlocked;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">             官方注释：插入队列中间。 通常我们不必醒来</span><br><span class="line">             // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">             // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">             needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">             Message prev;</span><br><span class="line">             //when是新消息的执行时间，p.when的是队列中message消息的执行时间，</span><br><span class="line">             如果找到比新的message还要晚执行的消息，</span><br><span class="line">             就执行msg.next = p;prev.next = msg;</span><br><span class="line">             也就是把插到该消息的前面，优先执行新的消息。</span><br><span class="line">             for (;;) &#123;</span><br><span class="line">                 prev = p;</span><br><span class="line">                 p = p.next;</span><br><span class="line">                 if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                     needWake = false;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             msg.next = p; // invariant: p == prev.next</span><br><span class="line">             prev.next = msg;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">         if (needWake) &#123;</span><br><span class="line">             nativeWake(mPtr);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/27/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coding_dog">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding_dog的成长笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/27/hello-world/" itemprop="url">hello world</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-27T00:00:00+08:00">
                2018-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我/" itemprop="url" rel="index">
                    <span itemprop="name">我</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/27/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/08/27/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="大事件"><a href="#大事件" class="headerlink" title="大事件"></a>大事件</h3><p> 20180703 入职新公司，职业生涯正式开始</p>
<p> 20181106 明人不说暗话，得我所爱</p>
<p> 20181206 媳妇超甜纪念视频</p>
<p> 20181223 冰川火山纹身（我们的第一个纹身）</p>
<p> 20190113 人生新高度</p>
<p> 20190615 拍结婚证件照</p>
<p> 20190912 求婚成功</p>
<p> 20190930 第一次一起旅行</p>
<p> 20191109 林俊杰演唱会</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.jpg"
                alt="Coding_dog" />
            
              <p class="site-author-name" itemprop="name">Coding_dog</p>
              <p class="site-description motion-element" itemprop="description">你愿意陪我一起菜鸡变凤凰吗</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Coding_dog</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'lKEXk4PjEE7zRpQT1zDMocSF-gzGzoHsz',
        appKey: 'oUy3OQ2TDAHq3mNInqu0U6eH',
        placeholder: '说两句',
        avatar:'wavatar',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
